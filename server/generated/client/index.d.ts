
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model DeviceStatus
 * 
 */
export type DeviceStatus = $Result.DefaultSelection<Prisma.$DeviceStatusPayload>
/**
 * Model DeviceTelemetry
 * 
 */
export type DeviceTelemetry = $Result.DefaultSelection<Prisma.$DeviceTelemetryPayload>
/**
 * Model EmailVerificationToken
 * 
 */
export type EmailVerificationToken = $Result.DefaultSelection<Prisma.$EmailVerificationTokenPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model FileUploadSession
 * 
 */
export type FileUploadSession = $Result.DefaultSelection<Prisma.$FileUploadSessionPayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model Playlist
 * 
 */
export type Playlist = $Result.DefaultSelection<Prisma.$PlaylistPayload>
/**
 * Model PlaylistItem
 * 
 */
export type PlaylistItem = $Result.DefaultSelection<Prisma.$PlaylistItemPayload>
/**
 * Model PlaylistLayout
 * 
 */
export type PlaylistLayout = $Result.DefaultSelection<Prisma.$PlaylistLayoutPayload>
/**
 * Model PlaylistLayoutSection
 * 
 */
export type PlaylistLayoutSection = $Result.DefaultSelection<Prisma.$PlaylistLayoutSectionPayload>
/**
 * Model PlaylistSchedule
 * 
 */
export type PlaylistSchedule = $Result.DefaultSelection<Prisma.$PlaylistSchedulePayload>
/**
 * Model PlaylistScreen
 * 
 */
export type PlaylistScreen = $Result.DefaultSelection<Prisma.$PlaylistScreenPayload>
/**
 * Model Screen
 * 
 */
export type Screen = $Result.DefaultSelection<Prisma.$ScreenPayload>
/**
 * Model ScreenGroup
 * 
 */
export type ScreenGroup = $Result.DefaultSelection<Prisma.$ScreenGroupPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model UserWorkspace
 * 
 */
export type UserWorkspace = $Result.DefaultSelection<Prisma.$UserWorkspacePayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceUserInvitation
 * 
 */
export type WorkspaceUserInvitation = $Result.DefaultSelection<Prisma.$WorkspaceUserInvitationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PlaylistItemType: {
  File: 'File',
  NestedPlaylist: 'NestedPlaylist'
};

export type PlaylistItemType = (typeof PlaylistItemType)[keyof typeof PlaylistItemType]


export const Weekday: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type Weekday = (typeof Weekday)[keyof typeof Weekday]


export const LayoutRotation: {
  R0: 'R0',
  R90: 'R90',
  R180: 'R180',
  R270: 'R270'
};

export type LayoutRotation = (typeof LayoutRotation)[keyof typeof LayoutRotation]

}

export type PlaylistItemType = $Enums.PlaylistItemType

export const PlaylistItemType: typeof $Enums.PlaylistItemType

export type Weekday = $Enums.Weekday

export const Weekday: typeof $Enums.Weekday

export type LayoutRotation = $Enums.LayoutRotation

export const LayoutRotation: typeof $Enums.LayoutRotation

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Devices
 * const devices = await prisma.device.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Devices
   * const devices = await prisma.device.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceStatus`: Exposes CRUD operations for the **DeviceStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceStatuses
    * const deviceStatuses = await prisma.deviceStatus.findMany()
    * ```
    */
  get deviceStatus(): Prisma.DeviceStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceTelemetry`: Exposes CRUD operations for the **DeviceTelemetry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTelemetries
    * const deviceTelemetries = await prisma.deviceTelemetry.findMany()
    * ```
    */
  get deviceTelemetry(): Prisma.DeviceTelemetryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerificationToken`: Exposes CRUD operations for the **EmailVerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailVerificationTokens
    * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
    * ```
    */
  get emailVerificationToken(): Prisma.EmailVerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileUploadSession`: Exposes CRUD operations for the **FileUploadSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileUploadSessions
    * const fileUploadSessions = await prisma.fileUploadSession.findMany()
    * ```
    */
  get fileUploadSession(): Prisma.FileUploadSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlist`: Exposes CRUD operations for the **Playlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Playlists
    * const playlists = await prisma.playlist.findMany()
    * ```
    */
  get playlist(): Prisma.PlaylistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlistItem`: Exposes CRUD operations for the **PlaylistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaylistItems
    * const playlistItems = await prisma.playlistItem.findMany()
    * ```
    */
  get playlistItem(): Prisma.PlaylistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlistLayout`: Exposes CRUD operations for the **PlaylistLayout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaylistLayouts
    * const playlistLayouts = await prisma.playlistLayout.findMany()
    * ```
    */
  get playlistLayout(): Prisma.PlaylistLayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlistLayoutSection`: Exposes CRUD operations for the **PlaylistLayoutSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaylistLayoutSections
    * const playlistLayoutSections = await prisma.playlistLayoutSection.findMany()
    * ```
    */
  get playlistLayoutSection(): Prisma.PlaylistLayoutSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlistSchedule`: Exposes CRUD operations for the **PlaylistSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaylistSchedules
    * const playlistSchedules = await prisma.playlistSchedule.findMany()
    * ```
    */
  get playlistSchedule(): Prisma.PlaylistScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlistScreen`: Exposes CRUD operations for the **PlaylistScreen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaylistScreens
    * const playlistScreens = await prisma.playlistScreen.findMany()
    * ```
    */
  get playlistScreen(): Prisma.PlaylistScreenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screen`: Exposes CRUD operations for the **Screen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Screens
    * const screens = await prisma.screen.findMany()
    * ```
    */
  get screen(): Prisma.ScreenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenGroup`: Exposes CRUD operations for the **ScreenGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScreenGroups
    * const screenGroups = await prisma.screenGroup.findMany()
    * ```
    */
  get screenGroup(): Prisma.ScreenGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userWorkspace`: Exposes CRUD operations for the **UserWorkspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserWorkspaces
    * const userWorkspaces = await prisma.userWorkspace.findMany()
    * ```
    */
  get userWorkspace(): Prisma.UserWorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceUserInvitation`: Exposes CRUD operations for the **WorkspaceUserInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceUserInvitations
    * const workspaceUserInvitations = await prisma.workspaceUserInvitation.findMany()
    * ```
    */
  get workspaceUserInvitation(): Prisma.WorkspaceUserInvitationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql


  /**
   * Prisma.skip
   */
  export import skip = runtime.skip


  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Device: 'Device',
    DeviceStatus: 'DeviceStatus',
    DeviceTelemetry: 'DeviceTelemetry',
    EmailVerificationToken: 'EmailVerificationToken',
    File: 'File',
    FileUploadSession: 'FileUploadSession',
    Folder: 'Folder',
    Playlist: 'Playlist',
    PlaylistItem: 'PlaylistItem',
    PlaylistLayout: 'PlaylistLayout',
    PlaylistLayoutSection: 'PlaylistLayoutSection',
    PlaylistSchedule: 'PlaylistSchedule',
    PlaylistScreen: 'PlaylistScreen',
    Screen: 'Screen',
    ScreenGroup: 'ScreenGroup',
    Session: 'Session',
    User: 'User',
    UserPreferences: 'UserPreferences',
    UserWorkspace: 'UserWorkspace',
    Workspace: 'Workspace',
    WorkspaceUserInvitation: 'WorkspaceUserInvitation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "device" | "deviceStatus" | "deviceTelemetry" | "emailVerificationToken" | "file" | "fileUploadSession" | "folder" | "playlist" | "playlistItem" | "playlistLayout" | "playlistLayoutSection" | "playlistSchedule" | "playlistScreen" | "screen" | "screenGroup" | "session" | "user" | "userPreferences" | "userWorkspace" | "workspace" | "workspaceUserInvitation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      DeviceStatus: {
        payload: Prisma.$DeviceStatusPayload<ExtArgs>
        fields: Prisma.DeviceStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>
          }
          findFirst: {
            args: Prisma.DeviceStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>
          }
          findMany: {
            args: Prisma.DeviceStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>[]
          }
          create: {
            args: Prisma.DeviceStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>
          }
          createMany: {
            args: Prisma.DeviceStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>[]
          }
          delete: {
            args: Prisma.DeviceStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>
          }
          update: {
            args: Prisma.DeviceStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>
          }
          deleteMany: {
            args: Prisma.DeviceStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>[]
          }
          upsert: {
            args: Prisma.DeviceStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatusPayload>
          }
          aggregate: {
            args: Prisma.DeviceStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceStatus>
          }
          groupBy: {
            args: Prisma.DeviceStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceStatusCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceStatusCountAggregateOutputType> | number
          }
        }
      }
      DeviceTelemetry: {
        payload: Prisma.$DeviceTelemetryPayload<ExtArgs>
        fields: Prisma.DeviceTelemetryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTelemetryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTelemetryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>
          }
          findFirst: {
            args: Prisma.DeviceTelemetryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTelemetryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>
          }
          findMany: {
            args: Prisma.DeviceTelemetryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>[]
          }
          create: {
            args: Prisma.DeviceTelemetryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>
          }
          createMany: {
            args: Prisma.DeviceTelemetryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTelemetryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>[]
          }
          delete: {
            args: Prisma.DeviceTelemetryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>
          }
          update: {
            args: Prisma.DeviceTelemetryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTelemetryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTelemetryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceTelemetryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>[]
          }
          upsert: {
            args: Prisma.DeviceTelemetryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTelemetryPayload>
          }
          aggregate: {
            args: Prisma.DeviceTelemetryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceTelemetry>
          }
          groupBy: {
            args: Prisma.DeviceTelemetryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTelemetryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTelemetryCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTelemetryCountAggregateOutputType> | number
          }
        }
      }
      EmailVerificationToken: {
        payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>
        fields: Prisma.EmailVerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          findMany: {
            args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          create: {
            args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          createMany: {
            args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          update: {
            args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailVerificationToken>
          }
          groupBy: {
            args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      FileUploadSession: {
        payload: Prisma.$FileUploadSessionPayload<ExtArgs>
        fields: Prisma.FileUploadSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileUploadSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileUploadSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>
          }
          findFirst: {
            args: Prisma.FileUploadSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileUploadSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>
          }
          findMany: {
            args: Prisma.FileUploadSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>[]
          }
          create: {
            args: Prisma.FileUploadSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>
          }
          createMany: {
            args: Prisma.FileUploadSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileUploadSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>[]
          }
          delete: {
            args: Prisma.FileUploadSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>
          }
          update: {
            args: Prisma.FileUploadSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>
          }
          deleteMany: {
            args: Prisma.FileUploadSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUploadSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUploadSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>[]
          }
          upsert: {
            args: Prisma.FileUploadSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileUploadSessionPayload>
          }
          aggregate: {
            args: Prisma.FileUploadSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileUploadSession>
          }
          groupBy: {
            args: Prisma.FileUploadSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileUploadSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileUploadSessionCountArgs<ExtArgs>
            result: $Utils.Optional<FileUploadSessionCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      Playlist: {
        payload: Prisma.$PlaylistPayload<ExtArgs>
        fields: Prisma.PlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findFirst: {
            args: Prisma.PlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findMany: {
            args: Prisma.PlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          create: {
            args: Prisma.PlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          createMany: {
            args: Prisma.PlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          delete: {
            args: Prisma.PlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          update: {
            args: Prisma.PlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          aggregate: {
            args: Prisma.PlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylist>
          }
          groupBy: {
            args: Prisma.PlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistCountAggregateOutputType> | number
          }
        }
      }
      PlaylistItem: {
        payload: Prisma.$PlaylistItemPayload<ExtArgs>
        fields: Prisma.PlaylistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          findFirst: {
            args: Prisma.PlaylistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          findMany: {
            args: Prisma.PlaylistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>[]
          }
          create: {
            args: Prisma.PlaylistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          createMany: {
            args: Prisma.PlaylistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>[]
          }
          delete: {
            args: Prisma.PlaylistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          update: {
            args: Prisma.PlaylistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          aggregate: {
            args: Prisma.PlaylistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylistItem>
          }
          groupBy: {
            args: Prisma.PlaylistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistItemCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistItemCountAggregateOutputType> | number
          }
        }
      }
      PlaylistLayout: {
        payload: Prisma.$PlaylistLayoutPayload<ExtArgs>
        fields: Prisma.PlaylistLayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistLayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistLayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>
          }
          findFirst: {
            args: Prisma.PlaylistLayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistLayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>
          }
          findMany: {
            args: Prisma.PlaylistLayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>[]
          }
          create: {
            args: Prisma.PlaylistLayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>
          }
          createMany: {
            args: Prisma.PlaylistLayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistLayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>[]
          }
          delete: {
            args: Prisma.PlaylistLayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>
          }
          update: {
            args: Prisma.PlaylistLayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistLayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistLayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistLayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistLayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutPayload>
          }
          aggregate: {
            args: Prisma.PlaylistLayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylistLayout>
          }
          groupBy: {
            args: Prisma.PlaylistLayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistLayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistLayoutCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistLayoutCountAggregateOutputType> | number
          }
        }
      }
      PlaylistLayoutSection: {
        payload: Prisma.$PlaylistLayoutSectionPayload<ExtArgs>
        fields: Prisma.PlaylistLayoutSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistLayoutSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistLayoutSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>
          }
          findFirst: {
            args: Prisma.PlaylistLayoutSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistLayoutSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>
          }
          findMany: {
            args: Prisma.PlaylistLayoutSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>[]
          }
          create: {
            args: Prisma.PlaylistLayoutSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>
          }
          createMany: {
            args: Prisma.PlaylistLayoutSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistLayoutSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>[]
          }
          delete: {
            args: Prisma.PlaylistLayoutSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>
          }
          update: {
            args: Prisma.PlaylistLayoutSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistLayoutSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistLayoutSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistLayoutSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistLayoutSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistLayoutSectionPayload>
          }
          aggregate: {
            args: Prisma.PlaylistLayoutSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylistLayoutSection>
          }
          groupBy: {
            args: Prisma.PlaylistLayoutSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistLayoutSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistLayoutSectionCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistLayoutSectionCountAggregateOutputType> | number
          }
        }
      }
      PlaylistSchedule: {
        payload: Prisma.$PlaylistSchedulePayload<ExtArgs>
        fields: Prisma.PlaylistScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>
          }
          findFirst: {
            args: Prisma.PlaylistScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>
          }
          findMany: {
            args: Prisma.PlaylistScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>[]
          }
          create: {
            args: Prisma.PlaylistScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>
          }
          createMany: {
            args: Prisma.PlaylistScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>[]
          }
          delete: {
            args: Prisma.PlaylistScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>
          }
          update: {
            args: Prisma.PlaylistScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>
          }
          deleteMany: {
            args: Prisma.PlaylistScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>[]
          }
          upsert: {
            args: Prisma.PlaylistScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSchedulePayload>
          }
          aggregate: {
            args: Prisma.PlaylistScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylistSchedule>
          }
          groupBy: {
            args: Prisma.PlaylistScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistScheduleCountAggregateOutputType> | number
          }
        }
      }
      PlaylistScreen: {
        payload: Prisma.$PlaylistScreenPayload<ExtArgs>
        fields: Prisma.PlaylistScreenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistScreenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistScreenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>
          }
          findFirst: {
            args: Prisma.PlaylistScreenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistScreenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>
          }
          findMany: {
            args: Prisma.PlaylistScreenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>[]
          }
          create: {
            args: Prisma.PlaylistScreenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>
          }
          createMany: {
            args: Prisma.PlaylistScreenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistScreenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>[]
          }
          delete: {
            args: Prisma.PlaylistScreenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>
          }
          update: {
            args: Prisma.PlaylistScreenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistScreenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistScreenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistScreenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistScreenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistScreenPayload>
          }
          aggregate: {
            args: Prisma.PlaylistScreenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylistScreen>
          }
          groupBy: {
            args: Prisma.PlaylistScreenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistScreenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistScreenCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistScreenCountAggregateOutputType> | number
          }
        }
      }
      Screen: {
        payload: Prisma.$ScreenPayload<ExtArgs>
        fields: Prisma.ScreenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>
          }
          findFirst: {
            args: Prisma.ScreenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>
          }
          findMany: {
            args: Prisma.ScreenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>[]
          }
          create: {
            args: Prisma.ScreenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>
          }
          createMany: {
            args: Prisma.ScreenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>[]
          }
          delete: {
            args: Prisma.ScreenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>
          }
          update: {
            args: Prisma.ScreenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>
          }
          deleteMany: {
            args: Prisma.ScreenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScreenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>[]
          }
          upsert: {
            args: Prisma.ScreenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenPayload>
          }
          aggregate: {
            args: Prisma.ScreenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreen>
          }
          groupBy: {
            args: Prisma.ScreenGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenCountAggregateOutputType> | number
          }
        }
      }
      ScreenGroup: {
        payload: Prisma.$ScreenGroupPayload<ExtArgs>
        fields: Prisma.ScreenGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>
          }
          findFirst: {
            args: Prisma.ScreenGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>
          }
          findMany: {
            args: Prisma.ScreenGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>[]
          }
          create: {
            args: Prisma.ScreenGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>
          }
          createMany: {
            args: Prisma.ScreenGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>[]
          }
          delete: {
            args: Prisma.ScreenGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>
          }
          update: {
            args: Prisma.ScreenGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>
          }
          deleteMany: {
            args: Prisma.ScreenGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScreenGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>[]
          }
          upsert: {
            args: Prisma.ScreenGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenGroupPayload>
          }
          aggregate: {
            args: Prisma.ScreenGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenGroup>
          }
          groupBy: {
            args: Prisma.ScreenGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenGroupCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      UserWorkspace: {
        payload: Prisma.$UserWorkspacePayload<ExtArgs>
        fields: Prisma.UserWorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserWorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserWorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>
          }
          findFirst: {
            args: Prisma.UserWorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserWorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>
          }
          findMany: {
            args: Prisma.UserWorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>[]
          }
          create: {
            args: Prisma.UserWorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>
          }
          createMany: {
            args: Prisma.UserWorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserWorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>[]
          }
          delete: {
            args: Prisma.UserWorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>
          }
          update: {
            args: Prisma.UserWorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>
          }
          deleteMany: {
            args: Prisma.UserWorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserWorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserWorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>[]
          }
          upsert: {
            args: Prisma.UserWorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWorkspacePayload>
          }
          aggregate: {
            args: Prisma.UserWorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserWorkspace>
          }
          groupBy: {
            args: Prisma.UserWorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserWorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserWorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<UserWorkspaceCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceUserInvitation: {
        payload: Prisma.$WorkspaceUserInvitationPayload<ExtArgs>
        fields: Prisma.WorkspaceUserInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceUserInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceUserInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceUserInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceUserInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>
          }
          findMany: {
            args: Prisma.WorkspaceUserInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>[]
          }
          create: {
            args: Prisma.WorkspaceUserInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>
          }
          createMany: {
            args: Prisma.WorkspaceUserInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceUserInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceUserInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>
          }
          update: {
            args: Prisma.WorkspaceUserInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceUserInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUserInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUserInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUserInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserInvitationPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceUserInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceUserInvitation>
          }
          groupBy: {
            args: Prisma.WorkspaceUserInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceUserInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserInvitationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    device?: DeviceOmit
    deviceStatus?: DeviceStatusOmit
    deviceTelemetry?: DeviceTelemetryOmit
    emailVerificationToken?: EmailVerificationTokenOmit
    file?: FileOmit
    fileUploadSession?: FileUploadSessionOmit
    folder?: FolderOmit
    playlist?: PlaylistOmit
    playlistItem?: PlaylistItemOmit
    playlistLayout?: PlaylistLayoutOmit
    playlistLayoutSection?: PlaylistLayoutSectionOmit
    playlistSchedule?: PlaylistScheduleOmit
    playlistScreen?: PlaylistScreenOmit
    screen?: ScreenOmit
    screenGroup?: ScreenGroupOmit
    session?: SessionOmit
    user?: UserOmit
    userPreferences?: UserPreferencesOmit
    userWorkspace?: UserWorkspaceOmit
    workspace?: WorkspaceOmit
    workspaceUserInvitation?: WorkspaceUserInvitationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    telemetry: number
    statusLog: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    telemetry?: boolean | DeviceCountOutputTypeCountTelemetryArgs
    statusLog?: boolean | DeviceCountOutputTypeCountStatusLogArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountTelemetryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTelemetryWhereInput | $Types.Skip
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountStatusLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceStatusWhereInput | $Types.Skip
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    playlistItems: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlistItems?: boolean | FileCountOutputTypeCountPlaylistItemsArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountPlaylistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistItemWhereInput | $Types.Skip
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    subfolders: number
    files: number
    fileUploadSessions: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subfolders?: boolean | FolderCountOutputTypeCountSubfoldersArgs
    files?: boolean | FolderCountOutputTypeCountFilesArgs
    fileUploadSessions?: boolean | FolderCountOutputTypeCountFileUploadSessionsArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountSubfoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput | $Types.Skip
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput | $Types.Skip
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountFileUploadSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileUploadSessionWhereInput | $Types.Skip
  }


  /**
   * Count Type PlaylistCountOutputType
   */

  export type PlaylistCountOutputType = {
    items: number
    parentItems: number
    screens: number
    schedules: number
  }

  export type PlaylistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PlaylistCountOutputTypeCountItemsArgs
    parentItems?: boolean | PlaylistCountOutputTypeCountParentItemsArgs
    screens?: boolean | PlaylistCountOutputTypeCountScreensArgs
    schedules?: boolean | PlaylistCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistCountOutputType
     */
    select?: PlaylistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistItemWhereInput | $Types.Skip
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountParentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistItemWhereInput | $Types.Skip
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountScreensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistScreenWhereInput | $Types.Skip
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistScheduleWhereInput | $Types.Skip
  }


  /**
   * Count Type PlaylistLayoutCountOutputType
   */

  export type PlaylistLayoutCountOutputType = {
    playlists: number
    sections: number
  }

  export type PlaylistLayoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlists?: boolean | PlaylistLayoutCountOutputTypeCountPlaylistsArgs
    sections?: boolean | PlaylistLayoutCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * PlaylistLayoutCountOutputType without action
   */
  export type PlaylistLayoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutCountOutputType
     */
    select?: PlaylistLayoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaylistLayoutCountOutputType without action
   */
  export type PlaylistLayoutCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput | $Types.Skip
  }

  /**
   * PlaylistLayoutCountOutputType without action
   */
  export type PlaylistLayoutCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
  }


  /**
   * Count Type PlaylistLayoutSectionCountOutputType
   */

  export type PlaylistLayoutSectionCountOutputType = {
    playlistItems: number
  }

  export type PlaylistLayoutSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlistItems?: boolean | PlaylistLayoutSectionCountOutputTypeCountPlaylistItemsArgs
  }

  // Custom InputTypes
  /**
   * PlaylistLayoutSectionCountOutputType without action
   */
  export type PlaylistLayoutSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSectionCountOutputType
     */
    select?: PlaylistLayoutSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaylistLayoutSectionCountOutputType without action
   */
  export type PlaylistLayoutSectionCountOutputTypeCountPlaylistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistItemWhereInput | $Types.Skip
  }


  /**
   * Count Type ScreenCountOutputType
   */

  export type ScreenCountOutputType = {
    playlists: number
  }

  export type ScreenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlists?: boolean | ScreenCountOutputTypeCountPlaylistsArgs
  }

  // Custom InputTypes
  /**
   * ScreenCountOutputType without action
   */
  export type ScreenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenCountOutputType
     */
    select?: ScreenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScreenCountOutputType without action
   */
  export type ScreenCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistScreenWhereInput | $Types.Skip
  }


  /**
   * Count Type ScreenGroupCountOutputType
   */

  export type ScreenGroupCountOutputType = {
    screens: number
  }

  export type ScreenGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screens?: boolean | ScreenGroupCountOutputTypeCountScreensArgs
  }

  // Custom InputTypes
  /**
   * ScreenGroupCountOutputType without action
   */
  export type ScreenGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroupCountOutputType
     */
    select?: ScreenGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScreenGroupCountOutputType without action
   */
  export type ScreenGroupCountOutputTypeCountScreensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenWhereInput | $Types.Skip
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    emailVerificationTokens: number
    sessions: number
    workspaces: number
    userPreferences: number
    uploadedFiles: number
    fileUploadSessions: number
    sentInvitations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailVerificationTokens?: boolean | UserCountOutputTypeCountEmailVerificationTokensArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    userPreferences?: boolean | UserCountOutputTypeCountUserPreferencesArgs
    uploadedFiles?: boolean | UserCountOutputTypeCountUploadedFilesArgs
    fileUploadSessions?: boolean | UserCountOutputTypeCountFileUploadSessionsArgs
    sentInvitations?: boolean | UserCountOutputTypeCountSentInvitationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailVerificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationTokenWhereInput | $Types.Skip
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput | $Types.Skip
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWorkspaceWhereInput | $Types.Skip
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput | $Types.Skip
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput | $Types.Skip
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFileUploadSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileUploadSessionWhereInput | $Types.Skip
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    members: number
    screens: number
    playlists: number
    layouts: number
    files: number
    folders: number
    fileUploadSessions: number
    userInvitations: number
    screenGroups: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WorkspaceCountOutputTypeCountMembersArgs
    screens?: boolean | WorkspaceCountOutputTypeCountScreensArgs
    playlists?: boolean | WorkspaceCountOutputTypeCountPlaylistsArgs
    layouts?: boolean | WorkspaceCountOutputTypeCountLayoutsArgs
    files?: boolean | WorkspaceCountOutputTypeCountFilesArgs
    folders?: boolean | WorkspaceCountOutputTypeCountFoldersArgs
    fileUploadSessions?: boolean | WorkspaceCountOutputTypeCountFileUploadSessionsArgs
    userInvitations?: boolean | WorkspaceCountOutputTypeCountUserInvitationsArgs
    screenGroups?: boolean | WorkspaceCountOutputTypeCountScreenGroupsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWorkspaceWhereInput | $Types.Skip
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountScreensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenWhereInput | $Types.Skip
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput | $Types.Skip
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountLayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistLayoutWhereInput | $Types.Skip
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput | $Types.Skip
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput | $Types.Skip
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountFileUploadSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileUploadSessionWhereInput | $Types.Skip
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountUserInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountScreenGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenGroupWhereInput | $Types.Skip
  }


  /**
   * Count Type WorkspaceUserInvitationCountOutputType
   */

  export type WorkspaceUserInvitationCountOutputType = {
    members: number
  }

  export type WorkspaceUserInvitationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WorkspaceUserInvitationCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceUserInvitationCountOutputType without action
   */
  export type WorkspaceUserInvitationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitationCountOutputType
     */
    select?: WorkspaceUserInvitationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceUserInvitationCountOutputType without action
   */
  export type WorkspaceUserInvitationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWorkspaceWhereInput | $Types.Skip
  }


  /**
   * Models
   */

  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    screenId: string | null
    token: string | null
    connectionCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isOnline: boolean | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    screenId: string | null
    token: string | null
    connectionCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isOnline: boolean | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    screenId: number
    token: number
    connectionCode: number
    createdAt: number
    updatedAt: number
    isOnline: number
    _all: number
  }


  export type DeviceMinAggregateInputType = {
    id?: true | $Types.Skip
    screenId?: true | $Types.Skip
    token?: true | $Types.Skip
    connectionCode?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    isOnline?: true | $Types.Skip
  }

  export type DeviceMaxAggregateInputType = {
    id?: true | $Types.Skip
    screenId?: true | $Types.Skip
    token?: true | $Types.Skip
    connectionCode?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    isOnline?: true | $Types.Skip
  }

  export type DeviceCountAggregateInputType = {
    id?: true | $Types.Skip
    screenId?: true | $Types.Skip
    token?: true | $Types.Skip
    connectionCode?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    isOnline?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput | $Types.Skip
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[] | $Types.Skip
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: DeviceCountAggregateInputType | true
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    screenId: string | null
    token: string
    connectionCode: string
    createdAt: Date
    updatedAt: Date
    isOnline: boolean
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    screenId?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    connectionCode?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    isOnline?: boolean | $Types.Skip
    screen?: boolean | Device$screenArgs<ExtArgs> | $Types.Skip
    telemetry?: boolean | Device$telemetryArgs<ExtArgs> | $Types.Skip
    statusLog?: boolean | Device$statusLogArgs<ExtArgs> | $Types.Skip
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    screenId?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    connectionCode?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    isOnline?: boolean | $Types.Skip
    screen?: boolean | Device$screenArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    screenId?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    connectionCode?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    isOnline?: boolean | $Types.Skip
    screen?: boolean | Device$screenArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean | $Types.Skip
    screenId?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    connectionCode?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    isOnline?: boolean | $Types.Skip
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "screenId" | "token" | "connectionCode" | "createdAt" | "updatedAt" | "isOnline", ExtArgs["result"]["device"], $Types.Skip>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screen?: boolean | Device$screenArgs<ExtArgs> | $Types.Skip
    telemetry?: boolean | Device$telemetryArgs<ExtArgs> | $Types.Skip
    statusLog?: boolean | Device$statusLogArgs<ExtArgs> | $Types.Skip
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screen?: boolean | Device$screenArgs<ExtArgs> | $Types.Skip
  }
  export type DeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screen?: boolean | Device$screenArgs<ExtArgs> | $Types.Skip
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      screen: Prisma.$ScreenPayload<ExtArgs> | null
      telemetry: Prisma.$DeviceTelemetryPayload<ExtArgs>[]
      statusLog: Prisma.$DeviceStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      screenId: string | null
      token: string
      connectionCode: string
      createdAt: Date
      updatedAt: Date
      isOnline: boolean
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {DeviceUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    screen<T extends Device$screenArgs<ExtArgs> = {}>(args?: Subset<T, Device$screenArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    telemetry<T extends Device$telemetryArgs<ExtArgs> = {}>(args?: Subset<T, Device$telemetryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusLog<T extends Device$statusLogArgs<ExtArgs> = {}>(args?: Subset<T, Device$statusLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly screenId: FieldRef<"Device", 'String'>
    readonly token: FieldRef<"Device", 'String'>
    readonly connectionCode: FieldRef<"Device", 'String'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
    readonly updatedAt: FieldRef<"Device", 'DateTime'>
    readonly isOnline: FieldRef<"Device", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number | $Types.Skip
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput | $Types.Skip
    /**
     * Limit how many Devices to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Device updateManyAndReturn
   */
  export type DeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput | $Types.Skip
    /**
     * Limit how many Devices to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput | $Types.Skip
    /**
     * Limit how many Devices to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Device.screen
   */
  export type Device$screenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    where?: ScreenWhereInput | $Types.Skip
  }

  /**
   * Device.telemetry
   */
  export type Device$telemetryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    where?: DeviceTelemetryWhereInput | $Types.Skip
    orderBy?: DeviceTelemetryOrderByWithRelationInput | DeviceTelemetryOrderByWithRelationInput[] | $Types.Skip
    cursor?: DeviceTelemetryWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: DeviceTelemetryScalarFieldEnum | DeviceTelemetryScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Device.statusLog
   */
  export type Device$statusLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    where?: DeviceStatusWhereInput | $Types.Skip
    orderBy?: DeviceStatusOrderByWithRelationInput | DeviceStatusOrderByWithRelationInput[] | $Types.Skip
    cursor?: DeviceStatusWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: DeviceStatusScalarFieldEnum | DeviceStatusScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model DeviceStatus
   */

  export type AggregateDeviceStatus = {
    _count: DeviceStatusCountAggregateOutputType | null
    _min: DeviceStatusMinAggregateOutputType | null
    _max: DeviceStatusMaxAggregateOutputType | null
  }

  export type DeviceStatusMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    isOnline: boolean | null
    createdAt: Date | null
  }

  export type DeviceStatusMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    isOnline: boolean | null
    createdAt: Date | null
  }

  export type DeviceStatusCountAggregateOutputType = {
    id: number
    deviceId: number
    isOnline: number
    createdAt: number
    _all: number
  }


  export type DeviceStatusMinAggregateInputType = {
    id?: true | $Types.Skip
    deviceId?: true | $Types.Skip
    isOnline?: true | $Types.Skip
    createdAt?: true | $Types.Skip
  }

  export type DeviceStatusMaxAggregateInputType = {
    id?: true | $Types.Skip
    deviceId?: true | $Types.Skip
    isOnline?: true | $Types.Skip
    createdAt?: true | $Types.Skip
  }

  export type DeviceStatusCountAggregateInputType = {
    id?: true | $Types.Skip
    deviceId?: true | $Types.Skip
    isOnline?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type DeviceStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceStatus to aggregate.
     */
    where?: DeviceStatusWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStatuses to fetch.
     */
    orderBy?: DeviceStatusOrderByWithRelationInput | DeviceStatusOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceStatusWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStatuses from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStatuses.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceStatuses
    **/
    _count?: true | DeviceStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceStatusMaxAggregateInputType
  }

  export type GetDeviceStatusAggregateType<T extends DeviceStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceStatus[P]>
      : GetScalarType<T[P], AggregateDeviceStatus[P]>
  }




  export type DeviceStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceStatusWhereInput | $Types.Skip
    orderBy?: DeviceStatusOrderByWithAggregationInput | DeviceStatusOrderByWithAggregationInput[] | $Types.Skip
    by: DeviceStatusScalarFieldEnum[] | DeviceStatusScalarFieldEnum
    having?: DeviceStatusScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: DeviceStatusCountAggregateInputType | true
    _min?: DeviceStatusMinAggregateInputType
    _max?: DeviceStatusMaxAggregateInputType
  }

  export type DeviceStatusGroupByOutputType = {
    id: string
    deviceId: string
    isOnline: boolean
    createdAt: Date
    _count: DeviceStatusCountAggregateOutputType | null
    _min: DeviceStatusMinAggregateOutputType | null
    _max: DeviceStatusMaxAggregateOutputType | null
  }

  type GetDeviceStatusGroupByPayload<T extends DeviceStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceStatusGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceStatusGroupByOutputType[P]>
        }
      >
    >


  export type DeviceStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    deviceId?: boolean | $Types.Skip
    isOnline?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["deviceStatus"]>

  export type DeviceStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    deviceId?: boolean | $Types.Skip
    isOnline?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["deviceStatus"]>

  export type DeviceStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    deviceId?: boolean | $Types.Skip
    isOnline?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["deviceStatus"]>

  export type DeviceStatusSelectScalar = {
    id?: boolean | $Types.Skip
    deviceId?: boolean | $Types.Skip
    isOnline?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
  }

  export type DeviceStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deviceId" | "isOnline" | "createdAt", ExtArgs["result"]["deviceStatus"], $Types.Skip>
  export type DeviceStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type DeviceStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type DeviceStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $DeviceStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceStatus"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      isOnline: boolean
      createdAt: Date
    }, ExtArgs["result"]["deviceStatus"]>
    composites: {}
  }

  type DeviceStatusGetPayload<S extends boolean | null | undefined | DeviceStatusDefaultArgs> = $Result.GetResult<Prisma.$DeviceStatusPayload, S>

  type DeviceStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceStatusCountAggregateInputType | true
    }

  export interface DeviceStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceStatus'], meta: { name: 'DeviceStatus' } }
    /**
     * Find zero or one DeviceStatus that matches the filter.
     * @param {DeviceStatusFindUniqueArgs} args - Arguments to find a DeviceStatus
     * @example
     * // Get one DeviceStatus
     * const deviceStatus = await prisma.deviceStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceStatusFindUniqueArgs>(args: SelectSubset<T, DeviceStatusFindUniqueArgs<ExtArgs>>): Prisma__DeviceStatusClient<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceStatusFindUniqueOrThrowArgs} args - Arguments to find a DeviceStatus
     * @example
     * // Get one DeviceStatus
     * const deviceStatus = await prisma.deviceStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceStatusClient<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusFindFirstArgs} args - Arguments to find a DeviceStatus
     * @example
     * // Get one DeviceStatus
     * const deviceStatus = await prisma.deviceStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceStatusFindFirstArgs>(args?: SelectSubset<T, DeviceStatusFindFirstArgs<ExtArgs>>): Prisma__DeviceStatusClient<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusFindFirstOrThrowArgs} args - Arguments to find a DeviceStatus
     * @example
     * // Get one DeviceStatus
     * const deviceStatus = await prisma.deviceStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceStatusClient<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceStatuses
     * const deviceStatuses = await prisma.deviceStatus.findMany()
     * 
     * // Get first 10 DeviceStatuses
     * const deviceStatuses = await prisma.deviceStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceStatusWithIdOnly = await prisma.deviceStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceStatusFindManyArgs>(args?: SelectSubset<T, DeviceStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceStatus.
     * @param {DeviceStatusCreateArgs} args - Arguments to create a DeviceStatus.
     * @example
     * // Create one DeviceStatus
     * const DeviceStatus = await prisma.deviceStatus.create({
     *   data: {
     *     // ... data to create a DeviceStatus
     *   }
     * })
     * 
     */
    create<T extends DeviceStatusCreateArgs>(args: SelectSubset<T, DeviceStatusCreateArgs<ExtArgs>>): Prisma__DeviceStatusClient<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceStatuses.
     * @param {DeviceStatusCreateManyArgs} args - Arguments to create many DeviceStatuses.
     * @example
     * // Create many DeviceStatuses
     * const deviceStatus = await prisma.deviceStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceStatusCreateManyArgs>(args?: SelectSubset<T, DeviceStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceStatuses and returns the data saved in the database.
     * @param {DeviceStatusCreateManyAndReturnArgs} args - Arguments to create many DeviceStatuses.
     * @example
     * // Create many DeviceStatuses
     * const deviceStatus = await prisma.deviceStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceStatuses and only return the `id`
     * const deviceStatusWithIdOnly = await prisma.deviceStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceStatus.
     * @param {DeviceStatusDeleteArgs} args - Arguments to delete one DeviceStatus.
     * @example
     * // Delete one DeviceStatus
     * const DeviceStatus = await prisma.deviceStatus.delete({
     *   where: {
     *     // ... filter to delete one DeviceStatus
     *   }
     * })
     * 
     */
    delete<T extends DeviceStatusDeleteArgs>(args: SelectSubset<T, DeviceStatusDeleteArgs<ExtArgs>>): Prisma__DeviceStatusClient<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceStatus.
     * @param {DeviceStatusUpdateArgs} args - Arguments to update one DeviceStatus.
     * @example
     * // Update one DeviceStatus
     * const deviceStatus = await prisma.deviceStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceStatusUpdateArgs>(args: SelectSubset<T, DeviceStatusUpdateArgs<ExtArgs>>): Prisma__DeviceStatusClient<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceStatuses.
     * @param {DeviceStatusDeleteManyArgs} args - Arguments to filter DeviceStatuses to delete.
     * @example
     * // Delete a few DeviceStatuses
     * const { count } = await prisma.deviceStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceStatusDeleteManyArgs>(args?: SelectSubset<T, DeviceStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceStatuses
     * const deviceStatus = await prisma.deviceStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceStatusUpdateManyArgs>(args: SelectSubset<T, DeviceStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceStatuses and returns the data updated in the database.
     * @param {DeviceStatusUpdateManyAndReturnArgs} args - Arguments to update many DeviceStatuses.
     * @example
     * // Update many DeviceStatuses
     * const deviceStatus = await prisma.deviceStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceStatuses and only return the `id`
     * const deviceStatusWithIdOnly = await prisma.deviceStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceStatus.
     * @param {DeviceStatusUpsertArgs} args - Arguments to update or create a DeviceStatus.
     * @example
     * // Update or create a DeviceStatus
     * const deviceStatus = await prisma.deviceStatus.upsert({
     *   create: {
     *     // ... data to create a DeviceStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceStatus we want to update
     *   }
     * })
     */
    upsert<T extends DeviceStatusUpsertArgs>(args: SelectSubset<T, DeviceStatusUpsertArgs<ExtArgs>>): Prisma__DeviceStatusClient<$Result.GetResult<Prisma.$DeviceStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusCountArgs} args - Arguments to filter DeviceStatuses to count.
     * @example
     * // Count the number of DeviceStatuses
     * const count = await prisma.deviceStatus.count({
     *   where: {
     *     // ... the filter for the DeviceStatuses we want to count
     *   }
     * })
    **/
    count<T extends DeviceStatusCountArgs>(
      args?: Subset<T, DeviceStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceStatusAggregateArgs>(args: Subset<T, DeviceStatusAggregateArgs>): Prisma.PrismaPromise<GetDeviceStatusAggregateType<T>>

    /**
     * Group by DeviceStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceStatusGroupByArgs['orderBy'] }
        : { orderBy?: DeviceStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceStatus model
   */
  readonly fields: DeviceStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceStatus model
   */
  interface DeviceStatusFieldRefs {
    readonly id: FieldRef<"DeviceStatus", 'String'>
    readonly deviceId: FieldRef<"DeviceStatus", 'String'>
    readonly isOnline: FieldRef<"DeviceStatus", 'Boolean'>
    readonly createdAt: FieldRef<"DeviceStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceStatus findUnique
   */
  export type DeviceStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatus to fetch.
     */
    where: DeviceStatusWhereUniqueInput
  }

  /**
   * DeviceStatus findUniqueOrThrow
   */
  export type DeviceStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatus to fetch.
     */
    where: DeviceStatusWhereUniqueInput
  }

  /**
   * DeviceStatus findFirst
   */
  export type DeviceStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatus to fetch.
     */
    where?: DeviceStatusWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStatuses to fetch.
     */
    orderBy?: DeviceStatusOrderByWithRelationInput | DeviceStatusOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceStatuses.
     */
    cursor?: DeviceStatusWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStatuses from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStatuses.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceStatuses.
     */
    distinct?: DeviceStatusScalarFieldEnum | DeviceStatusScalarFieldEnum[] | $Types.Skip
  }

  /**
   * DeviceStatus findFirstOrThrow
   */
  export type DeviceStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatus to fetch.
     */
    where?: DeviceStatusWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStatuses to fetch.
     */
    orderBy?: DeviceStatusOrderByWithRelationInput | DeviceStatusOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceStatuses.
     */
    cursor?: DeviceStatusWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStatuses from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStatuses.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceStatuses.
     */
    distinct?: DeviceStatusScalarFieldEnum | DeviceStatusScalarFieldEnum[] | $Types.Skip
  }

  /**
   * DeviceStatus findMany
   */
  export type DeviceStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * Filter, which DeviceStatuses to fetch.
     */
    where?: DeviceStatusWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStatuses to fetch.
     */
    orderBy?: DeviceStatusOrderByWithRelationInput | DeviceStatusOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceStatuses.
     */
    cursor?: DeviceStatusWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStatuses from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStatuses.
     */
    skip?: number | $Types.Skip
    distinct?: DeviceStatusScalarFieldEnum | DeviceStatusScalarFieldEnum[] | $Types.Skip
  }

  /**
   * DeviceStatus create
   */
  export type DeviceStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceStatus.
     */
    data: XOR<DeviceStatusCreateInput, DeviceStatusUncheckedCreateInput>
  }

  /**
   * DeviceStatus createMany
   */
  export type DeviceStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceStatuses.
     */
    data: DeviceStatusCreateManyInput | DeviceStatusCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * DeviceStatus createManyAndReturn
   */
  export type DeviceStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceStatuses.
     */
    data: DeviceStatusCreateManyInput | DeviceStatusCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceStatus update
   */
  export type DeviceStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceStatus.
     */
    data: XOR<DeviceStatusUpdateInput, DeviceStatusUncheckedUpdateInput>
    /**
     * Choose, which DeviceStatus to update.
     */
    where: DeviceStatusWhereUniqueInput
  }

  /**
   * DeviceStatus updateMany
   */
  export type DeviceStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceStatuses.
     */
    data: XOR<DeviceStatusUpdateManyMutationInput, DeviceStatusUncheckedUpdateManyInput>
    /**
     * Filter which DeviceStatuses to update
     */
    where?: DeviceStatusWhereInput | $Types.Skip
    /**
     * Limit how many DeviceStatuses to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * DeviceStatus updateManyAndReturn
   */
  export type DeviceStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * The data used to update DeviceStatuses.
     */
    data: XOR<DeviceStatusUpdateManyMutationInput, DeviceStatusUncheckedUpdateManyInput>
    /**
     * Filter which DeviceStatuses to update
     */
    where?: DeviceStatusWhereInput | $Types.Skip
    /**
     * Limit how many DeviceStatuses to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceStatus upsert
   */
  export type DeviceStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceStatus to update in case it exists.
     */
    where: DeviceStatusWhereUniqueInput
    /**
     * In case the DeviceStatus found by the `where` argument doesn't exist, create a new DeviceStatus with this data.
     */
    create: XOR<DeviceStatusCreateInput, DeviceStatusUncheckedCreateInput>
    /**
     * In case the DeviceStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceStatusUpdateInput, DeviceStatusUncheckedUpdateInput>
  }

  /**
   * DeviceStatus delete
   */
  export type DeviceStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
    /**
     * Filter which DeviceStatus to delete.
     */
    where: DeviceStatusWhereUniqueInput
  }

  /**
   * DeviceStatus deleteMany
   */
  export type DeviceStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceStatuses to delete
     */
    where?: DeviceStatusWhereInput | $Types.Skip
    /**
     * Limit how many DeviceStatuses to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * DeviceStatus without action
   */
  export type DeviceStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStatus
     */
    select?: DeviceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceStatus
     */
    omit?: DeviceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceStatusInclude<ExtArgs> | null
  }


  /**
   * Model DeviceTelemetry
   */

  export type AggregateDeviceTelemetry = {
    _count: DeviceTelemetryCountAggregateOutputType | null
    _avg: DeviceTelemetryAvgAggregateOutputType | null
    _sum: DeviceTelemetrySumAggregateOutputType | null
    _min: DeviceTelemetryMinAggregateOutputType | null
    _max: DeviceTelemetryMaxAggregateOutputType | null
  }

  export type DeviceTelemetryAvgAggregateOutputType = {
    screenResolutionWidth: number | null
    screenResolutionHeight: number | null
    totalMemory: number | null
    freeMemory: number | null
  }

  export type DeviceTelemetrySumAggregateOutputType = {
    screenResolutionWidth: number | null
    screenResolutionHeight: number | null
    totalMemory: bigint | null
    freeMemory: bigint | null
  }

  export type DeviceTelemetryMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    localIpAddress: string | null
    publicIpAddress: string | null
    macAddress: string | null
    softwareVersion: string | null
    platform: string | null
    osRelease: string | null
    screenResolutionWidth: number | null
    screenResolutionHeight: number | null
    hostname: string | null
    timezone: string | null
    totalMemory: bigint | null
    freeMemory: bigint | null
    createdAt: Date | null
  }

  export type DeviceTelemetryMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    localIpAddress: string | null
    publicIpAddress: string | null
    macAddress: string | null
    softwareVersion: string | null
    platform: string | null
    osRelease: string | null
    screenResolutionWidth: number | null
    screenResolutionHeight: number | null
    hostname: string | null
    timezone: string | null
    totalMemory: bigint | null
    freeMemory: bigint | null
    createdAt: Date | null
  }

  export type DeviceTelemetryCountAggregateOutputType = {
    id: number
    deviceId: number
    localIpAddress: number
    publicIpAddress: number
    macAddress: number
    softwareVersion: number
    platform: number
    osRelease: number
    screenResolutionWidth: number
    screenResolutionHeight: number
    hostname: number
    timezone: number
    totalMemory: number
    freeMemory: number
    createdAt: number
    _all: number
  }


  export type DeviceTelemetryAvgAggregateInputType = {
    screenResolutionWidth?: true | $Types.Skip
    screenResolutionHeight?: true | $Types.Skip
    totalMemory?: true | $Types.Skip
    freeMemory?: true | $Types.Skip
  }

  export type DeviceTelemetrySumAggregateInputType = {
    screenResolutionWidth?: true | $Types.Skip
    screenResolutionHeight?: true | $Types.Skip
    totalMemory?: true | $Types.Skip
    freeMemory?: true | $Types.Skip
  }

  export type DeviceTelemetryMinAggregateInputType = {
    id?: true | $Types.Skip
    deviceId?: true | $Types.Skip
    localIpAddress?: true | $Types.Skip
    publicIpAddress?: true | $Types.Skip
    macAddress?: true | $Types.Skip
    softwareVersion?: true | $Types.Skip
    platform?: true | $Types.Skip
    osRelease?: true | $Types.Skip
    screenResolutionWidth?: true | $Types.Skip
    screenResolutionHeight?: true | $Types.Skip
    hostname?: true | $Types.Skip
    timezone?: true | $Types.Skip
    totalMemory?: true | $Types.Skip
    freeMemory?: true | $Types.Skip
    createdAt?: true | $Types.Skip
  }

  export type DeviceTelemetryMaxAggregateInputType = {
    id?: true | $Types.Skip
    deviceId?: true | $Types.Skip
    localIpAddress?: true | $Types.Skip
    publicIpAddress?: true | $Types.Skip
    macAddress?: true | $Types.Skip
    softwareVersion?: true | $Types.Skip
    platform?: true | $Types.Skip
    osRelease?: true | $Types.Skip
    screenResolutionWidth?: true | $Types.Skip
    screenResolutionHeight?: true | $Types.Skip
    hostname?: true | $Types.Skip
    timezone?: true | $Types.Skip
    totalMemory?: true | $Types.Skip
    freeMemory?: true | $Types.Skip
    createdAt?: true | $Types.Skip
  }

  export type DeviceTelemetryCountAggregateInputType = {
    id?: true | $Types.Skip
    deviceId?: true | $Types.Skip
    localIpAddress?: true | $Types.Skip
    publicIpAddress?: true | $Types.Skip
    macAddress?: true | $Types.Skip
    softwareVersion?: true | $Types.Skip
    platform?: true | $Types.Skip
    osRelease?: true | $Types.Skip
    screenResolutionWidth?: true | $Types.Skip
    screenResolutionHeight?: true | $Types.Skip
    hostname?: true | $Types.Skip
    timezone?: true | $Types.Skip
    totalMemory?: true | $Types.Skip
    freeMemory?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type DeviceTelemetryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTelemetry to aggregate.
     */
    where?: DeviceTelemetryWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTelemetries to fetch.
     */
    orderBy?: DeviceTelemetryOrderByWithRelationInput | DeviceTelemetryOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTelemetryWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTelemetries from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTelemetries.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTelemetries
    **/
    _count?: true | DeviceTelemetryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceTelemetryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceTelemetrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTelemetryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTelemetryMaxAggregateInputType
  }

  export type GetDeviceTelemetryAggregateType<T extends DeviceTelemetryAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceTelemetry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceTelemetry[P]>
      : GetScalarType<T[P], AggregateDeviceTelemetry[P]>
  }




  export type DeviceTelemetryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTelemetryWhereInput | $Types.Skip
    orderBy?: DeviceTelemetryOrderByWithAggregationInput | DeviceTelemetryOrderByWithAggregationInput[] | $Types.Skip
    by: DeviceTelemetryScalarFieldEnum[] | DeviceTelemetryScalarFieldEnum
    having?: DeviceTelemetryScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: DeviceTelemetryCountAggregateInputType | true
    _avg?: DeviceTelemetryAvgAggregateInputType
    _sum?: DeviceTelemetrySumAggregateInputType
    _min?: DeviceTelemetryMinAggregateInputType
    _max?: DeviceTelemetryMaxAggregateInputType
  }

  export type DeviceTelemetryGroupByOutputType = {
    id: string
    deviceId: string
    localIpAddress: string | null
    publicIpAddress: string | null
    macAddress: string | null
    softwareVersion: string | null
    platform: string | null
    osRelease: string | null
    screenResolutionWidth: number | null
    screenResolutionHeight: number | null
    hostname: string | null
    timezone: string | null
    totalMemory: bigint | null
    freeMemory: bigint | null
    createdAt: Date
    _count: DeviceTelemetryCountAggregateOutputType | null
    _avg: DeviceTelemetryAvgAggregateOutputType | null
    _sum: DeviceTelemetrySumAggregateOutputType | null
    _min: DeviceTelemetryMinAggregateOutputType | null
    _max: DeviceTelemetryMaxAggregateOutputType | null
  }

  type GetDeviceTelemetryGroupByPayload<T extends DeviceTelemetryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTelemetryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTelemetryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTelemetryGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTelemetryGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTelemetrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    deviceId?: boolean | $Types.Skip
    localIpAddress?: boolean | $Types.Skip
    publicIpAddress?: boolean | $Types.Skip
    macAddress?: boolean | $Types.Skip
    softwareVersion?: boolean | $Types.Skip
    platform?: boolean | $Types.Skip
    osRelease?: boolean | $Types.Skip
    screenResolutionWidth?: boolean | $Types.Skip
    screenResolutionHeight?: boolean | $Types.Skip
    hostname?: boolean | $Types.Skip
    timezone?: boolean | $Types.Skip
    totalMemory?: boolean | $Types.Skip
    freeMemory?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["deviceTelemetry"]>

  export type DeviceTelemetrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    deviceId?: boolean | $Types.Skip
    localIpAddress?: boolean | $Types.Skip
    publicIpAddress?: boolean | $Types.Skip
    macAddress?: boolean | $Types.Skip
    softwareVersion?: boolean | $Types.Skip
    platform?: boolean | $Types.Skip
    osRelease?: boolean | $Types.Skip
    screenResolutionWidth?: boolean | $Types.Skip
    screenResolutionHeight?: boolean | $Types.Skip
    hostname?: boolean | $Types.Skip
    timezone?: boolean | $Types.Skip
    totalMemory?: boolean | $Types.Skip
    freeMemory?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["deviceTelemetry"]>

  export type DeviceTelemetrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    deviceId?: boolean | $Types.Skip
    localIpAddress?: boolean | $Types.Skip
    publicIpAddress?: boolean | $Types.Skip
    macAddress?: boolean | $Types.Skip
    softwareVersion?: boolean | $Types.Skip
    platform?: boolean | $Types.Skip
    osRelease?: boolean | $Types.Skip
    screenResolutionWidth?: boolean | $Types.Skip
    screenResolutionHeight?: boolean | $Types.Skip
    hostname?: boolean | $Types.Skip
    timezone?: boolean | $Types.Skip
    totalMemory?: boolean | $Types.Skip
    freeMemory?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["deviceTelemetry"]>

  export type DeviceTelemetrySelectScalar = {
    id?: boolean | $Types.Skip
    deviceId?: boolean | $Types.Skip
    localIpAddress?: boolean | $Types.Skip
    publicIpAddress?: boolean | $Types.Skip
    macAddress?: boolean | $Types.Skip
    softwareVersion?: boolean | $Types.Skip
    platform?: boolean | $Types.Skip
    osRelease?: boolean | $Types.Skip
    screenResolutionWidth?: boolean | $Types.Skip
    screenResolutionHeight?: boolean | $Types.Skip
    hostname?: boolean | $Types.Skip
    timezone?: boolean | $Types.Skip
    totalMemory?: boolean | $Types.Skip
    freeMemory?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
  }

  export type DeviceTelemetryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deviceId" | "localIpAddress" | "publicIpAddress" | "macAddress" | "softwareVersion" | "platform" | "osRelease" | "screenResolutionWidth" | "screenResolutionHeight" | "hostname" | "timezone" | "totalMemory" | "freeMemory" | "createdAt", ExtArgs["result"]["deviceTelemetry"], $Types.Skip>
  export type DeviceTelemetryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type DeviceTelemetryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type DeviceTelemetryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $DeviceTelemetryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceTelemetry"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      localIpAddress: string | null
      publicIpAddress: string | null
      macAddress: string | null
      softwareVersion: string | null
      platform: string | null
      osRelease: string | null
      screenResolutionWidth: number | null
      screenResolutionHeight: number | null
      hostname: string | null
      timezone: string | null
      totalMemory: bigint | null
      freeMemory: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["deviceTelemetry"]>
    composites: {}
  }

  type DeviceTelemetryGetPayload<S extends boolean | null | undefined | DeviceTelemetryDefaultArgs> = $Result.GetResult<Prisma.$DeviceTelemetryPayload, S>

  type DeviceTelemetryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceTelemetryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceTelemetryCountAggregateInputType | true
    }

  export interface DeviceTelemetryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceTelemetry'], meta: { name: 'DeviceTelemetry' } }
    /**
     * Find zero or one DeviceTelemetry that matches the filter.
     * @param {DeviceTelemetryFindUniqueArgs} args - Arguments to find a DeviceTelemetry
     * @example
     * // Get one DeviceTelemetry
     * const deviceTelemetry = await prisma.deviceTelemetry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTelemetryFindUniqueArgs>(args: SelectSubset<T, DeviceTelemetryFindUniqueArgs<ExtArgs>>): Prisma__DeviceTelemetryClient<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceTelemetry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceTelemetryFindUniqueOrThrowArgs} args - Arguments to find a DeviceTelemetry
     * @example
     * // Get one DeviceTelemetry
     * const deviceTelemetry = await prisma.deviceTelemetry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTelemetryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTelemetryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTelemetryClient<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceTelemetry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTelemetryFindFirstArgs} args - Arguments to find a DeviceTelemetry
     * @example
     * // Get one DeviceTelemetry
     * const deviceTelemetry = await prisma.deviceTelemetry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTelemetryFindFirstArgs>(args?: SelectSubset<T, DeviceTelemetryFindFirstArgs<ExtArgs>>): Prisma__DeviceTelemetryClient<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceTelemetry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTelemetryFindFirstOrThrowArgs} args - Arguments to find a DeviceTelemetry
     * @example
     * // Get one DeviceTelemetry
     * const deviceTelemetry = await prisma.deviceTelemetry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTelemetryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTelemetryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTelemetryClient<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceTelemetries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTelemetryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTelemetries
     * const deviceTelemetries = await prisma.deviceTelemetry.findMany()
     * 
     * // Get first 10 DeviceTelemetries
     * const deviceTelemetries = await prisma.deviceTelemetry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTelemetryWithIdOnly = await prisma.deviceTelemetry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTelemetryFindManyArgs>(args?: SelectSubset<T, DeviceTelemetryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceTelemetry.
     * @param {DeviceTelemetryCreateArgs} args - Arguments to create a DeviceTelemetry.
     * @example
     * // Create one DeviceTelemetry
     * const DeviceTelemetry = await prisma.deviceTelemetry.create({
     *   data: {
     *     // ... data to create a DeviceTelemetry
     *   }
     * })
     * 
     */
    create<T extends DeviceTelemetryCreateArgs>(args: SelectSubset<T, DeviceTelemetryCreateArgs<ExtArgs>>): Prisma__DeviceTelemetryClient<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceTelemetries.
     * @param {DeviceTelemetryCreateManyArgs} args - Arguments to create many DeviceTelemetries.
     * @example
     * // Create many DeviceTelemetries
     * const deviceTelemetry = await prisma.deviceTelemetry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTelemetryCreateManyArgs>(args?: SelectSubset<T, DeviceTelemetryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTelemetries and returns the data saved in the database.
     * @param {DeviceTelemetryCreateManyAndReturnArgs} args - Arguments to create many DeviceTelemetries.
     * @example
     * // Create many DeviceTelemetries
     * const deviceTelemetry = await prisma.deviceTelemetry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTelemetries and only return the `id`
     * const deviceTelemetryWithIdOnly = await prisma.deviceTelemetry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTelemetryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTelemetryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceTelemetry.
     * @param {DeviceTelemetryDeleteArgs} args - Arguments to delete one DeviceTelemetry.
     * @example
     * // Delete one DeviceTelemetry
     * const DeviceTelemetry = await prisma.deviceTelemetry.delete({
     *   where: {
     *     // ... filter to delete one DeviceTelemetry
     *   }
     * })
     * 
     */
    delete<T extends DeviceTelemetryDeleteArgs>(args: SelectSubset<T, DeviceTelemetryDeleteArgs<ExtArgs>>): Prisma__DeviceTelemetryClient<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceTelemetry.
     * @param {DeviceTelemetryUpdateArgs} args - Arguments to update one DeviceTelemetry.
     * @example
     * // Update one DeviceTelemetry
     * const deviceTelemetry = await prisma.deviceTelemetry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTelemetryUpdateArgs>(args: SelectSubset<T, DeviceTelemetryUpdateArgs<ExtArgs>>): Prisma__DeviceTelemetryClient<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceTelemetries.
     * @param {DeviceTelemetryDeleteManyArgs} args - Arguments to filter DeviceTelemetries to delete.
     * @example
     * // Delete a few DeviceTelemetries
     * const { count } = await prisma.deviceTelemetry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTelemetryDeleteManyArgs>(args?: SelectSubset<T, DeviceTelemetryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTelemetries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTelemetryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTelemetries
     * const deviceTelemetry = await prisma.deviceTelemetry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTelemetryUpdateManyArgs>(args: SelectSubset<T, DeviceTelemetryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTelemetries and returns the data updated in the database.
     * @param {DeviceTelemetryUpdateManyAndReturnArgs} args - Arguments to update many DeviceTelemetries.
     * @example
     * // Update many DeviceTelemetries
     * const deviceTelemetry = await prisma.deviceTelemetry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceTelemetries and only return the `id`
     * const deviceTelemetryWithIdOnly = await prisma.deviceTelemetry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceTelemetryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceTelemetryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceTelemetry.
     * @param {DeviceTelemetryUpsertArgs} args - Arguments to update or create a DeviceTelemetry.
     * @example
     * // Update or create a DeviceTelemetry
     * const deviceTelemetry = await prisma.deviceTelemetry.upsert({
     *   create: {
     *     // ... data to create a DeviceTelemetry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceTelemetry we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTelemetryUpsertArgs>(args: SelectSubset<T, DeviceTelemetryUpsertArgs<ExtArgs>>): Prisma__DeviceTelemetryClient<$Result.GetResult<Prisma.$DeviceTelemetryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceTelemetries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTelemetryCountArgs} args - Arguments to filter DeviceTelemetries to count.
     * @example
     * // Count the number of DeviceTelemetries
     * const count = await prisma.deviceTelemetry.count({
     *   where: {
     *     // ... the filter for the DeviceTelemetries we want to count
     *   }
     * })
    **/
    count<T extends DeviceTelemetryCountArgs>(
      args?: Subset<T, DeviceTelemetryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTelemetryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceTelemetry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTelemetryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTelemetryAggregateArgs>(args: Subset<T, DeviceTelemetryAggregateArgs>): Prisma.PrismaPromise<GetDeviceTelemetryAggregateType<T>>

    /**
     * Group by DeviceTelemetry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTelemetryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTelemetryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTelemetryGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTelemetryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTelemetryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTelemetryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceTelemetry model
   */
  readonly fields: DeviceTelemetryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceTelemetry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTelemetryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceTelemetry model
   */
  interface DeviceTelemetryFieldRefs {
    readonly id: FieldRef<"DeviceTelemetry", 'String'>
    readonly deviceId: FieldRef<"DeviceTelemetry", 'String'>
    readonly localIpAddress: FieldRef<"DeviceTelemetry", 'String'>
    readonly publicIpAddress: FieldRef<"DeviceTelemetry", 'String'>
    readonly macAddress: FieldRef<"DeviceTelemetry", 'String'>
    readonly softwareVersion: FieldRef<"DeviceTelemetry", 'String'>
    readonly platform: FieldRef<"DeviceTelemetry", 'String'>
    readonly osRelease: FieldRef<"DeviceTelemetry", 'String'>
    readonly screenResolutionWidth: FieldRef<"DeviceTelemetry", 'Int'>
    readonly screenResolutionHeight: FieldRef<"DeviceTelemetry", 'Int'>
    readonly hostname: FieldRef<"DeviceTelemetry", 'String'>
    readonly timezone: FieldRef<"DeviceTelemetry", 'String'>
    readonly totalMemory: FieldRef<"DeviceTelemetry", 'BigInt'>
    readonly freeMemory: FieldRef<"DeviceTelemetry", 'BigInt'>
    readonly createdAt: FieldRef<"DeviceTelemetry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceTelemetry findUnique
   */
  export type DeviceTelemetryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTelemetry to fetch.
     */
    where: DeviceTelemetryWhereUniqueInput
  }

  /**
   * DeviceTelemetry findUniqueOrThrow
   */
  export type DeviceTelemetryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTelemetry to fetch.
     */
    where: DeviceTelemetryWhereUniqueInput
  }

  /**
   * DeviceTelemetry findFirst
   */
  export type DeviceTelemetryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTelemetry to fetch.
     */
    where?: DeviceTelemetryWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTelemetries to fetch.
     */
    orderBy?: DeviceTelemetryOrderByWithRelationInput | DeviceTelemetryOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTelemetries.
     */
    cursor?: DeviceTelemetryWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTelemetries from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTelemetries.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTelemetries.
     */
    distinct?: DeviceTelemetryScalarFieldEnum | DeviceTelemetryScalarFieldEnum[] | $Types.Skip
  }

  /**
   * DeviceTelemetry findFirstOrThrow
   */
  export type DeviceTelemetryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTelemetry to fetch.
     */
    where?: DeviceTelemetryWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTelemetries to fetch.
     */
    orderBy?: DeviceTelemetryOrderByWithRelationInput | DeviceTelemetryOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTelemetries.
     */
    cursor?: DeviceTelemetryWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTelemetries from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTelemetries.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTelemetries.
     */
    distinct?: DeviceTelemetryScalarFieldEnum | DeviceTelemetryScalarFieldEnum[] | $Types.Skip
  }

  /**
   * DeviceTelemetry findMany
   */
  export type DeviceTelemetryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTelemetries to fetch.
     */
    where?: DeviceTelemetryWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTelemetries to fetch.
     */
    orderBy?: DeviceTelemetryOrderByWithRelationInput | DeviceTelemetryOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTelemetries.
     */
    cursor?: DeviceTelemetryWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTelemetries from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTelemetries.
     */
    skip?: number | $Types.Skip
    distinct?: DeviceTelemetryScalarFieldEnum | DeviceTelemetryScalarFieldEnum[] | $Types.Skip
  }

  /**
   * DeviceTelemetry create
   */
  export type DeviceTelemetryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceTelemetry.
     */
    data: XOR<DeviceTelemetryCreateInput, DeviceTelemetryUncheckedCreateInput>
  }

  /**
   * DeviceTelemetry createMany
   */
  export type DeviceTelemetryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTelemetries.
     */
    data: DeviceTelemetryCreateManyInput | DeviceTelemetryCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * DeviceTelemetry createManyAndReturn
   */
  export type DeviceTelemetryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceTelemetries.
     */
    data: DeviceTelemetryCreateManyInput | DeviceTelemetryCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceTelemetry update
   */
  export type DeviceTelemetryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceTelemetry.
     */
    data: XOR<DeviceTelemetryUpdateInput, DeviceTelemetryUncheckedUpdateInput>
    /**
     * Choose, which DeviceTelemetry to update.
     */
    where: DeviceTelemetryWhereUniqueInput
  }

  /**
   * DeviceTelemetry updateMany
   */
  export type DeviceTelemetryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTelemetries.
     */
    data: XOR<DeviceTelemetryUpdateManyMutationInput, DeviceTelemetryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTelemetries to update
     */
    where?: DeviceTelemetryWhereInput | $Types.Skip
    /**
     * Limit how many DeviceTelemetries to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * DeviceTelemetry updateManyAndReturn
   */
  export type DeviceTelemetryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * The data used to update DeviceTelemetries.
     */
    data: XOR<DeviceTelemetryUpdateManyMutationInput, DeviceTelemetryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTelemetries to update
     */
    where?: DeviceTelemetryWhereInput | $Types.Skip
    /**
     * Limit how many DeviceTelemetries to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceTelemetry upsert
   */
  export type DeviceTelemetryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceTelemetry to update in case it exists.
     */
    where: DeviceTelemetryWhereUniqueInput
    /**
     * In case the DeviceTelemetry found by the `where` argument doesn't exist, create a new DeviceTelemetry with this data.
     */
    create: XOR<DeviceTelemetryCreateInput, DeviceTelemetryUncheckedCreateInput>
    /**
     * In case the DeviceTelemetry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTelemetryUpdateInput, DeviceTelemetryUncheckedUpdateInput>
  }

  /**
   * DeviceTelemetry delete
   */
  export type DeviceTelemetryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
    /**
     * Filter which DeviceTelemetry to delete.
     */
    where: DeviceTelemetryWhereUniqueInput
  }

  /**
   * DeviceTelemetry deleteMany
   */
  export type DeviceTelemetryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTelemetries to delete
     */
    where?: DeviceTelemetryWhereInput | $Types.Skip
    /**
     * Limit how many DeviceTelemetries to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * DeviceTelemetry without action
   */
  export type DeviceTelemetryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTelemetry
     */
    select?: DeviceTelemetrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTelemetry
     */
    omit?: DeviceTelemetryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTelemetryInclude<ExtArgs> | null
  }


  /**
   * Model EmailVerificationToken
   */

  export type AggregateEmailVerificationToken = {
    _count: EmailVerificationTokenCountAggregateOutputType | null
    _min: EmailVerificationTokenMinAggregateOutputType | null
    _max: EmailVerificationTokenMaxAggregateOutputType | null
  }

  export type EmailVerificationTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    newEmail: string | null
    createdAt: Date | null
  }

  export type EmailVerificationTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    newEmail: string | null
    createdAt: Date | null
  }

  export type EmailVerificationTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    newEmail: number
    createdAt: number
    _all: number
  }


  export type EmailVerificationTokenMinAggregateInputType = {
    id?: true | $Types.Skip
    token?: true | $Types.Skip
    userId?: true | $Types.Skip
    newEmail?: true | $Types.Skip
    createdAt?: true | $Types.Skip
  }

  export type EmailVerificationTokenMaxAggregateInputType = {
    id?: true | $Types.Skip
    token?: true | $Types.Skip
    userId?: true | $Types.Skip
    newEmail?: true | $Types.Skip
    createdAt?: true | $Types.Skip
  }

  export type EmailVerificationTokenCountAggregateInputType = {
    id?: true | $Types.Skip
    token?: true | $Types.Skip
    userId?: true | $Types.Skip
    newEmail?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type EmailVerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerificationToken to aggregate.
     */
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailVerificationTokenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailVerificationTokens
    **/
    _count?: true | EmailVerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailVerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailVerificationTokenMaxAggregateInputType
  }

  export type GetEmailVerificationTokenAggregateType<T extends EmailVerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
      : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
  }




  export type EmailVerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    orderBy?: EmailVerificationTokenOrderByWithAggregationInput | EmailVerificationTokenOrderByWithAggregationInput[] | $Types.Skip
    by: EmailVerificationTokenScalarFieldEnum[] | EmailVerificationTokenScalarFieldEnum
    having?: EmailVerificationTokenScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: EmailVerificationTokenCountAggregateInputType | true
    _min?: EmailVerificationTokenMinAggregateInputType
    _max?: EmailVerificationTokenMaxAggregateInputType
  }

  export type EmailVerificationTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    newEmail: string | null
    createdAt: Date
    _count: EmailVerificationTokenCountAggregateOutputType | null
    _min: EmailVerificationTokenMinAggregateOutputType | null
    _max: EmailVerificationTokenMaxAggregateOutputType | null
  }

  type GetEmailVerificationTokenGroupByPayload<T extends EmailVerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailVerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type EmailVerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    newEmail?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    newEmail?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    newEmail?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectScalar = {
    id?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    newEmail?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
  }

  export type EmailVerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "newEmail" | "createdAt", ExtArgs["result"]["emailVerificationToken"], $Types.Skip>
  export type EmailVerificationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $EmailVerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailVerificationToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      newEmail: string | null
      createdAt: Date
    }, ExtArgs["result"]["emailVerificationToken"]>
    composites: {}
  }

  type EmailVerificationTokenGetPayload<S extends boolean | null | undefined | EmailVerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$EmailVerificationTokenPayload, S>

  type EmailVerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailVerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailVerificationTokenCountAggregateInputType | true
    }

  export interface EmailVerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailVerificationToken'], meta: { name: 'EmailVerificationToken' } }
    /**
     * Find zero or one EmailVerificationToken that matches the filter.
     * @param {EmailVerificationTokenFindUniqueArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationTokenFindUniqueArgs>(args: SelectSubset<T, EmailVerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailVerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationTokenFindFirstArgs>(args?: SelectSubset<T, EmailVerificationTokenFindFirstArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailVerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
     * 
     * // Get first 10 EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailVerificationTokenFindManyArgs>(args?: SelectSubset<T, EmailVerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailVerificationToken.
     * @param {EmailVerificationTokenCreateArgs} args - Arguments to create a EmailVerificationToken.
     * @example
     * // Create one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.create({
     *   data: {
     *     // ... data to create a EmailVerificationToken
     *   }
     * })
     * 
     */
    create<T extends EmailVerificationTokenCreateArgs>(args: SelectSubset<T, EmailVerificationTokenCreateArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailVerificationTokens.
     * @param {EmailVerificationTokenCreateManyArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailVerificationTokenCreateManyArgs>(args?: SelectSubset<T, EmailVerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailVerificationTokens and returns the data saved in the database.
     * @param {EmailVerificationTokenCreateManyAndReturnArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailVerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailVerificationToken.
     * @param {EmailVerificationTokenDeleteArgs} args - Arguments to delete one EmailVerificationToken.
     * @example
     * // Delete one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.delete({
     *   where: {
     *     // ... filter to delete one EmailVerificationToken
     *   }
     * })
     * 
     */
    delete<T extends EmailVerificationTokenDeleteArgs>(args: SelectSubset<T, EmailVerificationTokenDeleteArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpdateArgs} args - Arguments to update one EmailVerificationToken.
     * @example
     * // Update one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailVerificationTokenUpdateArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailVerificationTokens.
     * @param {EmailVerificationTokenDeleteManyArgs} args - Arguments to filter EmailVerificationTokens to delete.
     * @example
     * // Delete a few EmailVerificationTokens
     * const { count } = await prisma.emailVerificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailVerificationTokenDeleteManyArgs>(args?: SelectSubset<T, EmailVerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailVerificationTokenUpdateManyArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerificationTokens and returns the data updated in the database.
     * @param {EmailVerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many EmailVerificationTokens.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailVerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpsertArgs} args - Arguments to update or create a EmailVerificationToken.
     * @example
     * // Update or create a EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.upsert({
     *   create: {
     *     // ... data to create a EmailVerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationTokenUpsertArgs>(args: SelectSubset<T, EmailVerificationTokenUpsertArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenCountArgs} args - Arguments to filter EmailVerificationTokens to count.
     * @example
     * // Count the number of EmailVerificationTokens
     * const count = await prisma.emailVerificationToken.count({
     *   where: {
     *     // ... the filter for the EmailVerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends EmailVerificationTokenCountArgs>(
      args?: Subset<T, EmailVerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailVerificationTokenAggregateArgs>(args: Subset<T, EmailVerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetEmailVerificationTokenAggregateType<T>>

    /**
     * Group by EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailVerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailVerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailVerificationToken model
   */
  readonly fields: EmailVerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailVerificationToken model
   */
  interface EmailVerificationTokenFieldRefs {
    readonly id: FieldRef<"EmailVerificationToken", 'String'>
    readonly token: FieldRef<"EmailVerificationToken", 'String'>
    readonly userId: FieldRef<"EmailVerificationToken", 'String'>
    readonly newEmail: FieldRef<"EmailVerificationToken", 'String'>
    readonly createdAt: FieldRef<"EmailVerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailVerificationToken findUnique
   */
  export type EmailVerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken findUniqueOrThrow
   */
  export type EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken findFirst
   */
  export type EmailVerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * EmailVerificationToken findFirstOrThrow
   */
  export type EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * EmailVerificationToken findMany
   */
  export type EmailVerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationTokens to fetch.
     */
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number | $Types.Skip
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * EmailVerificationToken create
   */
  export type EmailVerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>
  }

  /**
   * EmailVerificationToken createMany
   */
  export type EmailVerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * EmailVerificationToken createManyAndReturn
   */
  export type EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerificationToken update
   */
  export type EmailVerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which EmailVerificationToken to update.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken updateMany
   */
  export type EmailVerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * EmailVerificationToken updateManyAndReturn
   */
  export type EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerificationToken upsert
   */
  export type EmailVerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailVerificationToken to update in case it exists.
     */
    where: EmailVerificationTokenWhereUniqueInput
    /**
     * In case the EmailVerificationToken found by the `where` argument doesn't exist, create a new EmailVerificationToken with this data.
     */
    create: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>
    /**
     * In case the EmailVerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>
  }

  /**
   * EmailVerificationToken delete
   */
  export type EmailVerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter which EmailVerificationToken to delete.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken deleteMany
   */
  export type EmailVerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerificationTokens to delete
     */
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    /**
     * Limit how many EmailVerificationTokens to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * EmailVerificationToken without action
   */
  export type EmailVerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
    duration: number | null
    defaultDuration: number | null
  }

  export type FileSumAggregateOutputType = {
    size: bigint | null
    width: number | null
    height: number | null
    duration: number | null
    defaultDuration: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    extension: string | null
    mimeType: string | null
    previewPath: string | null
    size: bigint | null
    type: string | null
    path: string | null
    width: number | null
    height: number | null
    duration: number | null
    defaultDuration: number | null
    md5: string | null
    folderId: string | null
    availabilityStartAt: Date | null
    availabilityEndAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    uploaderId: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    extension: string | null
    mimeType: string | null
    previewPath: string | null
    size: bigint | null
    type: string | null
    path: string | null
    width: number | null
    height: number | null
    duration: number | null
    defaultDuration: number | null
    md5: string | null
    folderId: string | null
    availabilityStartAt: Date | null
    availabilityEndAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    uploaderId: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    extension: number
    mimeType: number
    previewPath: number
    size: number
    type: number
    path: number
    width: number
    height: number
    duration: number
    defaultDuration: number
    md5: number
    folderId: number
    availabilityStartAt: number
    availabilityEndAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    uploaderId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    duration?: true | $Types.Skip
    defaultDuration?: true | $Types.Skip
  }

  export type FileSumAggregateInputType = {
    size?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    duration?: true | $Types.Skip
    defaultDuration?: true | $Types.Skip
  }

  export type FileMinAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    name?: true | $Types.Skip
    extension?: true | $Types.Skip
    mimeType?: true | $Types.Skip
    previewPath?: true | $Types.Skip
    size?: true | $Types.Skip
    type?: true | $Types.Skip
    path?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    duration?: true | $Types.Skip
    defaultDuration?: true | $Types.Skip
    md5?: true | $Types.Skip
    folderId?: true | $Types.Skip
    availabilityStartAt?: true | $Types.Skip
    availabilityEndAt?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
    uploaderId?: true | $Types.Skip
  }

  export type FileMaxAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    name?: true | $Types.Skip
    extension?: true | $Types.Skip
    mimeType?: true | $Types.Skip
    previewPath?: true | $Types.Skip
    size?: true | $Types.Skip
    type?: true | $Types.Skip
    path?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    duration?: true | $Types.Skip
    defaultDuration?: true | $Types.Skip
    md5?: true | $Types.Skip
    folderId?: true | $Types.Skip
    availabilityStartAt?: true | $Types.Skip
    availabilityEndAt?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
    uploaderId?: true | $Types.Skip
  }

  export type FileCountAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    name?: true | $Types.Skip
    extension?: true | $Types.Skip
    mimeType?: true | $Types.Skip
    previewPath?: true | $Types.Skip
    size?: true | $Types.Skip
    type?: true | $Types.Skip
    path?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    duration?: true | $Types.Skip
    defaultDuration?: true | $Types.Skip
    md5?: true | $Types.Skip
    folderId?: true | $Types.Skip
    availabilityStartAt?: true | $Types.Skip
    availabilityEndAt?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
    uploaderId?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput | $Types.Skip
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[] | $Types.Skip
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    extension: string
    mimeType: string
    previewPath: string | null
    size: bigint
    type: string
    path: string
    width: number | null
    height: number | null
    duration: number | null
    defaultDuration: number | null
    md5: string | null
    folderId: string | null
    availabilityStartAt: Date | null
    availabilityEndAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    uploaderId: string | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    extension?: boolean | $Types.Skip
    mimeType?: boolean | $Types.Skip
    previewPath?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    path?: boolean | $Types.Skip
    width?: boolean | $Types.Skip
    height?: boolean | $Types.Skip
    duration?: boolean | $Types.Skip
    defaultDuration?: boolean | $Types.Skip
    md5?: boolean | $Types.Skip
    folderId?: boolean | $Types.Skip
    availabilityStartAt?: boolean | $Types.Skip
    availabilityEndAt?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    uploaderId?: boolean | $Types.Skip
    folder?: boolean | File$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    uploader?: boolean | File$uploaderArgs<ExtArgs> | $Types.Skip
    playlistItems?: boolean | File$playlistItemsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    extension?: boolean | $Types.Skip
    mimeType?: boolean | $Types.Skip
    previewPath?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    path?: boolean | $Types.Skip
    width?: boolean | $Types.Skip
    height?: boolean | $Types.Skip
    duration?: boolean | $Types.Skip
    defaultDuration?: boolean | $Types.Skip
    md5?: boolean | $Types.Skip
    folderId?: boolean | $Types.Skip
    availabilityStartAt?: boolean | $Types.Skip
    availabilityEndAt?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    uploaderId?: boolean | $Types.Skip
    folder?: boolean | File$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    uploader?: boolean | File$uploaderArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    extension?: boolean | $Types.Skip
    mimeType?: boolean | $Types.Skip
    previewPath?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    path?: boolean | $Types.Skip
    width?: boolean | $Types.Skip
    height?: boolean | $Types.Skip
    duration?: boolean | $Types.Skip
    defaultDuration?: boolean | $Types.Skip
    md5?: boolean | $Types.Skip
    folderId?: boolean | $Types.Skip
    availabilityStartAt?: boolean | $Types.Skip
    availabilityEndAt?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    uploaderId?: boolean | $Types.Skip
    folder?: boolean | File$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    uploader?: boolean | File$uploaderArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    extension?: boolean | $Types.Skip
    mimeType?: boolean | $Types.Skip
    previewPath?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    path?: boolean | $Types.Skip
    width?: boolean | $Types.Skip
    height?: boolean | $Types.Skip
    duration?: boolean | $Types.Skip
    defaultDuration?: boolean | $Types.Skip
    md5?: boolean | $Types.Skip
    folderId?: boolean | $Types.Skip
    availabilityStartAt?: boolean | $Types.Skip
    availabilityEndAt?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    uploaderId?: boolean | $Types.Skip
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "extension" | "mimeType" | "previewPath" | "size" | "type" | "path" | "width" | "height" | "duration" | "defaultDuration" | "md5" | "folderId" | "availabilityStartAt" | "availabilityEndAt" | "createdAt" | "updatedAt" | "deletedAt" | "uploaderId", ExtArgs["result"]["file"], $Types.Skip>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | File$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    uploader?: boolean | File$uploaderArgs<ExtArgs> | $Types.Skip
    playlistItems?: boolean | File$playlistItemsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | File$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    uploader?: boolean | File$uploaderArgs<ExtArgs> | $Types.Skip
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | File$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    uploader?: boolean | File$uploaderArgs<ExtArgs> | $Types.Skip
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      folder: Prisma.$FolderPayload<ExtArgs> | null
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs> | null
      playlistItems: Prisma.$PlaylistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      extension: string
      mimeType: string
      previewPath: string | null
      size: bigint
      type: string
      path: string
      width: number | null
      height: number | null
      duration: number | null
      defaultDuration: number | null
      md5: string | null
      folderId: string | null
      availabilityStartAt: Date | null
      availabilityEndAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      uploaderId: string | null
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    folder<T extends File$folderArgs<ExtArgs> = {}>(args?: Subset<T, File$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends File$uploaderArgs<ExtArgs> = {}>(args?: Subset<T, File$uploaderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    playlistItems<T extends File$playlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, File$playlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly workspaceId: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly extension: FieldRef<"File", 'String'>
    readonly mimeType: FieldRef<"File", 'String'>
    readonly previewPath: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'BigInt'>
    readonly type: FieldRef<"File", 'String'>
    readonly path: FieldRef<"File", 'String'>
    readonly width: FieldRef<"File", 'Int'>
    readonly height: FieldRef<"File", 'Int'>
    readonly duration: FieldRef<"File", 'Int'>
    readonly defaultDuration: FieldRef<"File", 'Int'>
    readonly md5: FieldRef<"File", 'String'>
    readonly folderId: FieldRef<"File", 'String'>
    readonly availabilityStartAt: FieldRef<"File", 'DateTime'>
    readonly availabilityEndAt: FieldRef<"File", 'DateTime'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly deletedAt: FieldRef<"File", 'DateTime'>
    readonly uploaderId: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[] | $Types.Skip
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[] | $Types.Skip
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number | $Types.Skip
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[] | $Types.Skip
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput | $Types.Skip
    /**
     * Limit how many Files to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput | $Types.Skip
    /**
     * Limit how many Files to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput | $Types.Skip
    /**
     * Limit how many Files to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * File.folder
   */
  export type File$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput | $Types.Skip
  }

  /**
   * File.uploader
   */
  export type File$uploaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput | $Types.Skip
  }

  /**
   * File.playlistItems
   */
  export type File$playlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    where?: PlaylistItemWhereInput | $Types.Skip
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistItemWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[] | $Types.Skip
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model FileUploadSession
   */

  export type AggregateFileUploadSession = {
    _count: FileUploadSessionCountAggregateOutputType | null
    _avg: FileUploadSessionAvgAggregateOutputType | null
    _sum: FileUploadSessionSumAggregateOutputType | null
    _min: FileUploadSessionMinAggregateOutputType | null
    _max: FileUploadSessionMaxAggregateOutputType | null
  }

  export type FileUploadSessionAvgAggregateOutputType = {
    size: number | null
    uploaded: number | null
    parts: number | null
  }

  export type FileUploadSessionSumAggregateOutputType = {
    size: bigint | null
    uploaded: bigint | null
    parts: number | null
  }

  export type FileUploadSessionMinAggregateOutputType = {
    id: string | null
    name: string | null
    path: string | null
    size: bigint | null
    uploaded: bigint | null
    parts: number | null
    mimeType: string | null
    workspaceId: string | null
    uploadId: string | null
    folderId: string | null
    userId: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type FileUploadSessionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    path: string | null
    size: bigint | null
    uploaded: bigint | null
    parts: number | null
    mimeType: string | null
    workspaceId: string | null
    uploadId: string | null
    folderId: string | null
    userId: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type FileUploadSessionCountAggregateOutputType = {
    id: number
    name: number
    path: number
    size: number
    uploaded: number
    parts: number
    mimeType: number
    workspaceId: number
    uploadId: number
    folderId: number
    userId: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type FileUploadSessionAvgAggregateInputType = {
    size?: true | $Types.Skip
    uploaded?: true | $Types.Skip
    parts?: true | $Types.Skip
  }

  export type FileUploadSessionSumAggregateInputType = {
    size?: true | $Types.Skip
    uploaded?: true | $Types.Skip
    parts?: true | $Types.Skip
  }

  export type FileUploadSessionMinAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    path?: true | $Types.Skip
    size?: true | $Types.Skip
    uploaded?: true | $Types.Skip
    parts?: true | $Types.Skip
    mimeType?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    uploadId?: true | $Types.Skip
    folderId?: true | $Types.Skip
    userId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    completedAt?: true | $Types.Skip
  }

  export type FileUploadSessionMaxAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    path?: true | $Types.Skip
    size?: true | $Types.Skip
    uploaded?: true | $Types.Skip
    parts?: true | $Types.Skip
    mimeType?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    uploadId?: true | $Types.Skip
    folderId?: true | $Types.Skip
    userId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    completedAt?: true | $Types.Skip
  }

  export type FileUploadSessionCountAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    path?: true | $Types.Skip
    size?: true | $Types.Skip
    uploaded?: true | $Types.Skip
    parts?: true | $Types.Skip
    mimeType?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    uploadId?: true | $Types.Skip
    folderId?: true | $Types.Skip
    userId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    completedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type FileUploadSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileUploadSession to aggregate.
     */
    where?: FileUploadSessionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileUploadSessions to fetch.
     */
    orderBy?: FileUploadSessionOrderByWithRelationInput | FileUploadSessionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileUploadSessionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileUploadSessions from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileUploadSessions.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileUploadSessions
    **/
    _count?: true | FileUploadSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileUploadSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileUploadSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileUploadSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileUploadSessionMaxAggregateInputType
  }

  export type GetFileUploadSessionAggregateType<T extends FileUploadSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateFileUploadSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileUploadSession[P]>
      : GetScalarType<T[P], AggregateFileUploadSession[P]>
  }




  export type FileUploadSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileUploadSessionWhereInput | $Types.Skip
    orderBy?: FileUploadSessionOrderByWithAggregationInput | FileUploadSessionOrderByWithAggregationInput[] | $Types.Skip
    by: FileUploadSessionScalarFieldEnum[] | FileUploadSessionScalarFieldEnum
    having?: FileUploadSessionScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: FileUploadSessionCountAggregateInputType | true
    _avg?: FileUploadSessionAvgAggregateInputType
    _sum?: FileUploadSessionSumAggregateInputType
    _min?: FileUploadSessionMinAggregateInputType
    _max?: FileUploadSessionMaxAggregateInputType
  }

  export type FileUploadSessionGroupByOutputType = {
    id: string
    name: string
    path: string
    size: bigint
    uploaded: bigint
    parts: number
    mimeType: string
    workspaceId: string
    uploadId: string
    folderId: string | null
    userId: string
    createdAt: Date
    completedAt: Date | null
    _count: FileUploadSessionCountAggregateOutputType | null
    _avg: FileUploadSessionAvgAggregateOutputType | null
    _sum: FileUploadSessionSumAggregateOutputType | null
    _min: FileUploadSessionMinAggregateOutputType | null
    _max: FileUploadSessionMaxAggregateOutputType | null
  }

  type GetFileUploadSessionGroupByPayload<T extends FileUploadSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileUploadSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileUploadSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileUploadSessionGroupByOutputType[P]>
            : GetScalarType<T[P], FileUploadSessionGroupByOutputType[P]>
        }
      >
    >


  export type FileUploadSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    path?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    uploaded?: boolean | $Types.Skip
    parts?: boolean | $Types.Skip
    mimeType?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    uploadId?: boolean | $Types.Skip
    folderId?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    completedAt?: boolean | $Types.Skip
    folder?: boolean | FileUploadSession$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["fileUploadSession"]>

  export type FileUploadSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    path?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    uploaded?: boolean | $Types.Skip
    parts?: boolean | $Types.Skip
    mimeType?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    uploadId?: boolean | $Types.Skip
    folderId?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    completedAt?: boolean | $Types.Skip
    folder?: boolean | FileUploadSession$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["fileUploadSession"]>

  export type FileUploadSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    path?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    uploaded?: boolean | $Types.Skip
    parts?: boolean | $Types.Skip
    mimeType?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    uploadId?: boolean | $Types.Skip
    folderId?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    completedAt?: boolean | $Types.Skip
    folder?: boolean | FileUploadSession$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["fileUploadSession"]>

  export type FileUploadSessionSelectScalar = {
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    path?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    uploaded?: boolean | $Types.Skip
    parts?: boolean | $Types.Skip
    mimeType?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    uploadId?: boolean | $Types.Skip
    folderId?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    completedAt?: boolean | $Types.Skip
  }

  export type FileUploadSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "path" | "size" | "uploaded" | "parts" | "mimeType" | "workspaceId" | "uploadId" | "folderId" | "userId" | "createdAt" | "completedAt", ExtArgs["result"]["fileUploadSession"], $Types.Skip>
  export type FileUploadSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | FileUploadSession$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type FileUploadSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | FileUploadSession$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type FileUploadSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | FileUploadSession$folderArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $FileUploadSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileUploadSession"
    objects: {
      folder: Prisma.$FolderPayload<ExtArgs> | null
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      path: string
      size: bigint
      uploaded: bigint
      parts: number
      mimeType: string
      workspaceId: string
      uploadId: string
      folderId: string | null
      userId: string
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["fileUploadSession"]>
    composites: {}
  }

  type FileUploadSessionGetPayload<S extends boolean | null | undefined | FileUploadSessionDefaultArgs> = $Result.GetResult<Prisma.$FileUploadSessionPayload, S>

  type FileUploadSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileUploadSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileUploadSessionCountAggregateInputType | true
    }

  export interface FileUploadSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileUploadSession'], meta: { name: 'FileUploadSession' } }
    /**
     * Find zero or one FileUploadSession that matches the filter.
     * @param {FileUploadSessionFindUniqueArgs} args - Arguments to find a FileUploadSession
     * @example
     * // Get one FileUploadSession
     * const fileUploadSession = await prisma.fileUploadSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileUploadSessionFindUniqueArgs>(args: SelectSubset<T, FileUploadSessionFindUniqueArgs<ExtArgs>>): Prisma__FileUploadSessionClient<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileUploadSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileUploadSessionFindUniqueOrThrowArgs} args - Arguments to find a FileUploadSession
     * @example
     * // Get one FileUploadSession
     * const fileUploadSession = await prisma.fileUploadSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileUploadSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, FileUploadSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileUploadSessionClient<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileUploadSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadSessionFindFirstArgs} args - Arguments to find a FileUploadSession
     * @example
     * // Get one FileUploadSession
     * const fileUploadSession = await prisma.fileUploadSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileUploadSessionFindFirstArgs>(args?: SelectSubset<T, FileUploadSessionFindFirstArgs<ExtArgs>>): Prisma__FileUploadSessionClient<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileUploadSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadSessionFindFirstOrThrowArgs} args - Arguments to find a FileUploadSession
     * @example
     * // Get one FileUploadSession
     * const fileUploadSession = await prisma.fileUploadSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileUploadSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, FileUploadSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileUploadSessionClient<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileUploadSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileUploadSessions
     * const fileUploadSessions = await prisma.fileUploadSession.findMany()
     * 
     * // Get first 10 FileUploadSessions
     * const fileUploadSessions = await prisma.fileUploadSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileUploadSessionWithIdOnly = await prisma.fileUploadSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileUploadSessionFindManyArgs>(args?: SelectSubset<T, FileUploadSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileUploadSession.
     * @param {FileUploadSessionCreateArgs} args - Arguments to create a FileUploadSession.
     * @example
     * // Create one FileUploadSession
     * const FileUploadSession = await prisma.fileUploadSession.create({
     *   data: {
     *     // ... data to create a FileUploadSession
     *   }
     * })
     * 
     */
    create<T extends FileUploadSessionCreateArgs>(args: SelectSubset<T, FileUploadSessionCreateArgs<ExtArgs>>): Prisma__FileUploadSessionClient<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileUploadSessions.
     * @param {FileUploadSessionCreateManyArgs} args - Arguments to create many FileUploadSessions.
     * @example
     * // Create many FileUploadSessions
     * const fileUploadSession = await prisma.fileUploadSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileUploadSessionCreateManyArgs>(args?: SelectSubset<T, FileUploadSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileUploadSessions and returns the data saved in the database.
     * @param {FileUploadSessionCreateManyAndReturnArgs} args - Arguments to create many FileUploadSessions.
     * @example
     * // Create many FileUploadSessions
     * const fileUploadSession = await prisma.fileUploadSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileUploadSessions and only return the `id`
     * const fileUploadSessionWithIdOnly = await prisma.fileUploadSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileUploadSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, FileUploadSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileUploadSession.
     * @param {FileUploadSessionDeleteArgs} args - Arguments to delete one FileUploadSession.
     * @example
     * // Delete one FileUploadSession
     * const FileUploadSession = await prisma.fileUploadSession.delete({
     *   where: {
     *     // ... filter to delete one FileUploadSession
     *   }
     * })
     * 
     */
    delete<T extends FileUploadSessionDeleteArgs>(args: SelectSubset<T, FileUploadSessionDeleteArgs<ExtArgs>>): Prisma__FileUploadSessionClient<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileUploadSession.
     * @param {FileUploadSessionUpdateArgs} args - Arguments to update one FileUploadSession.
     * @example
     * // Update one FileUploadSession
     * const fileUploadSession = await prisma.fileUploadSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUploadSessionUpdateArgs>(args: SelectSubset<T, FileUploadSessionUpdateArgs<ExtArgs>>): Prisma__FileUploadSessionClient<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileUploadSessions.
     * @param {FileUploadSessionDeleteManyArgs} args - Arguments to filter FileUploadSessions to delete.
     * @example
     * // Delete a few FileUploadSessions
     * const { count } = await prisma.fileUploadSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileUploadSessionDeleteManyArgs>(args?: SelectSubset<T, FileUploadSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileUploadSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileUploadSessions
     * const fileUploadSession = await prisma.fileUploadSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUploadSessionUpdateManyArgs>(args: SelectSubset<T, FileUploadSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileUploadSessions and returns the data updated in the database.
     * @param {FileUploadSessionUpdateManyAndReturnArgs} args - Arguments to update many FileUploadSessions.
     * @example
     * // Update many FileUploadSessions
     * const fileUploadSession = await prisma.fileUploadSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileUploadSessions and only return the `id`
     * const fileUploadSessionWithIdOnly = await prisma.fileUploadSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUploadSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUploadSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileUploadSession.
     * @param {FileUploadSessionUpsertArgs} args - Arguments to update or create a FileUploadSession.
     * @example
     * // Update or create a FileUploadSession
     * const fileUploadSession = await prisma.fileUploadSession.upsert({
     *   create: {
     *     // ... data to create a FileUploadSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileUploadSession we want to update
     *   }
     * })
     */
    upsert<T extends FileUploadSessionUpsertArgs>(args: SelectSubset<T, FileUploadSessionUpsertArgs<ExtArgs>>): Prisma__FileUploadSessionClient<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileUploadSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadSessionCountArgs} args - Arguments to filter FileUploadSessions to count.
     * @example
     * // Count the number of FileUploadSessions
     * const count = await prisma.fileUploadSession.count({
     *   where: {
     *     // ... the filter for the FileUploadSessions we want to count
     *   }
     * })
    **/
    count<T extends FileUploadSessionCountArgs>(
      args?: Subset<T, FileUploadSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileUploadSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileUploadSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileUploadSessionAggregateArgs>(args: Subset<T, FileUploadSessionAggregateArgs>): Prisma.PrismaPromise<GetFileUploadSessionAggregateType<T>>

    /**
     * Group by FileUploadSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUploadSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileUploadSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileUploadSessionGroupByArgs['orderBy'] }
        : { orderBy?: FileUploadSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileUploadSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileUploadSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileUploadSession model
   */
  readonly fields: FileUploadSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileUploadSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileUploadSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    folder<T extends FileUploadSession$folderArgs<ExtArgs> = {}>(args?: Subset<T, FileUploadSession$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileUploadSession model
   */
  interface FileUploadSessionFieldRefs {
    readonly id: FieldRef<"FileUploadSession", 'String'>
    readonly name: FieldRef<"FileUploadSession", 'String'>
    readonly path: FieldRef<"FileUploadSession", 'String'>
    readonly size: FieldRef<"FileUploadSession", 'BigInt'>
    readonly uploaded: FieldRef<"FileUploadSession", 'BigInt'>
    readonly parts: FieldRef<"FileUploadSession", 'Int'>
    readonly mimeType: FieldRef<"FileUploadSession", 'String'>
    readonly workspaceId: FieldRef<"FileUploadSession", 'String'>
    readonly uploadId: FieldRef<"FileUploadSession", 'String'>
    readonly folderId: FieldRef<"FileUploadSession", 'String'>
    readonly userId: FieldRef<"FileUploadSession", 'String'>
    readonly createdAt: FieldRef<"FileUploadSession", 'DateTime'>
    readonly completedAt: FieldRef<"FileUploadSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileUploadSession findUnique
   */
  export type FileUploadSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which FileUploadSession to fetch.
     */
    where: FileUploadSessionWhereUniqueInput
  }

  /**
   * FileUploadSession findUniqueOrThrow
   */
  export type FileUploadSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which FileUploadSession to fetch.
     */
    where: FileUploadSessionWhereUniqueInput
  }

  /**
   * FileUploadSession findFirst
   */
  export type FileUploadSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which FileUploadSession to fetch.
     */
    where?: FileUploadSessionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileUploadSessions to fetch.
     */
    orderBy?: FileUploadSessionOrderByWithRelationInput | FileUploadSessionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileUploadSessions.
     */
    cursor?: FileUploadSessionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileUploadSessions from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileUploadSessions.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileUploadSessions.
     */
    distinct?: FileUploadSessionScalarFieldEnum | FileUploadSessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * FileUploadSession findFirstOrThrow
   */
  export type FileUploadSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which FileUploadSession to fetch.
     */
    where?: FileUploadSessionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileUploadSessions to fetch.
     */
    orderBy?: FileUploadSessionOrderByWithRelationInput | FileUploadSessionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileUploadSessions.
     */
    cursor?: FileUploadSessionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileUploadSessions from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileUploadSessions.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileUploadSessions.
     */
    distinct?: FileUploadSessionScalarFieldEnum | FileUploadSessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * FileUploadSession findMany
   */
  export type FileUploadSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which FileUploadSessions to fetch.
     */
    where?: FileUploadSessionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileUploadSessions to fetch.
     */
    orderBy?: FileUploadSessionOrderByWithRelationInput | FileUploadSessionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileUploadSessions.
     */
    cursor?: FileUploadSessionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileUploadSessions from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileUploadSessions.
     */
    skip?: number | $Types.Skip
    distinct?: FileUploadSessionScalarFieldEnum | FileUploadSessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * FileUploadSession create
   */
  export type FileUploadSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a FileUploadSession.
     */
    data: XOR<FileUploadSessionCreateInput, FileUploadSessionUncheckedCreateInput>
  }

  /**
   * FileUploadSession createMany
   */
  export type FileUploadSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileUploadSessions.
     */
    data: FileUploadSessionCreateManyInput | FileUploadSessionCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * FileUploadSession createManyAndReturn
   */
  export type FileUploadSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * The data used to create many FileUploadSessions.
     */
    data: FileUploadSessionCreateManyInput | FileUploadSessionCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileUploadSession update
   */
  export type FileUploadSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a FileUploadSession.
     */
    data: XOR<FileUploadSessionUpdateInput, FileUploadSessionUncheckedUpdateInput>
    /**
     * Choose, which FileUploadSession to update.
     */
    where: FileUploadSessionWhereUniqueInput
  }

  /**
   * FileUploadSession updateMany
   */
  export type FileUploadSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileUploadSessions.
     */
    data: XOR<FileUploadSessionUpdateManyMutationInput, FileUploadSessionUncheckedUpdateManyInput>
    /**
     * Filter which FileUploadSessions to update
     */
    where?: FileUploadSessionWhereInput | $Types.Skip
    /**
     * Limit how many FileUploadSessions to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * FileUploadSession updateManyAndReturn
   */
  export type FileUploadSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * The data used to update FileUploadSessions.
     */
    data: XOR<FileUploadSessionUpdateManyMutationInput, FileUploadSessionUncheckedUpdateManyInput>
    /**
     * Filter which FileUploadSessions to update
     */
    where?: FileUploadSessionWhereInput | $Types.Skip
    /**
     * Limit how many FileUploadSessions to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileUploadSession upsert
   */
  export type FileUploadSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the FileUploadSession to update in case it exists.
     */
    where: FileUploadSessionWhereUniqueInput
    /**
     * In case the FileUploadSession found by the `where` argument doesn't exist, create a new FileUploadSession with this data.
     */
    create: XOR<FileUploadSessionCreateInput, FileUploadSessionUncheckedCreateInput>
    /**
     * In case the FileUploadSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUploadSessionUpdateInput, FileUploadSessionUncheckedUpdateInput>
  }

  /**
   * FileUploadSession delete
   */
  export type FileUploadSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    /**
     * Filter which FileUploadSession to delete.
     */
    where: FileUploadSessionWhereUniqueInput
  }

  /**
   * FileUploadSession deleteMany
   */
  export type FileUploadSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileUploadSessions to delete
     */
    where?: FileUploadSessionWhereInput | $Types.Skip
    /**
     * Limit how many FileUploadSessions to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * FileUploadSession.folder
   */
  export type FileUploadSession$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput | $Types.Skip
  }

  /**
   * FileUploadSession without action
   */
  export type FileUploadSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    workspaceId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    workspaceId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    name: number
    workspaceId: number
    parentId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type FolderMinAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    parentId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
  }

  export type FolderMaxAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    parentId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
  }

  export type FolderCountAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    parentId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput | $Types.Skip
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[] | $Types.Skip
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: FolderCountAggregateInputType | true
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    name: string
    workspaceId: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    parentId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    parent?: boolean | Folder$parentArgs<ExtArgs> | $Types.Skip
    subfolders?: boolean | Folder$subfoldersArgs<ExtArgs> | $Types.Skip
    files?: boolean | Folder$filesArgs<ExtArgs> | $Types.Skip
    fileUploadSessions?: boolean | Folder$fileUploadSessionsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    parentId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    parent?: boolean | Folder$parentArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    parentId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    parent?: boolean | Folder$parentArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    parentId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "workspaceId" | "parentId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["folder"], $Types.Skip>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    parent?: boolean | Folder$parentArgs<ExtArgs> | $Types.Skip
    subfolders?: boolean | Folder$subfoldersArgs<ExtArgs> | $Types.Skip
    files?: boolean | Folder$filesArgs<ExtArgs> | $Types.Skip
    fileUploadSessions?: boolean | Folder$fileUploadSessionsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    parent?: boolean | Folder$parentArgs<ExtArgs> | $Types.Skip
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    parent?: boolean | Folder$parentArgs<ExtArgs> | $Types.Skip
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      parent: Prisma.$FolderPayload<ExtArgs> | null
      subfolders: Prisma.$FolderPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      fileUploadSessions: Prisma.$FileUploadSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      workspaceId: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Folder$parentArgs<ExtArgs> = {}>(args?: Subset<T, Folder$parentArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subfolders<T extends Folder$subfoldersArgs<ExtArgs> = {}>(args?: Subset<T, Folder$subfoldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Folder$filesArgs<ExtArgs> = {}>(args?: Subset<T, Folder$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileUploadSessions<T extends Folder$fileUploadSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Folder$fileUploadSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly workspaceId: FieldRef<"Folder", 'String'>
    readonly parentId: FieldRef<"Folder", 'String'>
    readonly createdAt: FieldRef<"Folder", 'DateTime'>
    readonly updatedAt: FieldRef<"Folder", 'DateTime'>
    readonly deletedAt: FieldRef<"Folder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number | $Types.Skip
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput | $Types.Skip
    /**
     * Limit how many Folders to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput | $Types.Skip
    /**
     * Limit how many Folders to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput | $Types.Skip
    /**
     * Limit how many Folders to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Folder.parent
   */
  export type Folder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput | $Types.Skip
  }

  /**
   * Folder.subfolders
   */
  export type Folder$subfoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput | $Types.Skip
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[] | $Types.Skip
    cursor?: FolderWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Folder.files
   */
  export type Folder$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput | $Types.Skip
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[] | $Types.Skip
    cursor?: FileWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Folder.fileUploadSessions
   */
  export type Folder$fileUploadSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    where?: FileUploadSessionWhereInput | $Types.Skip
    orderBy?: FileUploadSessionOrderByWithRelationInput | FileUploadSessionOrderByWithRelationInput[] | $Types.Skip
    cursor?: FileUploadSessionWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: FileUploadSessionScalarFieldEnum | FileUploadSessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model Playlist
   */

  export type AggregatePlaylist = {
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  export type PlaylistAvgAggregateOutputType = {
    size: number | null
    priority: number | null
  }

  export type PlaylistSumAggregateOutputType = {
    size: bigint | null
    priority: number | null
  }

  export type PlaylistMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    playlistLayoutId: string | null
    name: string | null
    description: string | null
    size: bigint | null
    type: string | null
    isPublished: boolean | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PlaylistMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    playlistLayoutId: string | null
    name: string | null
    description: string | null
    size: bigint | null
    type: string | null
    isPublished: boolean | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PlaylistCountAggregateOutputType = {
    id: number
    workspaceId: number
    playlistLayoutId: number
    name: number
    description: number
    size: number
    type: number
    isPublished: number
    priority: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PlaylistAvgAggregateInputType = {
    size?: true | $Types.Skip
    priority?: true | $Types.Skip
  }

  export type PlaylistSumAggregateInputType = {
    size?: true | $Types.Skip
    priority?: true | $Types.Skip
  }

  export type PlaylistMinAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    playlistLayoutId?: true | $Types.Skip
    name?: true | $Types.Skip
    description?: true | $Types.Skip
    size?: true | $Types.Skip
    type?: true | $Types.Skip
    isPublished?: true | $Types.Skip
    priority?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
  }

  export type PlaylistMaxAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    playlistLayoutId?: true | $Types.Skip
    name?: true | $Types.Skip
    description?: true | $Types.Skip
    size?: true | $Types.Skip
    type?: true | $Types.Skip
    isPublished?: true | $Types.Skip
    priority?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
  }

  export type PlaylistCountAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    playlistLayoutId?: true | $Types.Skip
    name?: true | $Types.Skip
    description?: true | $Types.Skip
    size?: true | $Types.Skip
    type?: true | $Types.Skip
    isPublished?: true | $Types.Skip
    priority?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type PlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlist to aggregate.
     */
    where?: PlaylistWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Playlists
    **/
    _count?: true | PlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistMaxAggregateInputType
  }

  export type GetPlaylistAggregateType<T extends PlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylist[P]>
      : GetScalarType<T[P], AggregatePlaylist[P]>
  }




  export type PlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput | $Types.Skip
    orderBy?: PlaylistOrderByWithAggregationInput | PlaylistOrderByWithAggregationInput[] | $Types.Skip
    by: PlaylistScalarFieldEnum[] | PlaylistScalarFieldEnum
    having?: PlaylistScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: PlaylistCountAggregateInputType | true
    _avg?: PlaylistAvgAggregateInputType
    _sum?: PlaylistSumAggregateInputType
    _min?: PlaylistMinAggregateInputType
    _max?: PlaylistMaxAggregateInputType
  }

  export type PlaylistGroupByOutputType = {
    id: string
    workspaceId: string
    playlistLayoutId: string | null
    name: string
    description: string
    size: bigint
    type: string
    isPublished: boolean
    priority: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  type GetPlaylistGroupByPayload<T extends PlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    playlistLayoutId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    description?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    layout?: boolean | Playlist$layoutArgs<ExtArgs> | $Types.Skip
    items?: boolean | Playlist$itemsArgs<ExtArgs> | $Types.Skip
    parentItems?: boolean | Playlist$parentItemsArgs<ExtArgs> | $Types.Skip
    screens?: boolean | Playlist$screensArgs<ExtArgs> | $Types.Skip
    schedules?: boolean | Playlist$schedulesArgs<ExtArgs> | $Types.Skip
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    playlistLayoutId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    description?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    layout?: boolean | Playlist$layoutArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    playlistLayoutId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    description?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    layout?: boolean | Playlist$layoutArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectScalar = {
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    playlistLayoutId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    description?: boolean | $Types.Skip
    size?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
  }

  export type PlaylistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "playlistLayoutId" | "name" | "description" | "size" | "type" | "isPublished" | "priority" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["playlist"], $Types.Skip>
  export type PlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    layout?: boolean | Playlist$layoutArgs<ExtArgs> | $Types.Skip
    items?: boolean | Playlist$itemsArgs<ExtArgs> | $Types.Skip
    parentItems?: boolean | Playlist$parentItemsArgs<ExtArgs> | $Types.Skip
    screens?: boolean | Playlist$screensArgs<ExtArgs> | $Types.Skip
    schedules?: boolean | Playlist$schedulesArgs<ExtArgs> | $Types.Skip
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    layout?: boolean | Playlist$layoutArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    layout?: boolean | Playlist$layoutArgs<ExtArgs> | $Types.Skip
  }

  export type $PlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Playlist"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      layout: Prisma.$PlaylistLayoutPayload<ExtArgs> | null
      items: Prisma.$PlaylistItemPayload<ExtArgs>[]
      parentItems: Prisma.$PlaylistItemPayload<ExtArgs>[]
      screens: Prisma.$PlaylistScreenPayload<ExtArgs>[]
      schedules: Prisma.$PlaylistSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      playlistLayoutId: string | null
      name: string
      description: string
      size: bigint
      type: string
      isPublished: boolean
      priority: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["playlist"]>
    composites: {}
  }

  type PlaylistGetPayload<S extends boolean | null | undefined | PlaylistDefaultArgs> = $Result.GetResult<Prisma.$PlaylistPayload, S>

  type PlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistCountAggregateInputType | true
    }

  export interface PlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Playlist'], meta: { name: 'Playlist' } }
    /**
     * Find zero or one Playlist that matches the filter.
     * @param {PlaylistFindUniqueArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistFindUniqueArgs>(args: SelectSubset<T, PlaylistFindUniqueArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Playlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistFindUniqueOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistFindFirstArgs>(args?: SelectSubset<T, PlaylistFindFirstArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Playlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Playlists
     * const playlists = await prisma.playlist.findMany()
     * 
     * // Get first 10 Playlists
     * const playlists = await prisma.playlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistWithIdOnly = await prisma.playlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistFindManyArgs>(args?: SelectSubset<T, PlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Playlist.
     * @param {PlaylistCreateArgs} args - Arguments to create a Playlist.
     * @example
     * // Create one Playlist
     * const Playlist = await prisma.playlist.create({
     *   data: {
     *     // ... data to create a Playlist
     *   }
     * })
     * 
     */
    create<T extends PlaylistCreateArgs>(args: SelectSubset<T, PlaylistCreateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Playlists.
     * @param {PlaylistCreateManyArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistCreateManyArgs>(args?: SelectSubset<T, PlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Playlists and returns the data saved in the database.
     * @param {PlaylistCreateManyAndReturnArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Playlist.
     * @param {PlaylistDeleteArgs} args - Arguments to delete one Playlist.
     * @example
     * // Delete one Playlist
     * const Playlist = await prisma.playlist.delete({
     *   where: {
     *     // ... filter to delete one Playlist
     *   }
     * })
     * 
     */
    delete<T extends PlaylistDeleteArgs>(args: SelectSubset<T, PlaylistDeleteArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Playlist.
     * @param {PlaylistUpdateArgs} args - Arguments to update one Playlist.
     * @example
     * // Update one Playlist
     * const playlist = await prisma.playlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistUpdateArgs>(args: SelectSubset<T, PlaylistUpdateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Playlists.
     * @param {PlaylistDeleteManyArgs} args - Arguments to filter Playlists to delete.
     * @example
     * // Delete a few Playlists
     * const { count } = await prisma.playlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistDeleteManyArgs>(args?: SelectSubset<T, PlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistUpdateManyArgs>(args: SelectSubset<T, PlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists and returns the data updated in the database.
     * @param {PlaylistUpdateManyAndReturnArgs} args - Arguments to update many Playlists.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Playlist.
     * @param {PlaylistUpsertArgs} args - Arguments to update or create a Playlist.
     * @example
     * // Update or create a Playlist
     * const playlist = await prisma.playlist.upsert({
     *   create: {
     *     // ... data to create a Playlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Playlist we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistUpsertArgs>(args: SelectSubset<T, PlaylistUpsertArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistCountArgs} args - Arguments to filter Playlists to count.
     * @example
     * // Count the number of Playlists
     * const count = await prisma.playlist.count({
     *   where: {
     *     // ... the filter for the Playlists we want to count
     *   }
     * })
    **/
    count<T extends PlaylistCountArgs>(
      args?: Subset<T, PlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistAggregateArgs>(args: Subset<T, PlaylistAggregateArgs>): Prisma.PrismaPromise<GetPlaylistAggregateType<T>>

    /**
     * Group by Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Playlist model
   */
  readonly fields: PlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Playlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    layout<T extends Playlist$layoutArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$layoutArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Playlist$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parentItems<T extends Playlist$parentItemsArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$parentItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    screens<T extends Playlist$screensArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$screensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Playlist$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Playlist model
   */
  interface PlaylistFieldRefs {
    readonly id: FieldRef<"Playlist", 'String'>
    readonly workspaceId: FieldRef<"Playlist", 'String'>
    readonly playlistLayoutId: FieldRef<"Playlist", 'String'>
    readonly name: FieldRef<"Playlist", 'String'>
    readonly description: FieldRef<"Playlist", 'String'>
    readonly size: FieldRef<"Playlist", 'BigInt'>
    readonly type: FieldRef<"Playlist", 'String'>
    readonly isPublished: FieldRef<"Playlist", 'Boolean'>
    readonly priority: FieldRef<"Playlist", 'Int'>
    readonly createdAt: FieldRef<"Playlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Playlist", 'DateTime'>
    readonly deletedAt: FieldRef<"Playlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Playlist findUnique
   */
  export type PlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findUniqueOrThrow
   */
  export type PlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findFirst
   */
  export type PlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Playlist findFirstOrThrow
   */
  export type PlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Playlist findMany
   */
  export type PlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlists to fetch.
     */
    where?: PlaylistWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Playlists.
     */
    cursor?: PlaylistWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number | $Types.Skip
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Playlist create
   */
  export type PlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a Playlist.
     */
    data: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
  }

  /**
   * Playlist createMany
   */
  export type PlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * Playlist createManyAndReturn
   */
  export type PlaylistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist update
   */
  export type PlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a Playlist.
     */
    data: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
    /**
     * Choose, which Playlist to update.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist updateMany
   */
  export type PlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput | $Types.Skip
    /**
     * Limit how many Playlists to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Playlist updateManyAndReturn
   */
  export type PlaylistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput | $Types.Skip
    /**
     * Limit how many Playlists to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist upsert
   */
  export type PlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the Playlist to update in case it exists.
     */
    where: PlaylistWhereUniqueInput
    /**
     * In case the Playlist found by the `where` argument doesn't exist, create a new Playlist with this data.
     */
    create: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
    /**
     * In case the Playlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
  }

  /**
   * Playlist delete
   */
  export type PlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter which Playlist to delete.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist deleteMany
   */
  export type PlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlists to delete
     */
    where?: PlaylistWhereInput | $Types.Skip
    /**
     * Limit how many Playlists to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Playlist.layout
   */
  export type Playlist$layoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    where?: PlaylistLayoutWhereInput | $Types.Skip
  }

  /**
   * Playlist.items
   */
  export type Playlist$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    where?: PlaylistItemWhereInput | $Types.Skip
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistItemWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Playlist.parentItems
   */
  export type Playlist$parentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    where?: PlaylistItemWhereInput | $Types.Skip
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistItemWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Playlist.screens
   */
  export type Playlist$screensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    where?: PlaylistScreenWhereInput | $Types.Skip
    orderBy?: PlaylistScreenOrderByWithRelationInput | PlaylistScreenOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistScreenWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistScreenScalarFieldEnum | PlaylistScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Playlist.schedules
   */
  export type Playlist$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    where?: PlaylistScheduleWhereInput | $Types.Skip
    orderBy?: PlaylistScheduleOrderByWithRelationInput | PlaylistScheduleOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistScheduleWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistScheduleScalarFieldEnum | PlaylistScheduleScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Playlist without action
   */
  export type PlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
  }


  /**
   * Model PlaylistItem
   */

  export type AggregatePlaylistItem = {
    _count: PlaylistItemCountAggregateOutputType | null
    _avg: PlaylistItemAvgAggregateOutputType | null
    _sum: PlaylistItemSumAggregateOutputType | null
    _min: PlaylistItemMinAggregateOutputType | null
    _max: PlaylistItemMaxAggregateOutputType | null
  }

  export type PlaylistItemAvgAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type PlaylistItemSumAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type PlaylistItemMinAggregateOutputType = {
    id: string | null
    playlistId: string | null
    type: $Enums.PlaylistItemType | null
    duration: number | null
    playlistLayoutSectionId: string | null
    fileId: string | null
    nestedPlaylistId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaylistItemMaxAggregateOutputType = {
    id: string | null
    playlistId: string | null
    type: $Enums.PlaylistItemType | null
    duration: number | null
    playlistLayoutSectionId: string | null
    fileId: string | null
    nestedPlaylistId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaylistItemCountAggregateOutputType = {
    id: number
    playlistId: number
    type: number
    duration: number
    playlistLayoutSectionId: number
    fileId: number
    nestedPlaylistId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlaylistItemAvgAggregateInputType = {
    duration?: true | $Types.Skip
    order?: true | $Types.Skip
  }

  export type PlaylistItemSumAggregateInputType = {
    duration?: true | $Types.Skip
    order?: true | $Types.Skip
  }

  export type PlaylistItemMinAggregateInputType = {
    id?: true | $Types.Skip
    playlistId?: true | $Types.Skip
    type?: true | $Types.Skip
    duration?: true | $Types.Skip
    playlistLayoutSectionId?: true | $Types.Skip
    fileId?: true | $Types.Skip
    nestedPlaylistId?: true | $Types.Skip
    order?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type PlaylistItemMaxAggregateInputType = {
    id?: true | $Types.Skip
    playlistId?: true | $Types.Skip
    type?: true | $Types.Skip
    duration?: true | $Types.Skip
    playlistLayoutSectionId?: true | $Types.Skip
    fileId?: true | $Types.Skip
    nestedPlaylistId?: true | $Types.Skip
    order?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type PlaylistItemCountAggregateInputType = {
    id?: true | $Types.Skip
    playlistId?: true | $Types.Skip
    type?: true | $Types.Skip
    duration?: true | $Types.Skip
    playlistLayoutSectionId?: true | $Types.Skip
    fileId?: true | $Types.Skip
    nestedPlaylistId?: true | $Types.Skip
    order?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type PlaylistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistItem to aggregate.
     */
    where?: PlaylistItemWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistItems to fetch.
     */
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistItemWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistItems from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistItems.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaylistItems
    **/
    _count?: true | PlaylistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistItemMaxAggregateInputType
  }

  export type GetPlaylistItemAggregateType<T extends PlaylistItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylistItem[P]>
      : GetScalarType<T[P], AggregatePlaylistItem[P]>
  }




  export type PlaylistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistItemWhereInput | $Types.Skip
    orderBy?: PlaylistItemOrderByWithAggregationInput | PlaylistItemOrderByWithAggregationInput[] | $Types.Skip
    by: PlaylistItemScalarFieldEnum[] | PlaylistItemScalarFieldEnum
    having?: PlaylistItemScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: PlaylistItemCountAggregateInputType | true
    _avg?: PlaylistItemAvgAggregateInputType
    _sum?: PlaylistItemSumAggregateInputType
    _min?: PlaylistItemMinAggregateInputType
    _max?: PlaylistItemMaxAggregateInputType
  }

  export type PlaylistItemGroupByOutputType = {
    id: string
    playlistId: string
    type: $Enums.PlaylistItemType
    duration: number | null
    playlistLayoutSectionId: string
    fileId: string | null
    nestedPlaylistId: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: PlaylistItemCountAggregateOutputType | null
    _avg: PlaylistItemAvgAggregateOutputType | null
    _sum: PlaylistItemSumAggregateOutputType | null
    _min: PlaylistItemMinAggregateOutputType | null
    _max: PlaylistItemMaxAggregateOutputType | null
  }

  type GetPlaylistItemGroupByPayload<T extends PlaylistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistItemGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistItemGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistId?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    duration?: boolean | $Types.Skip
    playlistLayoutSectionId?: boolean | $Types.Skip
    fileId?: boolean | $Types.Skip
    nestedPlaylistId?: boolean | $Types.Skip
    order?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    file?: boolean | PlaylistItem$fileArgs<ExtArgs> | $Types.Skip
    nestedPlaylist?: boolean | PlaylistItem$nestedPlaylistArgs<ExtArgs> | $Types.Skip
    playlistLayoutSection?: boolean | PlaylistLayoutSectionDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistItem"]>

  export type PlaylistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistId?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    duration?: boolean | $Types.Skip
    playlistLayoutSectionId?: boolean | $Types.Skip
    fileId?: boolean | $Types.Skip
    nestedPlaylistId?: boolean | $Types.Skip
    order?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    file?: boolean | PlaylistItem$fileArgs<ExtArgs> | $Types.Skip
    nestedPlaylist?: boolean | PlaylistItem$nestedPlaylistArgs<ExtArgs> | $Types.Skip
    playlistLayoutSection?: boolean | PlaylistLayoutSectionDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistItem"]>

  export type PlaylistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistId?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    duration?: boolean | $Types.Skip
    playlistLayoutSectionId?: boolean | $Types.Skip
    fileId?: boolean | $Types.Skip
    nestedPlaylistId?: boolean | $Types.Skip
    order?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    file?: boolean | PlaylistItem$fileArgs<ExtArgs> | $Types.Skip
    nestedPlaylist?: boolean | PlaylistItem$nestedPlaylistArgs<ExtArgs> | $Types.Skip
    playlistLayoutSection?: boolean | PlaylistLayoutSectionDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistItem"]>

  export type PlaylistItemSelectScalar = {
    id?: boolean | $Types.Skip
    playlistId?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    duration?: boolean | $Types.Skip
    playlistLayoutSectionId?: boolean | $Types.Skip
    fileId?: boolean | $Types.Skip
    nestedPlaylistId?: boolean | $Types.Skip
    order?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }

  export type PlaylistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playlistId" | "type" | "duration" | "playlistLayoutSectionId" | "fileId" | "nestedPlaylistId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["playlistItem"], $Types.Skip>
  export type PlaylistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    file?: boolean | PlaylistItem$fileArgs<ExtArgs> | $Types.Skip
    nestedPlaylist?: boolean | PlaylistItem$nestedPlaylistArgs<ExtArgs> | $Types.Skip
    playlistLayoutSection?: boolean | PlaylistLayoutSectionDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    file?: boolean | PlaylistItem$fileArgs<ExtArgs> | $Types.Skip
    nestedPlaylist?: boolean | PlaylistItem$nestedPlaylistArgs<ExtArgs> | $Types.Skip
    playlistLayoutSection?: boolean | PlaylistLayoutSectionDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    file?: boolean | PlaylistItem$fileArgs<ExtArgs> | $Types.Skip
    nestedPlaylist?: boolean | PlaylistItem$nestedPlaylistArgs<ExtArgs> | $Types.Skip
    playlistLayoutSection?: boolean | PlaylistLayoutSectionDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $PlaylistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaylistItem"
    objects: {
      playlist: Prisma.$PlaylistPayload<ExtArgs>
      file: Prisma.$FilePayload<ExtArgs> | null
      nestedPlaylist: Prisma.$PlaylistPayload<ExtArgs> | null
      playlistLayoutSection: Prisma.$PlaylistLayoutSectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playlistId: string
      type: $Enums.PlaylistItemType
      duration: number | null
      playlistLayoutSectionId: string
      fileId: string | null
      nestedPlaylistId: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playlistItem"]>
    composites: {}
  }

  type PlaylistItemGetPayload<S extends boolean | null | undefined | PlaylistItemDefaultArgs> = $Result.GetResult<Prisma.$PlaylistItemPayload, S>

  type PlaylistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistItemCountAggregateInputType | true
    }

  export interface PlaylistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaylistItem'], meta: { name: 'PlaylistItem' } }
    /**
     * Find zero or one PlaylistItem that matches the filter.
     * @param {PlaylistItemFindUniqueArgs} args - Arguments to find a PlaylistItem
     * @example
     * // Get one PlaylistItem
     * const playlistItem = await prisma.playlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistItemFindUniqueArgs>(args: SelectSubset<T, PlaylistItemFindUniqueArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaylistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistItemFindUniqueOrThrowArgs} args - Arguments to find a PlaylistItem
     * @example
     * // Get one PlaylistItem
     * const playlistItem = await prisma.playlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemFindFirstArgs} args - Arguments to find a PlaylistItem
     * @example
     * // Get one PlaylistItem
     * const playlistItem = await prisma.playlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistItemFindFirstArgs>(args?: SelectSubset<T, PlaylistItemFindFirstArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemFindFirstOrThrowArgs} args - Arguments to find a PlaylistItem
     * @example
     * // Get one PlaylistItem
     * const playlistItem = await prisma.playlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaylistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaylistItems
     * const playlistItems = await prisma.playlistItem.findMany()
     * 
     * // Get first 10 PlaylistItems
     * const playlistItems = await prisma.playlistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistItemWithIdOnly = await prisma.playlistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistItemFindManyArgs>(args?: SelectSubset<T, PlaylistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaylistItem.
     * @param {PlaylistItemCreateArgs} args - Arguments to create a PlaylistItem.
     * @example
     * // Create one PlaylistItem
     * const PlaylistItem = await prisma.playlistItem.create({
     *   data: {
     *     // ... data to create a PlaylistItem
     *   }
     * })
     * 
     */
    create<T extends PlaylistItemCreateArgs>(args: SelectSubset<T, PlaylistItemCreateArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaylistItems.
     * @param {PlaylistItemCreateManyArgs} args - Arguments to create many PlaylistItems.
     * @example
     * // Create many PlaylistItems
     * const playlistItem = await prisma.playlistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistItemCreateManyArgs>(args?: SelectSubset<T, PlaylistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaylistItems and returns the data saved in the database.
     * @param {PlaylistItemCreateManyAndReturnArgs} args - Arguments to create many PlaylistItems.
     * @example
     * // Create many PlaylistItems
     * const playlistItem = await prisma.playlistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaylistItems and only return the `id`
     * const playlistItemWithIdOnly = await prisma.playlistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaylistItem.
     * @param {PlaylistItemDeleteArgs} args - Arguments to delete one PlaylistItem.
     * @example
     * // Delete one PlaylistItem
     * const PlaylistItem = await prisma.playlistItem.delete({
     *   where: {
     *     // ... filter to delete one PlaylistItem
     *   }
     * })
     * 
     */
    delete<T extends PlaylistItemDeleteArgs>(args: SelectSubset<T, PlaylistItemDeleteArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaylistItem.
     * @param {PlaylistItemUpdateArgs} args - Arguments to update one PlaylistItem.
     * @example
     * // Update one PlaylistItem
     * const playlistItem = await prisma.playlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistItemUpdateArgs>(args: SelectSubset<T, PlaylistItemUpdateArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaylistItems.
     * @param {PlaylistItemDeleteManyArgs} args - Arguments to filter PlaylistItems to delete.
     * @example
     * // Delete a few PlaylistItems
     * const { count } = await prisma.playlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistItemDeleteManyArgs>(args?: SelectSubset<T, PlaylistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaylistItems
     * const playlistItem = await prisma.playlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistItemUpdateManyArgs>(args: SelectSubset<T, PlaylistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistItems and returns the data updated in the database.
     * @param {PlaylistItemUpdateManyAndReturnArgs} args - Arguments to update many PlaylistItems.
     * @example
     * // Update many PlaylistItems
     * const playlistItem = await prisma.playlistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaylistItems and only return the `id`
     * const playlistItemWithIdOnly = await prisma.playlistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaylistItem.
     * @param {PlaylistItemUpsertArgs} args - Arguments to update or create a PlaylistItem.
     * @example
     * // Update or create a PlaylistItem
     * const playlistItem = await prisma.playlistItem.upsert({
     *   create: {
     *     // ... data to create a PlaylistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaylistItem we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistItemUpsertArgs>(args: SelectSubset<T, PlaylistItemUpsertArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaylistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemCountArgs} args - Arguments to filter PlaylistItems to count.
     * @example
     * // Count the number of PlaylistItems
     * const count = await prisma.playlistItem.count({
     *   where: {
     *     // ... the filter for the PlaylistItems we want to count
     *   }
     * })
    **/
    count<T extends PlaylistItemCountArgs>(
      args?: Subset<T, PlaylistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaylistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistItemAggregateArgs>(args: Subset<T, PlaylistItemAggregateArgs>): Prisma.PrismaPromise<GetPlaylistItemAggregateType<T>>

    /**
     * Group by PlaylistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistItemGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaylistItem model
   */
  readonly fields: PlaylistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaylistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    file<T extends PlaylistItem$fileArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistItem$fileArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nestedPlaylist<T extends PlaylistItem$nestedPlaylistArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistItem$nestedPlaylistArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    playlistLayoutSection<T extends PlaylistLayoutSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistLayoutSectionDefaultArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaylistItem model
   */
  interface PlaylistItemFieldRefs {
    readonly id: FieldRef<"PlaylistItem", 'String'>
    readonly playlistId: FieldRef<"PlaylistItem", 'String'>
    readonly type: FieldRef<"PlaylistItem", 'PlaylistItemType'>
    readonly duration: FieldRef<"PlaylistItem", 'Int'>
    readonly playlistLayoutSectionId: FieldRef<"PlaylistItem", 'String'>
    readonly fileId: FieldRef<"PlaylistItem", 'String'>
    readonly nestedPlaylistId: FieldRef<"PlaylistItem", 'String'>
    readonly order: FieldRef<"PlaylistItem", 'Int'>
    readonly createdAt: FieldRef<"PlaylistItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PlaylistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaylistItem findUnique
   */
  export type PlaylistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItem to fetch.
     */
    where: PlaylistItemWhereUniqueInput
  }

  /**
   * PlaylistItem findUniqueOrThrow
   */
  export type PlaylistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItem to fetch.
     */
    where: PlaylistItemWhereUniqueInput
  }

  /**
   * PlaylistItem findFirst
   */
  export type PlaylistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItem to fetch.
     */
    where?: PlaylistItemWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistItems to fetch.
     */
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistItems.
     */
    cursor?: PlaylistItemWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistItems from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistItems.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistItems.
     */
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistItem findFirstOrThrow
   */
  export type PlaylistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItem to fetch.
     */
    where?: PlaylistItemWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistItems to fetch.
     */
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistItems.
     */
    cursor?: PlaylistItemWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistItems from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistItems.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistItems.
     */
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistItem findMany
   */
  export type PlaylistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItems to fetch.
     */
    where?: PlaylistItemWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistItems to fetch.
     */
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaylistItems.
     */
    cursor?: PlaylistItemWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistItems from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistItems.
     */
    skip?: number | $Types.Skip
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistItem create
   */
  export type PlaylistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaylistItem.
     */
    data: XOR<PlaylistItemCreateInput, PlaylistItemUncheckedCreateInput>
  }

  /**
   * PlaylistItem createMany
   */
  export type PlaylistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaylistItems.
     */
    data: PlaylistItemCreateManyInput | PlaylistItemCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * PlaylistItem createManyAndReturn
   */
  export type PlaylistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * The data used to create many PlaylistItems.
     */
    data: PlaylistItemCreateManyInput | PlaylistItemCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistItem update
   */
  export type PlaylistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaylistItem.
     */
    data: XOR<PlaylistItemUpdateInput, PlaylistItemUncheckedUpdateInput>
    /**
     * Choose, which PlaylistItem to update.
     */
    where: PlaylistItemWhereUniqueInput
  }

  /**
   * PlaylistItem updateMany
   */
  export type PlaylistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaylistItems.
     */
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistItems to update
     */
    where?: PlaylistItemWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistItems to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistItem updateManyAndReturn
   */
  export type PlaylistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * The data used to update PlaylistItems.
     */
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistItems to update
     */
    where?: PlaylistItemWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistItems to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistItem upsert
   */
  export type PlaylistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaylistItem to update in case it exists.
     */
    where: PlaylistItemWhereUniqueInput
    /**
     * In case the PlaylistItem found by the `where` argument doesn't exist, create a new PlaylistItem with this data.
     */
    create: XOR<PlaylistItemCreateInput, PlaylistItemUncheckedCreateInput>
    /**
     * In case the PlaylistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistItemUpdateInput, PlaylistItemUncheckedUpdateInput>
  }

  /**
   * PlaylistItem delete
   */
  export type PlaylistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter which PlaylistItem to delete.
     */
    where: PlaylistItemWhereUniqueInput
  }

  /**
   * PlaylistItem deleteMany
   */
  export type PlaylistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistItems to delete
     */
    where?: PlaylistItemWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistItems to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistItem.file
   */
  export type PlaylistItem$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput | $Types.Skip
  }

  /**
   * PlaylistItem.nestedPlaylist
   */
  export type PlaylistItem$nestedPlaylistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput | $Types.Skip
  }

  /**
   * PlaylistItem without action
   */
  export type PlaylistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
  }


  /**
   * Model PlaylistLayout
   */

  export type AggregatePlaylistLayout = {
    _count: PlaylistLayoutCountAggregateOutputType | null
    _avg: PlaylistLayoutAvgAggregateOutputType | null
    _sum: PlaylistLayoutSumAggregateOutputType | null
    _min: PlaylistLayoutMinAggregateOutputType | null
    _max: PlaylistLayoutMaxAggregateOutputType | null
  }

  export type PlaylistLayoutAvgAggregateOutputType = {
    resolutionWidth: number | null
    resolutionHeight: number | null
  }

  export type PlaylistLayoutSumAggregateOutputType = {
    resolutionWidth: number | null
    resolutionHeight: number | null
  }

  export type PlaylistLayoutMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    resolutionWidth: number | null
    resolutionHeight: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaylistLayoutMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    resolutionWidth: number | null
    resolutionHeight: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaylistLayoutCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    resolutionWidth: number
    resolutionHeight: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlaylistLayoutAvgAggregateInputType = {
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
  }

  export type PlaylistLayoutSumAggregateInputType = {
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
  }

  export type PlaylistLayoutMinAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    name?: true | $Types.Skip
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type PlaylistLayoutMaxAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    name?: true | $Types.Skip
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type PlaylistLayoutCountAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    name?: true | $Types.Skip
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type PlaylistLayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistLayout to aggregate.
     */
    where?: PlaylistLayoutWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistLayouts to fetch.
     */
    orderBy?: PlaylistLayoutOrderByWithRelationInput | PlaylistLayoutOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistLayoutWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistLayouts from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistLayouts.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaylistLayouts
    **/
    _count?: true | PlaylistLayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistLayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistLayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistLayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistLayoutMaxAggregateInputType
  }

  export type GetPlaylistLayoutAggregateType<T extends PlaylistLayoutAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylistLayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylistLayout[P]>
      : GetScalarType<T[P], AggregatePlaylistLayout[P]>
  }




  export type PlaylistLayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistLayoutWhereInput | $Types.Skip
    orderBy?: PlaylistLayoutOrderByWithAggregationInput | PlaylistLayoutOrderByWithAggregationInput[] | $Types.Skip
    by: PlaylistLayoutScalarFieldEnum[] | PlaylistLayoutScalarFieldEnum
    having?: PlaylistLayoutScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: PlaylistLayoutCountAggregateInputType | true
    _avg?: PlaylistLayoutAvgAggregateInputType
    _sum?: PlaylistLayoutSumAggregateInputType
    _min?: PlaylistLayoutMinAggregateInputType
    _max?: PlaylistLayoutMaxAggregateInputType
  }

  export type PlaylistLayoutGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt: Date
    updatedAt: Date
    _count: PlaylistLayoutCountAggregateOutputType | null
    _avg: PlaylistLayoutAvgAggregateOutputType | null
    _sum: PlaylistLayoutSumAggregateOutputType | null
    _min: PlaylistLayoutMinAggregateOutputType | null
    _max: PlaylistLayoutMaxAggregateOutputType | null
  }

  type GetPlaylistLayoutGroupByPayload<T extends PlaylistLayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistLayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistLayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistLayoutGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistLayoutGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistLayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    resolutionWidth?: boolean | $Types.Skip
    resolutionHeight?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    playlists?: boolean | PlaylistLayout$playlistsArgs<ExtArgs> | $Types.Skip
    sections?: boolean | PlaylistLayout$sectionsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | PlaylistLayoutCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistLayout"]>

  export type PlaylistLayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    resolutionWidth?: boolean | $Types.Skip
    resolutionHeight?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistLayout"]>

  export type PlaylistLayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    resolutionWidth?: boolean | $Types.Skip
    resolutionHeight?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistLayout"]>

  export type PlaylistLayoutSelectScalar = {
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    resolutionWidth?: boolean | $Types.Skip
    resolutionHeight?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }

  export type PlaylistLayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "resolutionWidth" | "resolutionHeight" | "createdAt" | "updatedAt", ExtArgs["result"]["playlistLayout"], $Types.Skip>
  export type PlaylistLayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    playlists?: boolean | PlaylistLayout$playlistsArgs<ExtArgs> | $Types.Skip
    sections?: boolean | PlaylistLayout$sectionsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | PlaylistLayoutCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistLayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistLayoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $PlaylistLayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaylistLayout"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      playlists: Prisma.$PlaylistPayload<ExtArgs>[]
      sections: Prisma.$PlaylistLayoutSectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      resolutionWidth: number
      resolutionHeight: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playlistLayout"]>
    composites: {}
  }

  type PlaylistLayoutGetPayload<S extends boolean | null | undefined | PlaylistLayoutDefaultArgs> = $Result.GetResult<Prisma.$PlaylistLayoutPayload, S>

  type PlaylistLayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistLayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistLayoutCountAggregateInputType | true
    }

  export interface PlaylistLayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaylistLayout'], meta: { name: 'PlaylistLayout' } }
    /**
     * Find zero or one PlaylistLayout that matches the filter.
     * @param {PlaylistLayoutFindUniqueArgs} args - Arguments to find a PlaylistLayout
     * @example
     * // Get one PlaylistLayout
     * const playlistLayout = await prisma.playlistLayout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistLayoutFindUniqueArgs>(args: SelectSubset<T, PlaylistLayoutFindUniqueArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaylistLayout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistLayoutFindUniqueOrThrowArgs} args - Arguments to find a PlaylistLayout
     * @example
     * // Get one PlaylistLayout
     * const playlistLayout = await prisma.playlistLayout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistLayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistLayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistLayout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutFindFirstArgs} args - Arguments to find a PlaylistLayout
     * @example
     * // Get one PlaylistLayout
     * const playlistLayout = await prisma.playlistLayout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistLayoutFindFirstArgs>(args?: SelectSubset<T, PlaylistLayoutFindFirstArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistLayout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutFindFirstOrThrowArgs} args - Arguments to find a PlaylistLayout
     * @example
     * // Get one PlaylistLayout
     * const playlistLayout = await prisma.playlistLayout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistLayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistLayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaylistLayouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaylistLayouts
     * const playlistLayouts = await prisma.playlistLayout.findMany()
     * 
     * // Get first 10 PlaylistLayouts
     * const playlistLayouts = await prisma.playlistLayout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistLayoutWithIdOnly = await prisma.playlistLayout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistLayoutFindManyArgs>(args?: SelectSubset<T, PlaylistLayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaylistLayout.
     * @param {PlaylistLayoutCreateArgs} args - Arguments to create a PlaylistLayout.
     * @example
     * // Create one PlaylistLayout
     * const PlaylistLayout = await prisma.playlistLayout.create({
     *   data: {
     *     // ... data to create a PlaylistLayout
     *   }
     * })
     * 
     */
    create<T extends PlaylistLayoutCreateArgs>(args: SelectSubset<T, PlaylistLayoutCreateArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaylistLayouts.
     * @param {PlaylistLayoutCreateManyArgs} args - Arguments to create many PlaylistLayouts.
     * @example
     * // Create many PlaylistLayouts
     * const playlistLayout = await prisma.playlistLayout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistLayoutCreateManyArgs>(args?: SelectSubset<T, PlaylistLayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaylistLayouts and returns the data saved in the database.
     * @param {PlaylistLayoutCreateManyAndReturnArgs} args - Arguments to create many PlaylistLayouts.
     * @example
     * // Create many PlaylistLayouts
     * const playlistLayout = await prisma.playlistLayout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaylistLayouts and only return the `id`
     * const playlistLayoutWithIdOnly = await prisma.playlistLayout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistLayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistLayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaylistLayout.
     * @param {PlaylistLayoutDeleteArgs} args - Arguments to delete one PlaylistLayout.
     * @example
     * // Delete one PlaylistLayout
     * const PlaylistLayout = await prisma.playlistLayout.delete({
     *   where: {
     *     // ... filter to delete one PlaylistLayout
     *   }
     * })
     * 
     */
    delete<T extends PlaylistLayoutDeleteArgs>(args: SelectSubset<T, PlaylistLayoutDeleteArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaylistLayout.
     * @param {PlaylistLayoutUpdateArgs} args - Arguments to update one PlaylistLayout.
     * @example
     * // Update one PlaylistLayout
     * const playlistLayout = await prisma.playlistLayout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistLayoutUpdateArgs>(args: SelectSubset<T, PlaylistLayoutUpdateArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaylistLayouts.
     * @param {PlaylistLayoutDeleteManyArgs} args - Arguments to filter PlaylistLayouts to delete.
     * @example
     * // Delete a few PlaylistLayouts
     * const { count } = await prisma.playlistLayout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistLayoutDeleteManyArgs>(args?: SelectSubset<T, PlaylistLayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistLayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaylistLayouts
     * const playlistLayout = await prisma.playlistLayout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistLayoutUpdateManyArgs>(args: SelectSubset<T, PlaylistLayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistLayouts and returns the data updated in the database.
     * @param {PlaylistLayoutUpdateManyAndReturnArgs} args - Arguments to update many PlaylistLayouts.
     * @example
     * // Update many PlaylistLayouts
     * const playlistLayout = await prisma.playlistLayout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaylistLayouts and only return the `id`
     * const playlistLayoutWithIdOnly = await prisma.playlistLayout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistLayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistLayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaylistLayout.
     * @param {PlaylistLayoutUpsertArgs} args - Arguments to update or create a PlaylistLayout.
     * @example
     * // Update or create a PlaylistLayout
     * const playlistLayout = await prisma.playlistLayout.upsert({
     *   create: {
     *     // ... data to create a PlaylistLayout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaylistLayout we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistLayoutUpsertArgs>(args: SelectSubset<T, PlaylistLayoutUpsertArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaylistLayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutCountArgs} args - Arguments to filter PlaylistLayouts to count.
     * @example
     * // Count the number of PlaylistLayouts
     * const count = await prisma.playlistLayout.count({
     *   where: {
     *     // ... the filter for the PlaylistLayouts we want to count
     *   }
     * })
    **/
    count<T extends PlaylistLayoutCountArgs>(
      args?: Subset<T, PlaylistLayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistLayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaylistLayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistLayoutAggregateArgs>(args: Subset<T, PlaylistLayoutAggregateArgs>): Prisma.PrismaPromise<GetPlaylistLayoutAggregateType<T>>

    /**
     * Group by PlaylistLayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistLayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistLayoutGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistLayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistLayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistLayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaylistLayout model
   */
  readonly fields: PlaylistLayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaylistLayout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistLayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    playlists<T extends PlaylistLayout$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistLayout$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sections<T extends PlaylistLayout$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistLayout$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaylistLayout model
   */
  interface PlaylistLayoutFieldRefs {
    readonly id: FieldRef<"PlaylistLayout", 'String'>
    readonly workspaceId: FieldRef<"PlaylistLayout", 'String'>
    readonly name: FieldRef<"PlaylistLayout", 'String'>
    readonly resolutionWidth: FieldRef<"PlaylistLayout", 'Int'>
    readonly resolutionHeight: FieldRef<"PlaylistLayout", 'Int'>
    readonly createdAt: FieldRef<"PlaylistLayout", 'DateTime'>
    readonly updatedAt: FieldRef<"PlaylistLayout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaylistLayout findUnique
   */
  export type PlaylistLayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayout to fetch.
     */
    where: PlaylistLayoutWhereUniqueInput
  }

  /**
   * PlaylistLayout findUniqueOrThrow
   */
  export type PlaylistLayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayout to fetch.
     */
    where: PlaylistLayoutWhereUniqueInput
  }

  /**
   * PlaylistLayout findFirst
   */
  export type PlaylistLayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayout to fetch.
     */
    where?: PlaylistLayoutWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistLayouts to fetch.
     */
    orderBy?: PlaylistLayoutOrderByWithRelationInput | PlaylistLayoutOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistLayouts.
     */
    cursor?: PlaylistLayoutWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistLayouts from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistLayouts.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistLayouts.
     */
    distinct?: PlaylistLayoutScalarFieldEnum | PlaylistLayoutScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayout findFirstOrThrow
   */
  export type PlaylistLayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayout to fetch.
     */
    where?: PlaylistLayoutWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistLayouts to fetch.
     */
    orderBy?: PlaylistLayoutOrderByWithRelationInput | PlaylistLayoutOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistLayouts.
     */
    cursor?: PlaylistLayoutWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistLayouts from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistLayouts.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistLayouts.
     */
    distinct?: PlaylistLayoutScalarFieldEnum | PlaylistLayoutScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayout findMany
   */
  export type PlaylistLayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayouts to fetch.
     */
    where?: PlaylistLayoutWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistLayouts to fetch.
     */
    orderBy?: PlaylistLayoutOrderByWithRelationInput | PlaylistLayoutOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaylistLayouts.
     */
    cursor?: PlaylistLayoutWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistLayouts from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistLayouts.
     */
    skip?: number | $Types.Skip
    distinct?: PlaylistLayoutScalarFieldEnum | PlaylistLayoutScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayout create
   */
  export type PlaylistLayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaylistLayout.
     */
    data: XOR<PlaylistLayoutCreateInput, PlaylistLayoutUncheckedCreateInput>
  }

  /**
   * PlaylistLayout createMany
   */
  export type PlaylistLayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaylistLayouts.
     */
    data: PlaylistLayoutCreateManyInput | PlaylistLayoutCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * PlaylistLayout createManyAndReturn
   */
  export type PlaylistLayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * The data used to create many PlaylistLayouts.
     */
    data: PlaylistLayoutCreateManyInput | PlaylistLayoutCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistLayout update
   */
  export type PlaylistLayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaylistLayout.
     */
    data: XOR<PlaylistLayoutUpdateInput, PlaylistLayoutUncheckedUpdateInput>
    /**
     * Choose, which PlaylistLayout to update.
     */
    where: PlaylistLayoutWhereUniqueInput
  }

  /**
   * PlaylistLayout updateMany
   */
  export type PlaylistLayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaylistLayouts.
     */
    data: XOR<PlaylistLayoutUpdateManyMutationInput, PlaylistLayoutUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistLayouts to update
     */
    where?: PlaylistLayoutWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistLayouts to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistLayout updateManyAndReturn
   */
  export type PlaylistLayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * The data used to update PlaylistLayouts.
     */
    data: XOR<PlaylistLayoutUpdateManyMutationInput, PlaylistLayoutUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistLayouts to update
     */
    where?: PlaylistLayoutWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistLayouts to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistLayout upsert
   */
  export type PlaylistLayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaylistLayout to update in case it exists.
     */
    where: PlaylistLayoutWhereUniqueInput
    /**
     * In case the PlaylistLayout found by the `where` argument doesn't exist, create a new PlaylistLayout with this data.
     */
    create: XOR<PlaylistLayoutCreateInput, PlaylistLayoutUncheckedCreateInput>
    /**
     * In case the PlaylistLayout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistLayoutUpdateInput, PlaylistLayoutUncheckedUpdateInput>
  }

  /**
   * PlaylistLayout delete
   */
  export type PlaylistLayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    /**
     * Filter which PlaylistLayout to delete.
     */
    where: PlaylistLayoutWhereUniqueInput
  }

  /**
   * PlaylistLayout deleteMany
   */
  export type PlaylistLayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistLayouts to delete
     */
    where?: PlaylistLayoutWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistLayouts to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistLayout.playlists
   */
  export type PlaylistLayout$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput | $Types.Skip
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayout.sections
   */
  export type PlaylistLayout$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    orderBy?: PlaylistLayoutSectionOrderByWithRelationInput | PlaylistLayoutSectionOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistLayoutSectionWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistLayoutSectionScalarFieldEnum | PlaylistLayoutSectionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayout without action
   */
  export type PlaylistLayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
  }


  /**
   * Model PlaylistLayoutSection
   */

  export type AggregatePlaylistLayoutSection = {
    _count: PlaylistLayoutSectionCountAggregateOutputType | null
    _avg: PlaylistLayoutSectionAvgAggregateOutputType | null
    _sum: PlaylistLayoutSectionSumAggregateOutputType | null
    _min: PlaylistLayoutSectionMinAggregateOutputType | null
    _max: PlaylistLayoutSectionMaxAggregateOutputType | null
  }

  export type PlaylistLayoutSectionAvgAggregateOutputType = {
    top: number | null
    left: number | null
    width: number | null
    height: number | null
    zIndex: number | null
  }

  export type PlaylistLayoutSectionSumAggregateOutputType = {
    top: number | null
    left: number | null
    width: number | null
    height: number | null
    zIndex: number | null
  }

  export type PlaylistLayoutSectionMinAggregateOutputType = {
    id: string | null
    playlistLayoutId: string | null
    name: string | null
    top: number | null
    left: number | null
    width: number | null
    height: number | null
    zIndex: number | null
  }

  export type PlaylistLayoutSectionMaxAggregateOutputType = {
    id: string | null
    playlistLayoutId: string | null
    name: string | null
    top: number | null
    left: number | null
    width: number | null
    height: number | null
    zIndex: number | null
  }

  export type PlaylistLayoutSectionCountAggregateOutputType = {
    id: number
    playlistLayoutId: number
    name: number
    top: number
    left: number
    width: number
    height: number
    zIndex: number
    _all: number
  }


  export type PlaylistLayoutSectionAvgAggregateInputType = {
    top?: true | $Types.Skip
    left?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    zIndex?: true | $Types.Skip
  }

  export type PlaylistLayoutSectionSumAggregateInputType = {
    top?: true | $Types.Skip
    left?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    zIndex?: true | $Types.Skip
  }

  export type PlaylistLayoutSectionMinAggregateInputType = {
    id?: true | $Types.Skip
    playlistLayoutId?: true | $Types.Skip
    name?: true | $Types.Skip
    top?: true | $Types.Skip
    left?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    zIndex?: true | $Types.Skip
  }

  export type PlaylistLayoutSectionMaxAggregateInputType = {
    id?: true | $Types.Skip
    playlistLayoutId?: true | $Types.Skip
    name?: true | $Types.Skip
    top?: true | $Types.Skip
    left?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    zIndex?: true | $Types.Skip
  }

  export type PlaylistLayoutSectionCountAggregateInputType = {
    id?: true | $Types.Skip
    playlistLayoutId?: true | $Types.Skip
    name?: true | $Types.Skip
    top?: true | $Types.Skip
    left?: true | $Types.Skip
    width?: true | $Types.Skip
    height?: true | $Types.Skip
    zIndex?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type PlaylistLayoutSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistLayoutSection to aggregate.
     */
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistLayoutSections to fetch.
     */
    orderBy?: PlaylistLayoutSectionOrderByWithRelationInput | PlaylistLayoutSectionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistLayoutSectionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistLayoutSections from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistLayoutSections.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaylistLayoutSections
    **/
    _count?: true | PlaylistLayoutSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistLayoutSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistLayoutSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistLayoutSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistLayoutSectionMaxAggregateInputType
  }

  export type GetPlaylistLayoutSectionAggregateType<T extends PlaylistLayoutSectionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylistLayoutSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylistLayoutSection[P]>
      : GetScalarType<T[P], AggregatePlaylistLayoutSection[P]>
  }




  export type PlaylistLayoutSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    orderBy?: PlaylistLayoutSectionOrderByWithAggregationInput | PlaylistLayoutSectionOrderByWithAggregationInput[] | $Types.Skip
    by: PlaylistLayoutSectionScalarFieldEnum[] | PlaylistLayoutSectionScalarFieldEnum
    having?: PlaylistLayoutSectionScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: PlaylistLayoutSectionCountAggregateInputType | true
    _avg?: PlaylistLayoutSectionAvgAggregateInputType
    _sum?: PlaylistLayoutSectionSumAggregateInputType
    _min?: PlaylistLayoutSectionMinAggregateInputType
    _max?: PlaylistLayoutSectionMaxAggregateInputType
  }

  export type PlaylistLayoutSectionGroupByOutputType = {
    id: string
    playlistLayoutId: string
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
    _count: PlaylistLayoutSectionCountAggregateOutputType | null
    _avg: PlaylistLayoutSectionAvgAggregateOutputType | null
    _sum: PlaylistLayoutSectionSumAggregateOutputType | null
    _min: PlaylistLayoutSectionMinAggregateOutputType | null
    _max: PlaylistLayoutSectionMaxAggregateOutputType | null
  }

  type GetPlaylistLayoutSectionGroupByPayload<T extends PlaylistLayoutSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistLayoutSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistLayoutSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistLayoutSectionGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistLayoutSectionGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistLayoutSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistLayoutId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    top?: boolean | $Types.Skip
    left?: boolean | $Types.Skip
    width?: boolean | $Types.Skip
    height?: boolean | $Types.Skip
    zIndex?: boolean | $Types.Skip
    playlistLayout?: boolean | PlaylistLayoutDefaultArgs<ExtArgs> | $Types.Skip
    playlistItems?: boolean | PlaylistLayoutSection$playlistItemsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | PlaylistLayoutSectionCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistLayoutSection"]>

  export type PlaylistLayoutSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistLayoutId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    top?: boolean | $Types.Skip
    left?: boolean | $Types.Skip
    width?: boolean | $Types.Skip
    height?: boolean | $Types.Skip
    zIndex?: boolean | $Types.Skip
    playlistLayout?: boolean | PlaylistLayoutDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistLayoutSection"]>

  export type PlaylistLayoutSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistLayoutId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    top?: boolean | $Types.Skip
    left?: boolean | $Types.Skip
    width?: boolean | $Types.Skip
    height?: boolean | $Types.Skip
    zIndex?: boolean | $Types.Skip
    playlistLayout?: boolean | PlaylistLayoutDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistLayoutSection"]>

  export type PlaylistLayoutSectionSelectScalar = {
    id?: boolean | $Types.Skip
    playlistLayoutId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    top?: boolean | $Types.Skip
    left?: boolean | $Types.Skip
    width?: boolean | $Types.Skip
    height?: boolean | $Types.Skip
    zIndex?: boolean | $Types.Skip
  }

  export type PlaylistLayoutSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playlistLayoutId" | "name" | "top" | "left" | "width" | "height" | "zIndex", ExtArgs["result"]["playlistLayoutSection"], $Types.Skip>
  export type PlaylistLayoutSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlistLayout?: boolean | PlaylistLayoutDefaultArgs<ExtArgs> | $Types.Skip
    playlistItems?: boolean | PlaylistLayoutSection$playlistItemsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | PlaylistLayoutSectionCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistLayoutSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlistLayout?: boolean | PlaylistLayoutDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistLayoutSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlistLayout?: boolean | PlaylistLayoutDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $PlaylistLayoutSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaylistLayoutSection"
    objects: {
      playlistLayout: Prisma.$PlaylistLayoutPayload<ExtArgs>
      playlistItems: Prisma.$PlaylistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playlistLayoutId: string
      name: string
      top: number
      left: number
      width: number
      height: number
      zIndex: number
    }, ExtArgs["result"]["playlistLayoutSection"]>
    composites: {}
  }

  type PlaylistLayoutSectionGetPayload<S extends boolean | null | undefined | PlaylistLayoutSectionDefaultArgs> = $Result.GetResult<Prisma.$PlaylistLayoutSectionPayload, S>

  type PlaylistLayoutSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistLayoutSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistLayoutSectionCountAggregateInputType | true
    }

  export interface PlaylistLayoutSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaylistLayoutSection'], meta: { name: 'PlaylistLayoutSection' } }
    /**
     * Find zero or one PlaylistLayoutSection that matches the filter.
     * @param {PlaylistLayoutSectionFindUniqueArgs} args - Arguments to find a PlaylistLayoutSection
     * @example
     * // Get one PlaylistLayoutSection
     * const playlistLayoutSection = await prisma.playlistLayoutSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistLayoutSectionFindUniqueArgs>(args: SelectSubset<T, PlaylistLayoutSectionFindUniqueArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaylistLayoutSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistLayoutSectionFindUniqueOrThrowArgs} args - Arguments to find a PlaylistLayoutSection
     * @example
     * // Get one PlaylistLayoutSection
     * const playlistLayoutSection = await prisma.playlistLayoutSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistLayoutSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistLayoutSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistLayoutSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutSectionFindFirstArgs} args - Arguments to find a PlaylistLayoutSection
     * @example
     * // Get one PlaylistLayoutSection
     * const playlistLayoutSection = await prisma.playlistLayoutSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistLayoutSectionFindFirstArgs>(args?: SelectSubset<T, PlaylistLayoutSectionFindFirstArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistLayoutSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutSectionFindFirstOrThrowArgs} args - Arguments to find a PlaylistLayoutSection
     * @example
     * // Get one PlaylistLayoutSection
     * const playlistLayoutSection = await prisma.playlistLayoutSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistLayoutSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistLayoutSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaylistLayoutSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaylistLayoutSections
     * const playlistLayoutSections = await prisma.playlistLayoutSection.findMany()
     * 
     * // Get first 10 PlaylistLayoutSections
     * const playlistLayoutSections = await prisma.playlistLayoutSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistLayoutSectionWithIdOnly = await prisma.playlistLayoutSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistLayoutSectionFindManyArgs>(args?: SelectSubset<T, PlaylistLayoutSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaylistLayoutSection.
     * @param {PlaylistLayoutSectionCreateArgs} args - Arguments to create a PlaylistLayoutSection.
     * @example
     * // Create one PlaylistLayoutSection
     * const PlaylistLayoutSection = await prisma.playlistLayoutSection.create({
     *   data: {
     *     // ... data to create a PlaylistLayoutSection
     *   }
     * })
     * 
     */
    create<T extends PlaylistLayoutSectionCreateArgs>(args: SelectSubset<T, PlaylistLayoutSectionCreateArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaylistLayoutSections.
     * @param {PlaylistLayoutSectionCreateManyArgs} args - Arguments to create many PlaylistLayoutSections.
     * @example
     * // Create many PlaylistLayoutSections
     * const playlistLayoutSection = await prisma.playlistLayoutSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistLayoutSectionCreateManyArgs>(args?: SelectSubset<T, PlaylistLayoutSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaylistLayoutSections and returns the data saved in the database.
     * @param {PlaylistLayoutSectionCreateManyAndReturnArgs} args - Arguments to create many PlaylistLayoutSections.
     * @example
     * // Create many PlaylistLayoutSections
     * const playlistLayoutSection = await prisma.playlistLayoutSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaylistLayoutSections and only return the `id`
     * const playlistLayoutSectionWithIdOnly = await prisma.playlistLayoutSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistLayoutSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistLayoutSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaylistLayoutSection.
     * @param {PlaylistLayoutSectionDeleteArgs} args - Arguments to delete one PlaylistLayoutSection.
     * @example
     * // Delete one PlaylistLayoutSection
     * const PlaylistLayoutSection = await prisma.playlistLayoutSection.delete({
     *   where: {
     *     // ... filter to delete one PlaylistLayoutSection
     *   }
     * })
     * 
     */
    delete<T extends PlaylistLayoutSectionDeleteArgs>(args: SelectSubset<T, PlaylistLayoutSectionDeleteArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaylistLayoutSection.
     * @param {PlaylistLayoutSectionUpdateArgs} args - Arguments to update one PlaylistLayoutSection.
     * @example
     * // Update one PlaylistLayoutSection
     * const playlistLayoutSection = await prisma.playlistLayoutSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistLayoutSectionUpdateArgs>(args: SelectSubset<T, PlaylistLayoutSectionUpdateArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaylistLayoutSections.
     * @param {PlaylistLayoutSectionDeleteManyArgs} args - Arguments to filter PlaylistLayoutSections to delete.
     * @example
     * // Delete a few PlaylistLayoutSections
     * const { count } = await prisma.playlistLayoutSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistLayoutSectionDeleteManyArgs>(args?: SelectSubset<T, PlaylistLayoutSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistLayoutSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaylistLayoutSections
     * const playlistLayoutSection = await prisma.playlistLayoutSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistLayoutSectionUpdateManyArgs>(args: SelectSubset<T, PlaylistLayoutSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistLayoutSections and returns the data updated in the database.
     * @param {PlaylistLayoutSectionUpdateManyAndReturnArgs} args - Arguments to update many PlaylistLayoutSections.
     * @example
     * // Update many PlaylistLayoutSections
     * const playlistLayoutSection = await prisma.playlistLayoutSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaylistLayoutSections and only return the `id`
     * const playlistLayoutSectionWithIdOnly = await prisma.playlistLayoutSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistLayoutSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistLayoutSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaylistLayoutSection.
     * @param {PlaylistLayoutSectionUpsertArgs} args - Arguments to update or create a PlaylistLayoutSection.
     * @example
     * // Update or create a PlaylistLayoutSection
     * const playlistLayoutSection = await prisma.playlistLayoutSection.upsert({
     *   create: {
     *     // ... data to create a PlaylistLayoutSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaylistLayoutSection we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistLayoutSectionUpsertArgs>(args: SelectSubset<T, PlaylistLayoutSectionUpsertArgs<ExtArgs>>): Prisma__PlaylistLayoutSectionClient<$Result.GetResult<Prisma.$PlaylistLayoutSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaylistLayoutSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutSectionCountArgs} args - Arguments to filter PlaylistLayoutSections to count.
     * @example
     * // Count the number of PlaylistLayoutSections
     * const count = await prisma.playlistLayoutSection.count({
     *   where: {
     *     // ... the filter for the PlaylistLayoutSections we want to count
     *   }
     * })
    **/
    count<T extends PlaylistLayoutSectionCountArgs>(
      args?: Subset<T, PlaylistLayoutSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistLayoutSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaylistLayoutSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistLayoutSectionAggregateArgs>(args: Subset<T, PlaylistLayoutSectionAggregateArgs>): Prisma.PrismaPromise<GetPlaylistLayoutSectionAggregateType<T>>

    /**
     * Group by PlaylistLayoutSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistLayoutSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistLayoutSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistLayoutSectionGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistLayoutSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistLayoutSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistLayoutSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaylistLayoutSection model
   */
  readonly fields: PlaylistLayoutSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaylistLayoutSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistLayoutSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlistLayout<T extends PlaylistLayoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistLayoutDefaultArgs<ExtArgs>>): Prisma__PlaylistLayoutClient<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    playlistItems<T extends PlaylistLayoutSection$playlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistLayoutSection$playlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaylistLayoutSection model
   */
  interface PlaylistLayoutSectionFieldRefs {
    readonly id: FieldRef<"PlaylistLayoutSection", 'String'>
    readonly playlistLayoutId: FieldRef<"PlaylistLayoutSection", 'String'>
    readonly name: FieldRef<"PlaylistLayoutSection", 'String'>
    readonly top: FieldRef<"PlaylistLayoutSection", 'Int'>
    readonly left: FieldRef<"PlaylistLayoutSection", 'Int'>
    readonly width: FieldRef<"PlaylistLayoutSection", 'Int'>
    readonly height: FieldRef<"PlaylistLayoutSection", 'Int'>
    readonly zIndex: FieldRef<"PlaylistLayoutSection", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlaylistLayoutSection findUnique
   */
  export type PlaylistLayoutSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayoutSection to fetch.
     */
    where: PlaylistLayoutSectionWhereUniqueInput
  }

  /**
   * PlaylistLayoutSection findUniqueOrThrow
   */
  export type PlaylistLayoutSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayoutSection to fetch.
     */
    where: PlaylistLayoutSectionWhereUniqueInput
  }

  /**
   * PlaylistLayoutSection findFirst
   */
  export type PlaylistLayoutSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayoutSection to fetch.
     */
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistLayoutSections to fetch.
     */
    orderBy?: PlaylistLayoutSectionOrderByWithRelationInput | PlaylistLayoutSectionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistLayoutSections.
     */
    cursor?: PlaylistLayoutSectionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistLayoutSections from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistLayoutSections.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistLayoutSections.
     */
    distinct?: PlaylistLayoutSectionScalarFieldEnum | PlaylistLayoutSectionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayoutSection findFirstOrThrow
   */
  export type PlaylistLayoutSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayoutSection to fetch.
     */
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistLayoutSections to fetch.
     */
    orderBy?: PlaylistLayoutSectionOrderByWithRelationInput | PlaylistLayoutSectionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistLayoutSections.
     */
    cursor?: PlaylistLayoutSectionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistLayoutSections from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistLayoutSections.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistLayoutSections.
     */
    distinct?: PlaylistLayoutSectionScalarFieldEnum | PlaylistLayoutSectionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayoutSection findMany
   */
  export type PlaylistLayoutSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistLayoutSections to fetch.
     */
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistLayoutSections to fetch.
     */
    orderBy?: PlaylistLayoutSectionOrderByWithRelationInput | PlaylistLayoutSectionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaylistLayoutSections.
     */
    cursor?: PlaylistLayoutSectionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistLayoutSections from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistLayoutSections.
     */
    skip?: number | $Types.Skip
    distinct?: PlaylistLayoutSectionScalarFieldEnum | PlaylistLayoutSectionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayoutSection create
   */
  export type PlaylistLayoutSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaylistLayoutSection.
     */
    data: XOR<PlaylistLayoutSectionCreateInput, PlaylistLayoutSectionUncheckedCreateInput>
  }

  /**
   * PlaylistLayoutSection createMany
   */
  export type PlaylistLayoutSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaylistLayoutSections.
     */
    data: PlaylistLayoutSectionCreateManyInput | PlaylistLayoutSectionCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * PlaylistLayoutSection createManyAndReturn
   */
  export type PlaylistLayoutSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * The data used to create many PlaylistLayoutSections.
     */
    data: PlaylistLayoutSectionCreateManyInput | PlaylistLayoutSectionCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistLayoutSection update
   */
  export type PlaylistLayoutSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaylistLayoutSection.
     */
    data: XOR<PlaylistLayoutSectionUpdateInput, PlaylistLayoutSectionUncheckedUpdateInput>
    /**
     * Choose, which PlaylistLayoutSection to update.
     */
    where: PlaylistLayoutSectionWhereUniqueInput
  }

  /**
   * PlaylistLayoutSection updateMany
   */
  export type PlaylistLayoutSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaylistLayoutSections.
     */
    data: XOR<PlaylistLayoutSectionUpdateManyMutationInput, PlaylistLayoutSectionUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistLayoutSections to update
     */
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistLayoutSections to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistLayoutSection updateManyAndReturn
   */
  export type PlaylistLayoutSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * The data used to update PlaylistLayoutSections.
     */
    data: XOR<PlaylistLayoutSectionUpdateManyMutationInput, PlaylistLayoutSectionUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistLayoutSections to update
     */
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistLayoutSections to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistLayoutSection upsert
   */
  export type PlaylistLayoutSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaylistLayoutSection to update in case it exists.
     */
    where: PlaylistLayoutSectionWhereUniqueInput
    /**
     * In case the PlaylistLayoutSection found by the `where` argument doesn't exist, create a new PlaylistLayoutSection with this data.
     */
    create: XOR<PlaylistLayoutSectionCreateInput, PlaylistLayoutSectionUncheckedCreateInput>
    /**
     * In case the PlaylistLayoutSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistLayoutSectionUpdateInput, PlaylistLayoutSectionUncheckedUpdateInput>
  }

  /**
   * PlaylistLayoutSection delete
   */
  export type PlaylistLayoutSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
    /**
     * Filter which PlaylistLayoutSection to delete.
     */
    where: PlaylistLayoutSectionWhereUniqueInput
  }

  /**
   * PlaylistLayoutSection deleteMany
   */
  export type PlaylistLayoutSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistLayoutSections to delete
     */
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistLayoutSections to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistLayoutSection.playlistItems
   */
  export type PlaylistLayoutSection$playlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    where?: PlaylistItemWhereInput | $Types.Skip
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistItemWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistLayoutSection without action
   */
  export type PlaylistLayoutSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayoutSection
     */
    select?: PlaylistLayoutSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayoutSection
     */
    omit?: PlaylistLayoutSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutSectionInclude<ExtArgs> | null
  }


  /**
   * Model PlaylistSchedule
   */

  export type AggregatePlaylistSchedule = {
    _count: PlaylistScheduleCountAggregateOutputType | null
    _min: PlaylistScheduleMinAggregateOutputType | null
    _max: PlaylistScheduleMaxAggregateOutputType | null
  }

  export type PlaylistScheduleMinAggregateOutputType = {
    id: string | null
    playlistId: string | null
    startAt: Date | null
    endAt: Date | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaylistScheduleMaxAggregateOutputType = {
    id: string | null
    playlistId: string | null
    startAt: Date | null
    endAt: Date | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaylistScheduleCountAggregateOutputType = {
    id: number
    playlistId: number
    startAt: number
    endAt: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    weekdays: number
    _all: number
  }


  export type PlaylistScheduleMinAggregateInputType = {
    id?: true | $Types.Skip
    playlistId?: true | $Types.Skip
    startAt?: true | $Types.Skip
    endAt?: true | $Types.Skip
    startTime?: true | $Types.Skip
    endTime?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type PlaylistScheduleMaxAggregateInputType = {
    id?: true | $Types.Skip
    playlistId?: true | $Types.Skip
    startAt?: true | $Types.Skip
    endAt?: true | $Types.Skip
    startTime?: true | $Types.Skip
    endTime?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type PlaylistScheduleCountAggregateInputType = {
    id?: true | $Types.Skip
    playlistId?: true | $Types.Skip
    startAt?: true | $Types.Skip
    endAt?: true | $Types.Skip
    startTime?: true | $Types.Skip
    endTime?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    weekdays?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type PlaylistScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistSchedule to aggregate.
     */
    where?: PlaylistScheduleWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistSchedules to fetch.
     */
    orderBy?: PlaylistScheduleOrderByWithRelationInput | PlaylistScheduleOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistScheduleWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistSchedules from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistSchedules.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaylistSchedules
    **/
    _count?: true | PlaylistScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistScheduleMaxAggregateInputType
  }

  export type GetPlaylistScheduleAggregateType<T extends PlaylistScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylistSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylistSchedule[P]>
      : GetScalarType<T[P], AggregatePlaylistSchedule[P]>
  }




  export type PlaylistScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistScheduleWhereInput | $Types.Skip
    orderBy?: PlaylistScheduleOrderByWithAggregationInput | PlaylistScheduleOrderByWithAggregationInput[] | $Types.Skip
    by: PlaylistScheduleScalarFieldEnum[] | PlaylistScheduleScalarFieldEnum
    having?: PlaylistScheduleScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: PlaylistScheduleCountAggregateInputType | true
    _min?: PlaylistScheduleMinAggregateInputType
    _max?: PlaylistScheduleMaxAggregateInputType
  }

  export type PlaylistScheduleGroupByOutputType = {
    id: string
    playlistId: string
    startAt: Date
    endAt: Date | null
    startTime: string | null
    endTime: string | null
    createdAt: Date
    updatedAt: Date
    weekdays: $Enums.Weekday[]
    _count: PlaylistScheduleCountAggregateOutputType | null
    _min: PlaylistScheduleMinAggregateOutputType | null
    _max: PlaylistScheduleMaxAggregateOutputType | null
  }

  type GetPlaylistScheduleGroupByPayload<T extends PlaylistScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistScheduleGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistId?: boolean | $Types.Skip
    startAt?: boolean | $Types.Skip
    endAt?: boolean | $Types.Skip
    startTime?: boolean | $Types.Skip
    endTime?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    weekdays?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistSchedule"]>

  export type PlaylistScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistId?: boolean | $Types.Skip
    startAt?: boolean | $Types.Skip
    endAt?: boolean | $Types.Skip
    startTime?: boolean | $Types.Skip
    endTime?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    weekdays?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistSchedule"]>

  export type PlaylistScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    playlistId?: boolean | $Types.Skip
    startAt?: boolean | $Types.Skip
    endAt?: boolean | $Types.Skip
    startTime?: boolean | $Types.Skip
    endTime?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    weekdays?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistSchedule"]>

  export type PlaylistScheduleSelectScalar = {
    id?: boolean | $Types.Skip
    playlistId?: boolean | $Types.Skip
    startAt?: boolean | $Types.Skip
    endAt?: boolean | $Types.Skip
    startTime?: boolean | $Types.Skip
    endTime?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    weekdays?: boolean | $Types.Skip
  }

  export type PlaylistScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playlistId" | "startAt" | "endAt" | "startTime" | "endTime" | "createdAt" | "updatedAt" | "weekdays", ExtArgs["result"]["playlistSchedule"], $Types.Skip>
  export type PlaylistScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $PlaylistSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaylistSchedule"
    objects: {
      playlist: Prisma.$PlaylistPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playlistId: string
      startAt: Date
      endAt: Date | null
      startTime: string | null
      endTime: string | null
      createdAt: Date
      updatedAt: Date
      weekdays: $Enums.Weekday[]
    }, ExtArgs["result"]["playlistSchedule"]>
    composites: {}
  }

  type PlaylistScheduleGetPayload<S extends boolean | null | undefined | PlaylistScheduleDefaultArgs> = $Result.GetResult<Prisma.$PlaylistSchedulePayload, S>

  type PlaylistScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistScheduleCountAggregateInputType | true
    }

  export interface PlaylistScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaylistSchedule'], meta: { name: 'PlaylistSchedule' } }
    /**
     * Find zero or one PlaylistSchedule that matches the filter.
     * @param {PlaylistScheduleFindUniqueArgs} args - Arguments to find a PlaylistSchedule
     * @example
     * // Get one PlaylistSchedule
     * const playlistSchedule = await prisma.playlistSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistScheduleFindUniqueArgs>(args: SelectSubset<T, PlaylistScheduleFindUniqueArgs<ExtArgs>>): Prisma__PlaylistScheduleClient<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaylistSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistScheduleFindUniqueOrThrowArgs} args - Arguments to find a PlaylistSchedule
     * @example
     * // Get one PlaylistSchedule
     * const playlistSchedule = await prisma.playlistSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistScheduleClient<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScheduleFindFirstArgs} args - Arguments to find a PlaylistSchedule
     * @example
     * // Get one PlaylistSchedule
     * const playlistSchedule = await prisma.playlistSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistScheduleFindFirstArgs>(args?: SelectSubset<T, PlaylistScheduleFindFirstArgs<ExtArgs>>): Prisma__PlaylistScheduleClient<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScheduleFindFirstOrThrowArgs} args - Arguments to find a PlaylistSchedule
     * @example
     * // Get one PlaylistSchedule
     * const playlistSchedule = await prisma.playlistSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistScheduleClient<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaylistSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaylistSchedules
     * const playlistSchedules = await prisma.playlistSchedule.findMany()
     * 
     * // Get first 10 PlaylistSchedules
     * const playlistSchedules = await prisma.playlistSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistScheduleWithIdOnly = await prisma.playlistSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistScheduleFindManyArgs>(args?: SelectSubset<T, PlaylistScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaylistSchedule.
     * @param {PlaylistScheduleCreateArgs} args - Arguments to create a PlaylistSchedule.
     * @example
     * // Create one PlaylistSchedule
     * const PlaylistSchedule = await prisma.playlistSchedule.create({
     *   data: {
     *     // ... data to create a PlaylistSchedule
     *   }
     * })
     * 
     */
    create<T extends PlaylistScheduleCreateArgs>(args: SelectSubset<T, PlaylistScheduleCreateArgs<ExtArgs>>): Prisma__PlaylistScheduleClient<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaylistSchedules.
     * @param {PlaylistScheduleCreateManyArgs} args - Arguments to create many PlaylistSchedules.
     * @example
     * // Create many PlaylistSchedules
     * const playlistSchedule = await prisma.playlistSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistScheduleCreateManyArgs>(args?: SelectSubset<T, PlaylistScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaylistSchedules and returns the data saved in the database.
     * @param {PlaylistScheduleCreateManyAndReturnArgs} args - Arguments to create many PlaylistSchedules.
     * @example
     * // Create many PlaylistSchedules
     * const playlistSchedule = await prisma.playlistSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaylistSchedules and only return the `id`
     * const playlistScheduleWithIdOnly = await prisma.playlistSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaylistSchedule.
     * @param {PlaylistScheduleDeleteArgs} args - Arguments to delete one PlaylistSchedule.
     * @example
     * // Delete one PlaylistSchedule
     * const PlaylistSchedule = await prisma.playlistSchedule.delete({
     *   where: {
     *     // ... filter to delete one PlaylistSchedule
     *   }
     * })
     * 
     */
    delete<T extends PlaylistScheduleDeleteArgs>(args: SelectSubset<T, PlaylistScheduleDeleteArgs<ExtArgs>>): Prisma__PlaylistScheduleClient<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaylistSchedule.
     * @param {PlaylistScheduleUpdateArgs} args - Arguments to update one PlaylistSchedule.
     * @example
     * // Update one PlaylistSchedule
     * const playlistSchedule = await prisma.playlistSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistScheduleUpdateArgs>(args: SelectSubset<T, PlaylistScheduleUpdateArgs<ExtArgs>>): Prisma__PlaylistScheduleClient<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaylistSchedules.
     * @param {PlaylistScheduleDeleteManyArgs} args - Arguments to filter PlaylistSchedules to delete.
     * @example
     * // Delete a few PlaylistSchedules
     * const { count } = await prisma.playlistSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistScheduleDeleteManyArgs>(args?: SelectSubset<T, PlaylistScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaylistSchedules
     * const playlistSchedule = await prisma.playlistSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistScheduleUpdateManyArgs>(args: SelectSubset<T, PlaylistScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistSchedules and returns the data updated in the database.
     * @param {PlaylistScheduleUpdateManyAndReturnArgs} args - Arguments to update many PlaylistSchedules.
     * @example
     * // Update many PlaylistSchedules
     * const playlistSchedule = await prisma.playlistSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaylistSchedules and only return the `id`
     * const playlistScheduleWithIdOnly = await prisma.playlistSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaylistSchedule.
     * @param {PlaylistScheduleUpsertArgs} args - Arguments to update or create a PlaylistSchedule.
     * @example
     * // Update or create a PlaylistSchedule
     * const playlistSchedule = await prisma.playlistSchedule.upsert({
     *   create: {
     *     // ... data to create a PlaylistSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaylistSchedule we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistScheduleUpsertArgs>(args: SelectSubset<T, PlaylistScheduleUpsertArgs<ExtArgs>>): Prisma__PlaylistScheduleClient<$Result.GetResult<Prisma.$PlaylistSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaylistSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScheduleCountArgs} args - Arguments to filter PlaylistSchedules to count.
     * @example
     * // Count the number of PlaylistSchedules
     * const count = await prisma.playlistSchedule.count({
     *   where: {
     *     // ... the filter for the PlaylistSchedules we want to count
     *   }
     * })
    **/
    count<T extends PlaylistScheduleCountArgs>(
      args?: Subset<T, PlaylistScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaylistSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistScheduleAggregateArgs>(args: Subset<T, PlaylistScheduleAggregateArgs>): Prisma.PrismaPromise<GetPlaylistScheduleAggregateType<T>>

    /**
     * Group by PlaylistSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistScheduleGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaylistSchedule model
   */
  readonly fields: PlaylistScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaylistSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaylistSchedule model
   */
  interface PlaylistScheduleFieldRefs {
    readonly id: FieldRef<"PlaylistSchedule", 'String'>
    readonly playlistId: FieldRef<"PlaylistSchedule", 'String'>
    readonly startAt: FieldRef<"PlaylistSchedule", 'DateTime'>
    readonly endAt: FieldRef<"PlaylistSchedule", 'DateTime'>
    readonly startTime: FieldRef<"PlaylistSchedule", 'String'>
    readonly endTime: FieldRef<"PlaylistSchedule", 'String'>
    readonly createdAt: FieldRef<"PlaylistSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"PlaylistSchedule", 'DateTime'>
    readonly weekdays: FieldRef<"PlaylistSchedule", 'Weekday[]'>
  }
    

  // Custom InputTypes
  /**
   * PlaylistSchedule findUnique
   */
  export type PlaylistScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSchedule to fetch.
     */
    where: PlaylistScheduleWhereUniqueInput
  }

  /**
   * PlaylistSchedule findUniqueOrThrow
   */
  export type PlaylistScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSchedule to fetch.
     */
    where: PlaylistScheduleWhereUniqueInput
  }

  /**
   * PlaylistSchedule findFirst
   */
  export type PlaylistScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSchedule to fetch.
     */
    where?: PlaylistScheduleWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistSchedules to fetch.
     */
    orderBy?: PlaylistScheduleOrderByWithRelationInput | PlaylistScheduleOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistSchedules.
     */
    cursor?: PlaylistScheduleWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistSchedules from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistSchedules.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistSchedules.
     */
    distinct?: PlaylistScheduleScalarFieldEnum | PlaylistScheduleScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistSchedule findFirstOrThrow
   */
  export type PlaylistScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSchedule to fetch.
     */
    where?: PlaylistScheduleWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistSchedules to fetch.
     */
    orderBy?: PlaylistScheduleOrderByWithRelationInput | PlaylistScheduleOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistSchedules.
     */
    cursor?: PlaylistScheduleWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistSchedules from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistSchedules.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistSchedules.
     */
    distinct?: PlaylistScheduleScalarFieldEnum | PlaylistScheduleScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistSchedule findMany
   */
  export type PlaylistScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSchedules to fetch.
     */
    where?: PlaylistScheduleWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistSchedules to fetch.
     */
    orderBy?: PlaylistScheduleOrderByWithRelationInput | PlaylistScheduleOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaylistSchedules.
     */
    cursor?: PlaylistScheduleWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistSchedules from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistSchedules.
     */
    skip?: number | $Types.Skip
    distinct?: PlaylistScheduleScalarFieldEnum | PlaylistScheduleScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistSchedule create
   */
  export type PlaylistScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaylistSchedule.
     */
    data: XOR<PlaylistScheduleCreateInput, PlaylistScheduleUncheckedCreateInput>
  }

  /**
   * PlaylistSchedule createMany
   */
  export type PlaylistScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaylistSchedules.
     */
    data: PlaylistScheduleCreateManyInput | PlaylistScheduleCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * PlaylistSchedule createManyAndReturn
   */
  export type PlaylistScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many PlaylistSchedules.
     */
    data: PlaylistScheduleCreateManyInput | PlaylistScheduleCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistSchedule update
   */
  export type PlaylistScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaylistSchedule.
     */
    data: XOR<PlaylistScheduleUpdateInput, PlaylistScheduleUncheckedUpdateInput>
    /**
     * Choose, which PlaylistSchedule to update.
     */
    where: PlaylistScheduleWhereUniqueInput
  }

  /**
   * PlaylistSchedule updateMany
   */
  export type PlaylistScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaylistSchedules.
     */
    data: XOR<PlaylistScheduleUpdateManyMutationInput, PlaylistScheduleUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistSchedules to update
     */
    where?: PlaylistScheduleWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistSchedules to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistSchedule updateManyAndReturn
   */
  export type PlaylistScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * The data used to update PlaylistSchedules.
     */
    data: XOR<PlaylistScheduleUpdateManyMutationInput, PlaylistScheduleUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistSchedules to update
     */
    where?: PlaylistScheduleWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistSchedules to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistSchedule upsert
   */
  export type PlaylistScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaylistSchedule to update in case it exists.
     */
    where: PlaylistScheduleWhereUniqueInput
    /**
     * In case the PlaylistSchedule found by the `where` argument doesn't exist, create a new PlaylistSchedule with this data.
     */
    create: XOR<PlaylistScheduleCreateInput, PlaylistScheduleUncheckedCreateInput>
    /**
     * In case the PlaylistSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistScheduleUpdateInput, PlaylistScheduleUncheckedUpdateInput>
  }

  /**
   * PlaylistSchedule delete
   */
  export type PlaylistScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
    /**
     * Filter which PlaylistSchedule to delete.
     */
    where: PlaylistScheduleWhereUniqueInput
  }

  /**
   * PlaylistSchedule deleteMany
   */
  export type PlaylistScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistSchedules to delete
     */
    where?: PlaylistScheduleWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistSchedules to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistSchedule without action
   */
  export type PlaylistScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSchedule
     */
    select?: PlaylistScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSchedule
     */
    omit?: PlaylistScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScheduleInclude<ExtArgs> | null
  }


  /**
   * Model PlaylistScreen
   */

  export type AggregatePlaylistScreen = {
    _count: PlaylistScreenCountAggregateOutputType | null
    _min: PlaylistScreenMinAggregateOutputType | null
    _max: PlaylistScreenMaxAggregateOutputType | null
  }

  export type PlaylistScreenMinAggregateOutputType = {
    playlistId: string | null
    screenId: string | null
  }

  export type PlaylistScreenMaxAggregateOutputType = {
    playlistId: string | null
    screenId: string | null
  }

  export type PlaylistScreenCountAggregateOutputType = {
    playlistId: number
    screenId: number
    _all: number
  }


  export type PlaylistScreenMinAggregateInputType = {
    playlistId?: true | $Types.Skip
    screenId?: true | $Types.Skip
  }

  export type PlaylistScreenMaxAggregateInputType = {
    playlistId?: true | $Types.Skip
    screenId?: true | $Types.Skip
  }

  export type PlaylistScreenCountAggregateInputType = {
    playlistId?: true | $Types.Skip
    screenId?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type PlaylistScreenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistScreen to aggregate.
     */
    where?: PlaylistScreenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistScreens to fetch.
     */
    orderBy?: PlaylistScreenOrderByWithRelationInput | PlaylistScreenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistScreenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistScreens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistScreens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaylistScreens
    **/
    _count?: true | PlaylistScreenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistScreenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistScreenMaxAggregateInputType
  }

  export type GetPlaylistScreenAggregateType<T extends PlaylistScreenAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylistScreen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylistScreen[P]>
      : GetScalarType<T[P], AggregatePlaylistScreen[P]>
  }




  export type PlaylistScreenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistScreenWhereInput | $Types.Skip
    orderBy?: PlaylistScreenOrderByWithAggregationInput | PlaylistScreenOrderByWithAggregationInput[] | $Types.Skip
    by: PlaylistScreenScalarFieldEnum[] | PlaylistScreenScalarFieldEnum
    having?: PlaylistScreenScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: PlaylistScreenCountAggregateInputType | true
    _min?: PlaylistScreenMinAggregateInputType
    _max?: PlaylistScreenMaxAggregateInputType
  }

  export type PlaylistScreenGroupByOutputType = {
    playlistId: string
    screenId: string
    _count: PlaylistScreenCountAggregateOutputType | null
    _min: PlaylistScreenMinAggregateOutputType | null
    _max: PlaylistScreenMaxAggregateOutputType | null
  }

  type GetPlaylistScreenGroupByPayload<T extends PlaylistScreenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistScreenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistScreenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistScreenGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistScreenGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistScreenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    playlistId?: boolean | $Types.Skip
    screenId?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    screen?: boolean | ScreenDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistScreen"]>

  export type PlaylistScreenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    playlistId?: boolean | $Types.Skip
    screenId?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    screen?: boolean | ScreenDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistScreen"]>

  export type PlaylistScreenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    playlistId?: boolean | $Types.Skip
    screenId?: boolean | $Types.Skip
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    screen?: boolean | ScreenDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["playlistScreen"]>

  export type PlaylistScreenSelectScalar = {
    playlistId?: boolean | $Types.Skip
    screenId?: boolean | $Types.Skip
  }

  export type PlaylistScreenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"playlistId" | "screenId", ExtArgs["result"]["playlistScreen"], $Types.Skip>
  export type PlaylistScreenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    screen?: boolean | ScreenDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistScreenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    screen?: boolean | ScreenDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type PlaylistScreenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs> | $Types.Skip
    screen?: boolean | ScreenDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $PlaylistScreenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaylistScreen"
    objects: {
      playlist: Prisma.$PlaylistPayload<ExtArgs>
      screen: Prisma.$ScreenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      playlistId: string
      screenId: string
    }, ExtArgs["result"]["playlistScreen"]>
    composites: {}
  }

  type PlaylistScreenGetPayload<S extends boolean | null | undefined | PlaylistScreenDefaultArgs> = $Result.GetResult<Prisma.$PlaylistScreenPayload, S>

  type PlaylistScreenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistScreenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistScreenCountAggregateInputType | true
    }

  export interface PlaylistScreenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaylistScreen'], meta: { name: 'PlaylistScreen' } }
    /**
     * Find zero or one PlaylistScreen that matches the filter.
     * @param {PlaylistScreenFindUniqueArgs} args - Arguments to find a PlaylistScreen
     * @example
     * // Get one PlaylistScreen
     * const playlistScreen = await prisma.playlistScreen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistScreenFindUniqueArgs>(args: SelectSubset<T, PlaylistScreenFindUniqueArgs<ExtArgs>>): Prisma__PlaylistScreenClient<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaylistScreen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistScreenFindUniqueOrThrowArgs} args - Arguments to find a PlaylistScreen
     * @example
     * // Get one PlaylistScreen
     * const playlistScreen = await prisma.playlistScreen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistScreenFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistScreenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistScreenClient<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistScreen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScreenFindFirstArgs} args - Arguments to find a PlaylistScreen
     * @example
     * // Get one PlaylistScreen
     * const playlistScreen = await prisma.playlistScreen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistScreenFindFirstArgs>(args?: SelectSubset<T, PlaylistScreenFindFirstArgs<ExtArgs>>): Prisma__PlaylistScreenClient<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistScreen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScreenFindFirstOrThrowArgs} args - Arguments to find a PlaylistScreen
     * @example
     * // Get one PlaylistScreen
     * const playlistScreen = await prisma.playlistScreen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistScreenFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistScreenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistScreenClient<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaylistScreens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScreenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaylistScreens
     * const playlistScreens = await prisma.playlistScreen.findMany()
     * 
     * // Get first 10 PlaylistScreens
     * const playlistScreens = await prisma.playlistScreen.findMany({ take: 10 })
     * 
     * // Only select the `playlistId`
     * const playlistScreenWithPlaylistIdOnly = await prisma.playlistScreen.findMany({ select: { playlistId: true } })
     * 
     */
    findMany<T extends PlaylistScreenFindManyArgs>(args?: SelectSubset<T, PlaylistScreenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaylistScreen.
     * @param {PlaylistScreenCreateArgs} args - Arguments to create a PlaylistScreen.
     * @example
     * // Create one PlaylistScreen
     * const PlaylistScreen = await prisma.playlistScreen.create({
     *   data: {
     *     // ... data to create a PlaylistScreen
     *   }
     * })
     * 
     */
    create<T extends PlaylistScreenCreateArgs>(args: SelectSubset<T, PlaylistScreenCreateArgs<ExtArgs>>): Prisma__PlaylistScreenClient<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaylistScreens.
     * @param {PlaylistScreenCreateManyArgs} args - Arguments to create many PlaylistScreens.
     * @example
     * // Create many PlaylistScreens
     * const playlistScreen = await prisma.playlistScreen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistScreenCreateManyArgs>(args?: SelectSubset<T, PlaylistScreenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaylistScreens and returns the data saved in the database.
     * @param {PlaylistScreenCreateManyAndReturnArgs} args - Arguments to create many PlaylistScreens.
     * @example
     * // Create many PlaylistScreens
     * const playlistScreen = await prisma.playlistScreen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaylistScreens and only return the `playlistId`
     * const playlistScreenWithPlaylistIdOnly = await prisma.playlistScreen.createManyAndReturn({
     *   select: { playlistId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistScreenCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistScreenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaylistScreen.
     * @param {PlaylistScreenDeleteArgs} args - Arguments to delete one PlaylistScreen.
     * @example
     * // Delete one PlaylistScreen
     * const PlaylistScreen = await prisma.playlistScreen.delete({
     *   where: {
     *     // ... filter to delete one PlaylistScreen
     *   }
     * })
     * 
     */
    delete<T extends PlaylistScreenDeleteArgs>(args: SelectSubset<T, PlaylistScreenDeleteArgs<ExtArgs>>): Prisma__PlaylistScreenClient<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaylistScreen.
     * @param {PlaylistScreenUpdateArgs} args - Arguments to update one PlaylistScreen.
     * @example
     * // Update one PlaylistScreen
     * const playlistScreen = await prisma.playlistScreen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistScreenUpdateArgs>(args: SelectSubset<T, PlaylistScreenUpdateArgs<ExtArgs>>): Prisma__PlaylistScreenClient<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaylistScreens.
     * @param {PlaylistScreenDeleteManyArgs} args - Arguments to filter PlaylistScreens to delete.
     * @example
     * // Delete a few PlaylistScreens
     * const { count } = await prisma.playlistScreen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistScreenDeleteManyArgs>(args?: SelectSubset<T, PlaylistScreenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistScreens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScreenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaylistScreens
     * const playlistScreen = await prisma.playlistScreen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistScreenUpdateManyArgs>(args: SelectSubset<T, PlaylistScreenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistScreens and returns the data updated in the database.
     * @param {PlaylistScreenUpdateManyAndReturnArgs} args - Arguments to update many PlaylistScreens.
     * @example
     * // Update many PlaylistScreens
     * const playlistScreen = await prisma.playlistScreen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaylistScreens and only return the `playlistId`
     * const playlistScreenWithPlaylistIdOnly = await prisma.playlistScreen.updateManyAndReturn({
     *   select: { playlistId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistScreenUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistScreenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaylistScreen.
     * @param {PlaylistScreenUpsertArgs} args - Arguments to update or create a PlaylistScreen.
     * @example
     * // Update or create a PlaylistScreen
     * const playlistScreen = await prisma.playlistScreen.upsert({
     *   create: {
     *     // ... data to create a PlaylistScreen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaylistScreen we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistScreenUpsertArgs>(args: SelectSubset<T, PlaylistScreenUpsertArgs<ExtArgs>>): Prisma__PlaylistScreenClient<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaylistScreens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScreenCountArgs} args - Arguments to filter PlaylistScreens to count.
     * @example
     * // Count the number of PlaylistScreens
     * const count = await prisma.playlistScreen.count({
     *   where: {
     *     // ... the filter for the PlaylistScreens we want to count
     *   }
     * })
    **/
    count<T extends PlaylistScreenCountArgs>(
      args?: Subset<T, PlaylistScreenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistScreenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaylistScreen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScreenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistScreenAggregateArgs>(args: Subset<T, PlaylistScreenAggregateArgs>): Prisma.PrismaPromise<GetPlaylistScreenAggregateType<T>>

    /**
     * Group by PlaylistScreen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistScreenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistScreenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistScreenGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistScreenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistScreenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistScreenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaylistScreen model
   */
  readonly fields: PlaylistScreenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaylistScreen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistScreenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    screen<T extends ScreenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScreenDefaultArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaylistScreen model
   */
  interface PlaylistScreenFieldRefs {
    readonly playlistId: FieldRef<"PlaylistScreen", 'String'>
    readonly screenId: FieldRef<"PlaylistScreen", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlaylistScreen findUnique
   */
  export type PlaylistScreenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistScreen to fetch.
     */
    where: PlaylistScreenWhereUniqueInput
  }

  /**
   * PlaylistScreen findUniqueOrThrow
   */
  export type PlaylistScreenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistScreen to fetch.
     */
    where: PlaylistScreenWhereUniqueInput
  }

  /**
   * PlaylistScreen findFirst
   */
  export type PlaylistScreenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistScreen to fetch.
     */
    where?: PlaylistScreenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistScreens to fetch.
     */
    orderBy?: PlaylistScreenOrderByWithRelationInput | PlaylistScreenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistScreens.
     */
    cursor?: PlaylistScreenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistScreens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistScreens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistScreens.
     */
    distinct?: PlaylistScreenScalarFieldEnum | PlaylistScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistScreen findFirstOrThrow
   */
  export type PlaylistScreenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistScreen to fetch.
     */
    where?: PlaylistScreenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistScreens to fetch.
     */
    orderBy?: PlaylistScreenOrderByWithRelationInput | PlaylistScreenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistScreens.
     */
    cursor?: PlaylistScreenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistScreens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistScreens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistScreens.
     */
    distinct?: PlaylistScreenScalarFieldEnum | PlaylistScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistScreen findMany
   */
  export type PlaylistScreenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistScreens to fetch.
     */
    where?: PlaylistScreenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistScreens to fetch.
     */
    orderBy?: PlaylistScreenOrderByWithRelationInput | PlaylistScreenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaylistScreens.
     */
    cursor?: PlaylistScreenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistScreens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistScreens.
     */
    skip?: number | $Types.Skip
    distinct?: PlaylistScreenScalarFieldEnum | PlaylistScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * PlaylistScreen create
   */
  export type PlaylistScreenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaylistScreen.
     */
    data: XOR<PlaylistScreenCreateInput, PlaylistScreenUncheckedCreateInput>
  }

  /**
   * PlaylistScreen createMany
   */
  export type PlaylistScreenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaylistScreens.
     */
    data: PlaylistScreenCreateManyInput | PlaylistScreenCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * PlaylistScreen createManyAndReturn
   */
  export type PlaylistScreenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * The data used to create many PlaylistScreens.
     */
    data: PlaylistScreenCreateManyInput | PlaylistScreenCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistScreen update
   */
  export type PlaylistScreenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaylistScreen.
     */
    data: XOR<PlaylistScreenUpdateInput, PlaylistScreenUncheckedUpdateInput>
    /**
     * Choose, which PlaylistScreen to update.
     */
    where: PlaylistScreenWhereUniqueInput
  }

  /**
   * PlaylistScreen updateMany
   */
  export type PlaylistScreenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaylistScreens.
     */
    data: XOR<PlaylistScreenUpdateManyMutationInput, PlaylistScreenUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistScreens to update
     */
    where?: PlaylistScreenWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistScreens to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistScreen updateManyAndReturn
   */
  export type PlaylistScreenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * The data used to update PlaylistScreens.
     */
    data: XOR<PlaylistScreenUpdateManyMutationInput, PlaylistScreenUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistScreens to update
     */
    where?: PlaylistScreenWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistScreens to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistScreen upsert
   */
  export type PlaylistScreenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaylistScreen to update in case it exists.
     */
    where: PlaylistScreenWhereUniqueInput
    /**
     * In case the PlaylistScreen found by the `where` argument doesn't exist, create a new PlaylistScreen with this data.
     */
    create: XOR<PlaylistScreenCreateInput, PlaylistScreenUncheckedCreateInput>
    /**
     * In case the PlaylistScreen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistScreenUpdateInput, PlaylistScreenUncheckedUpdateInput>
  }

  /**
   * PlaylistScreen delete
   */
  export type PlaylistScreenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    /**
     * Filter which PlaylistScreen to delete.
     */
    where: PlaylistScreenWhereUniqueInput
  }

  /**
   * PlaylistScreen deleteMany
   */
  export type PlaylistScreenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistScreens to delete
     */
    where?: PlaylistScreenWhereInput | $Types.Skip
    /**
     * Limit how many PlaylistScreens to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * PlaylistScreen without action
   */
  export type PlaylistScreenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
  }


  /**
   * Model Screen
   */

  export type AggregateScreen = {
    _count: ScreenCountAggregateOutputType | null
    _avg: ScreenAvgAggregateOutputType | null
    _sum: ScreenSumAggregateOutputType | null
    _min: ScreenMinAggregateOutputType | null
    _max: ScreenMaxAggregateOutputType | null
  }

  export type ScreenAvgAggregateOutputType = {
    resolutionWidth: number | null
    resolutionHeight: number | null
  }

  export type ScreenSumAggregateOutputType = {
    resolutionWidth: number | null
    resolutionHeight: number | null
  }

  export type ScreenMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    groupId: string | null
    name: string | null
    layoutRotation: $Enums.LayoutRotation | null
    resolutionWidth: number | null
    resolutionHeight: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScreenMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    groupId: string | null
    name: string | null
    layoutRotation: $Enums.LayoutRotation | null
    resolutionWidth: number | null
    resolutionHeight: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScreenCountAggregateOutputType = {
    id: number
    workspaceId: number
    groupId: number
    name: number
    layoutRotation: number
    resolutionWidth: number
    resolutionHeight: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScreenAvgAggregateInputType = {
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
  }

  export type ScreenSumAggregateInputType = {
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
  }

  export type ScreenMinAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    groupId?: true | $Types.Skip
    name?: true | $Types.Skip
    layoutRotation?: true | $Types.Skip
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
    type?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type ScreenMaxAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    groupId?: true | $Types.Skip
    name?: true | $Types.Skip
    layoutRotation?: true | $Types.Skip
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
    type?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type ScreenCountAggregateInputType = {
    id?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    groupId?: true | $Types.Skip
    name?: true | $Types.Skip
    layoutRotation?: true | $Types.Skip
    resolutionWidth?: true | $Types.Skip
    resolutionHeight?: true | $Types.Skip
    type?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type ScreenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Screen to aggregate.
     */
    where?: ScreenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screens to fetch.
     */
    orderBy?: ScreenOrderByWithRelationInput | ScreenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Screens
    **/
    _count?: true | ScreenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScreenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScreenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenMaxAggregateInputType
  }

  export type GetScreenAggregateType<T extends ScreenAggregateArgs> = {
        [P in keyof T & keyof AggregateScreen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreen[P]>
      : GetScalarType<T[P], AggregateScreen[P]>
  }




  export type ScreenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenWhereInput | $Types.Skip
    orderBy?: ScreenOrderByWithAggregationInput | ScreenOrderByWithAggregationInput[] | $Types.Skip
    by: ScreenScalarFieldEnum[] | ScreenScalarFieldEnum
    having?: ScreenScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: ScreenCountAggregateInputType | true
    _avg?: ScreenAvgAggregateInputType
    _sum?: ScreenSumAggregateInputType
    _min?: ScreenMinAggregateInputType
    _max?: ScreenMaxAggregateInputType
  }

  export type ScreenGroupByOutputType = {
    id: string
    workspaceId: string
    groupId: string | null
    name: string
    layoutRotation: $Enums.LayoutRotation
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt: Date
    updatedAt: Date
    _count: ScreenCountAggregateOutputType | null
    _avg: ScreenAvgAggregateOutputType | null
    _sum: ScreenSumAggregateOutputType | null
    _min: ScreenMinAggregateOutputType | null
    _max: ScreenMaxAggregateOutputType | null
  }

  type GetScreenGroupByPayload<T extends ScreenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenGroupByOutputType[P]>
        }
      >
    >


  export type ScreenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    groupId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    layoutRotation?: boolean | $Types.Skip
    resolutionWidth?: boolean | $Types.Skip
    resolutionHeight?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    device?: boolean | Screen$deviceArgs<ExtArgs> | $Types.Skip
    playlists?: boolean | Screen$playlistsArgs<ExtArgs> | $Types.Skip
    group?: boolean | Screen$groupArgs<ExtArgs> | $Types.Skip
    _count?: boolean | ScreenCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["screen"]>

  export type ScreenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    groupId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    layoutRotation?: boolean | $Types.Skip
    resolutionWidth?: boolean | $Types.Skip
    resolutionHeight?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    group?: boolean | Screen$groupArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["screen"]>

  export type ScreenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    groupId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    layoutRotation?: boolean | $Types.Skip
    resolutionWidth?: boolean | $Types.Skip
    resolutionHeight?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    group?: boolean | Screen$groupArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["screen"]>

  export type ScreenSelectScalar = {
    id?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    groupId?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    layoutRotation?: boolean | $Types.Skip
    resolutionWidth?: boolean | $Types.Skip
    resolutionHeight?: boolean | $Types.Skip
    type?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }

  export type ScreenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "groupId" | "name" | "layoutRotation" | "resolutionWidth" | "resolutionHeight" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["screen"], $Types.Skip>
  export type ScreenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    device?: boolean | Screen$deviceArgs<ExtArgs> | $Types.Skip
    playlists?: boolean | Screen$playlistsArgs<ExtArgs> | $Types.Skip
    group?: boolean | Screen$groupArgs<ExtArgs> | $Types.Skip
    _count?: boolean | ScreenCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type ScreenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    group?: boolean | Screen$groupArgs<ExtArgs> | $Types.Skip
  }
  export type ScreenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    group?: boolean | Screen$groupArgs<ExtArgs> | $Types.Skip
  }

  export type $ScreenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Screen"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs> | null
      playlists: Prisma.$PlaylistScreenPayload<ExtArgs>[]
      group: Prisma.$ScreenGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      groupId: string | null
      name: string
      layoutRotation: $Enums.LayoutRotation
      resolutionWidth: number
      resolutionHeight: number
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["screen"]>
    composites: {}
  }

  type ScreenGetPayload<S extends boolean | null | undefined | ScreenDefaultArgs> = $Result.GetResult<Prisma.$ScreenPayload, S>

  type ScreenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScreenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenCountAggregateInputType | true
    }

  export interface ScreenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Screen'], meta: { name: 'Screen' } }
    /**
     * Find zero or one Screen that matches the filter.
     * @param {ScreenFindUniqueArgs} args - Arguments to find a Screen
     * @example
     * // Get one Screen
     * const screen = await prisma.screen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenFindUniqueArgs>(args: SelectSubset<T, ScreenFindUniqueArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Screen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenFindUniqueOrThrowArgs} args - Arguments to find a Screen
     * @example
     * // Get one Screen
     * const screen = await prisma.screen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Screen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenFindFirstArgs} args - Arguments to find a Screen
     * @example
     * // Get one Screen
     * const screen = await prisma.screen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenFindFirstArgs>(args?: SelectSubset<T, ScreenFindFirstArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Screen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenFindFirstOrThrowArgs} args - Arguments to find a Screen
     * @example
     * // Get one Screen
     * const screen = await prisma.screen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Screens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Screens
     * const screens = await prisma.screen.findMany()
     * 
     * // Get first 10 Screens
     * const screens = await prisma.screen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const screenWithIdOnly = await prisma.screen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScreenFindManyArgs>(args?: SelectSubset<T, ScreenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Screen.
     * @param {ScreenCreateArgs} args - Arguments to create a Screen.
     * @example
     * // Create one Screen
     * const Screen = await prisma.screen.create({
     *   data: {
     *     // ... data to create a Screen
     *   }
     * })
     * 
     */
    create<T extends ScreenCreateArgs>(args: SelectSubset<T, ScreenCreateArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Screens.
     * @param {ScreenCreateManyArgs} args - Arguments to create many Screens.
     * @example
     * // Create many Screens
     * const screen = await prisma.screen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenCreateManyArgs>(args?: SelectSubset<T, ScreenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Screens and returns the data saved in the database.
     * @param {ScreenCreateManyAndReturnArgs} args - Arguments to create many Screens.
     * @example
     * // Create many Screens
     * const screen = await prisma.screen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Screens and only return the `id`
     * const screenWithIdOnly = await prisma.screen.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Screen.
     * @param {ScreenDeleteArgs} args - Arguments to delete one Screen.
     * @example
     * // Delete one Screen
     * const Screen = await prisma.screen.delete({
     *   where: {
     *     // ... filter to delete one Screen
     *   }
     * })
     * 
     */
    delete<T extends ScreenDeleteArgs>(args: SelectSubset<T, ScreenDeleteArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Screen.
     * @param {ScreenUpdateArgs} args - Arguments to update one Screen.
     * @example
     * // Update one Screen
     * const screen = await prisma.screen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenUpdateArgs>(args: SelectSubset<T, ScreenUpdateArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Screens.
     * @param {ScreenDeleteManyArgs} args - Arguments to filter Screens to delete.
     * @example
     * // Delete a few Screens
     * const { count } = await prisma.screen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenDeleteManyArgs>(args?: SelectSubset<T, ScreenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Screens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Screens
     * const screen = await prisma.screen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenUpdateManyArgs>(args: SelectSubset<T, ScreenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Screens and returns the data updated in the database.
     * @param {ScreenUpdateManyAndReturnArgs} args - Arguments to update many Screens.
     * @example
     * // Update many Screens
     * const screen = await prisma.screen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Screens and only return the `id`
     * const screenWithIdOnly = await prisma.screen.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScreenUpdateManyAndReturnArgs>(args: SelectSubset<T, ScreenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Screen.
     * @param {ScreenUpsertArgs} args - Arguments to update or create a Screen.
     * @example
     * // Update or create a Screen
     * const screen = await prisma.screen.upsert({
     *   create: {
     *     // ... data to create a Screen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Screen we want to update
     *   }
     * })
     */
    upsert<T extends ScreenUpsertArgs>(args: SelectSubset<T, ScreenUpsertArgs<ExtArgs>>): Prisma__ScreenClient<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Screens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenCountArgs} args - Arguments to filter Screens to count.
     * @example
     * // Count the number of Screens
     * const count = await prisma.screen.count({
     *   where: {
     *     // ... the filter for the Screens we want to count
     *   }
     * })
    **/
    count<T extends ScreenCountArgs>(
      args?: Subset<T, ScreenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Screen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenAggregateArgs>(args: Subset<T, ScreenAggregateArgs>): Prisma.PrismaPromise<GetScreenAggregateType<T>>

    /**
     * Group by Screen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenGroupByArgs['orderBy'] }
        : { orderBy?: ScreenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Screen model
   */
  readonly fields: ScreenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Screen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    device<T extends Screen$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Screen$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    playlists<T extends Screen$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, Screen$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistScreenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    group<T extends Screen$groupArgs<ExtArgs> = {}>(args?: Subset<T, Screen$groupArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Screen model
   */
  interface ScreenFieldRefs {
    readonly id: FieldRef<"Screen", 'String'>
    readonly workspaceId: FieldRef<"Screen", 'String'>
    readonly groupId: FieldRef<"Screen", 'String'>
    readonly name: FieldRef<"Screen", 'String'>
    readonly layoutRotation: FieldRef<"Screen", 'LayoutRotation'>
    readonly resolutionWidth: FieldRef<"Screen", 'Int'>
    readonly resolutionHeight: FieldRef<"Screen", 'Int'>
    readonly type: FieldRef<"Screen", 'String'>
    readonly createdAt: FieldRef<"Screen", 'DateTime'>
    readonly updatedAt: FieldRef<"Screen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Screen findUnique
   */
  export type ScreenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * Filter, which Screen to fetch.
     */
    where: ScreenWhereUniqueInput
  }

  /**
   * Screen findUniqueOrThrow
   */
  export type ScreenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * Filter, which Screen to fetch.
     */
    where: ScreenWhereUniqueInput
  }

  /**
   * Screen findFirst
   */
  export type ScreenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * Filter, which Screen to fetch.
     */
    where?: ScreenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screens to fetch.
     */
    orderBy?: ScreenOrderByWithRelationInput | ScreenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Screens.
     */
    cursor?: ScreenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Screens.
     */
    distinct?: ScreenScalarFieldEnum | ScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Screen findFirstOrThrow
   */
  export type ScreenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * Filter, which Screen to fetch.
     */
    where?: ScreenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screens to fetch.
     */
    orderBy?: ScreenOrderByWithRelationInput | ScreenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Screens.
     */
    cursor?: ScreenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screens.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Screens.
     */
    distinct?: ScreenScalarFieldEnum | ScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Screen findMany
   */
  export type ScreenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * Filter, which Screens to fetch.
     */
    where?: ScreenWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screens to fetch.
     */
    orderBy?: ScreenOrderByWithRelationInput | ScreenOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Screens.
     */
    cursor?: ScreenWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screens from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screens.
     */
    skip?: number | $Types.Skip
    distinct?: ScreenScalarFieldEnum | ScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Screen create
   */
  export type ScreenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * The data needed to create a Screen.
     */
    data: XOR<ScreenCreateInput, ScreenUncheckedCreateInput>
  }

  /**
   * Screen createMany
   */
  export type ScreenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Screens.
     */
    data: ScreenCreateManyInput | ScreenCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * Screen createManyAndReturn
   */
  export type ScreenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * The data used to create many Screens.
     */
    data: ScreenCreateManyInput | ScreenCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Screen update
   */
  export type ScreenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * The data needed to update a Screen.
     */
    data: XOR<ScreenUpdateInput, ScreenUncheckedUpdateInput>
    /**
     * Choose, which Screen to update.
     */
    where: ScreenWhereUniqueInput
  }

  /**
   * Screen updateMany
   */
  export type ScreenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Screens.
     */
    data: XOR<ScreenUpdateManyMutationInput, ScreenUncheckedUpdateManyInput>
    /**
     * Filter which Screens to update
     */
    where?: ScreenWhereInput | $Types.Skip
    /**
     * Limit how many Screens to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Screen updateManyAndReturn
   */
  export type ScreenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * The data used to update Screens.
     */
    data: XOR<ScreenUpdateManyMutationInput, ScreenUncheckedUpdateManyInput>
    /**
     * Filter which Screens to update
     */
    where?: ScreenWhereInput | $Types.Skip
    /**
     * Limit how many Screens to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Screen upsert
   */
  export type ScreenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * The filter to search for the Screen to update in case it exists.
     */
    where: ScreenWhereUniqueInput
    /**
     * In case the Screen found by the `where` argument doesn't exist, create a new Screen with this data.
     */
    create: XOR<ScreenCreateInput, ScreenUncheckedCreateInput>
    /**
     * In case the Screen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenUpdateInput, ScreenUncheckedUpdateInput>
  }

  /**
   * Screen delete
   */
  export type ScreenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    /**
     * Filter which Screen to delete.
     */
    where: ScreenWhereUniqueInput
  }

  /**
   * Screen deleteMany
   */
  export type ScreenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Screens to delete
     */
    where?: ScreenWhereInput | $Types.Skip
    /**
     * Limit how many Screens to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Screen.device
   */
  export type Screen$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput | $Types.Skip
  }

  /**
   * Screen.playlists
   */
  export type Screen$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistScreen
     */
    select?: PlaylistScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistScreen
     */
    omit?: PlaylistScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistScreenInclude<ExtArgs> | null
    where?: PlaylistScreenWhereInput | $Types.Skip
    orderBy?: PlaylistScreenOrderByWithRelationInput | PlaylistScreenOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistScreenWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistScreenScalarFieldEnum | PlaylistScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Screen.group
   */
  export type Screen$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    where?: ScreenGroupWhereInput | $Types.Skip
  }

  /**
   * Screen without action
   */
  export type ScreenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
  }


  /**
   * Model ScreenGroup
   */

  export type AggregateScreenGroup = {
    _count: ScreenGroupCountAggregateOutputType | null
    _min: ScreenGroupMinAggregateOutputType | null
    _max: ScreenGroupMaxAggregateOutputType | null
  }

  export type ScreenGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    workspaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ScreenGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    workspaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ScreenGroupCountAggregateOutputType = {
    id: number
    name: number
    workspaceId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ScreenGroupMinAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
  }

  export type ScreenGroupMaxAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
  }

  export type ScreenGroupCountAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type ScreenGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenGroup to aggregate.
     */
    where?: ScreenGroupWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenGroups to fetch.
     */
    orderBy?: ScreenGroupOrderByWithRelationInput | ScreenGroupOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenGroupWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenGroups from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenGroups.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScreenGroups
    **/
    _count?: true | ScreenGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenGroupMaxAggregateInputType
  }

  export type GetScreenGroupAggregateType<T extends ScreenGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenGroup[P]>
      : GetScalarType<T[P], AggregateScreenGroup[P]>
  }




  export type ScreenGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenGroupWhereInput | $Types.Skip
    orderBy?: ScreenGroupOrderByWithAggregationInput | ScreenGroupOrderByWithAggregationInput[] | $Types.Skip
    by: ScreenGroupScalarFieldEnum[] | ScreenGroupScalarFieldEnum
    having?: ScreenGroupScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: ScreenGroupCountAggregateInputType | true
    _min?: ScreenGroupMinAggregateInputType
    _max?: ScreenGroupMaxAggregateInputType
  }

  export type ScreenGroupGroupByOutputType = {
    id: string
    name: string
    workspaceId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ScreenGroupCountAggregateOutputType | null
    _min: ScreenGroupMinAggregateOutputType | null
    _max: ScreenGroupMaxAggregateOutputType | null
  }

  type GetScreenGroupGroupByPayload<T extends ScreenGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenGroupGroupByOutputType[P]>
        }
      >
    >


  export type ScreenGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    screens?: boolean | ScreenGroup$screensArgs<ExtArgs> | $Types.Skip
    _count?: boolean | ScreenGroupCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["screenGroup"]>

  export type ScreenGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["screenGroup"]>

  export type ScreenGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["screenGroup"]>

  export type ScreenGroupSelectScalar = {
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
  }

  export type ScreenGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "workspaceId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["screenGroup"], $Types.Skip>
  export type ScreenGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    screens?: boolean | ScreenGroup$screensArgs<ExtArgs> | $Types.Skip
    _count?: boolean | ScreenGroupCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type ScreenGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type ScreenGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $ScreenGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScreenGroup"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      screens: Prisma.$ScreenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      workspaceId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["screenGroup"]>
    composites: {}
  }

  type ScreenGroupGetPayload<S extends boolean | null | undefined | ScreenGroupDefaultArgs> = $Result.GetResult<Prisma.$ScreenGroupPayload, S>

  type ScreenGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScreenGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenGroupCountAggregateInputType | true
    }

  export interface ScreenGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScreenGroup'], meta: { name: 'ScreenGroup' } }
    /**
     * Find zero or one ScreenGroup that matches the filter.
     * @param {ScreenGroupFindUniqueArgs} args - Arguments to find a ScreenGroup
     * @example
     * // Get one ScreenGroup
     * const screenGroup = await prisma.screenGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenGroupFindUniqueArgs>(args: SelectSubset<T, ScreenGroupFindUniqueArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScreenGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenGroupFindUniqueOrThrowArgs} args - Arguments to find a ScreenGroup
     * @example
     * // Get one ScreenGroup
     * const screenGroup = await prisma.screenGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenGroupFindFirstArgs} args - Arguments to find a ScreenGroup
     * @example
     * // Get one ScreenGroup
     * const screenGroup = await prisma.screenGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenGroupFindFirstArgs>(args?: SelectSubset<T, ScreenGroupFindFirstArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScreenGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenGroupFindFirstOrThrowArgs} args - Arguments to find a ScreenGroup
     * @example
     * // Get one ScreenGroup
     * const screenGroup = await prisma.screenGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScreenGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScreenGroups
     * const screenGroups = await prisma.screenGroup.findMany()
     * 
     * // Get first 10 ScreenGroups
     * const screenGroups = await prisma.screenGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const screenGroupWithIdOnly = await prisma.screenGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScreenGroupFindManyArgs>(args?: SelectSubset<T, ScreenGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScreenGroup.
     * @param {ScreenGroupCreateArgs} args - Arguments to create a ScreenGroup.
     * @example
     * // Create one ScreenGroup
     * const ScreenGroup = await prisma.screenGroup.create({
     *   data: {
     *     // ... data to create a ScreenGroup
     *   }
     * })
     * 
     */
    create<T extends ScreenGroupCreateArgs>(args: SelectSubset<T, ScreenGroupCreateArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScreenGroups.
     * @param {ScreenGroupCreateManyArgs} args - Arguments to create many ScreenGroups.
     * @example
     * // Create many ScreenGroups
     * const screenGroup = await prisma.screenGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenGroupCreateManyArgs>(args?: SelectSubset<T, ScreenGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScreenGroups and returns the data saved in the database.
     * @param {ScreenGroupCreateManyAndReturnArgs} args - Arguments to create many ScreenGroups.
     * @example
     * // Create many ScreenGroups
     * const screenGroup = await prisma.screenGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScreenGroups and only return the `id`
     * const screenGroupWithIdOnly = await prisma.screenGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScreenGroup.
     * @param {ScreenGroupDeleteArgs} args - Arguments to delete one ScreenGroup.
     * @example
     * // Delete one ScreenGroup
     * const ScreenGroup = await prisma.screenGroup.delete({
     *   where: {
     *     // ... filter to delete one ScreenGroup
     *   }
     * })
     * 
     */
    delete<T extends ScreenGroupDeleteArgs>(args: SelectSubset<T, ScreenGroupDeleteArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScreenGroup.
     * @param {ScreenGroupUpdateArgs} args - Arguments to update one ScreenGroup.
     * @example
     * // Update one ScreenGroup
     * const screenGroup = await prisma.screenGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenGroupUpdateArgs>(args: SelectSubset<T, ScreenGroupUpdateArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScreenGroups.
     * @param {ScreenGroupDeleteManyArgs} args - Arguments to filter ScreenGroups to delete.
     * @example
     * // Delete a few ScreenGroups
     * const { count } = await prisma.screenGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenGroupDeleteManyArgs>(args?: SelectSubset<T, ScreenGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScreenGroups
     * const screenGroup = await prisma.screenGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenGroupUpdateManyArgs>(args: SelectSubset<T, ScreenGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenGroups and returns the data updated in the database.
     * @param {ScreenGroupUpdateManyAndReturnArgs} args - Arguments to update many ScreenGroups.
     * @example
     * // Update many ScreenGroups
     * const screenGroup = await prisma.screenGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScreenGroups and only return the `id`
     * const screenGroupWithIdOnly = await prisma.screenGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScreenGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, ScreenGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScreenGroup.
     * @param {ScreenGroupUpsertArgs} args - Arguments to update or create a ScreenGroup.
     * @example
     * // Update or create a ScreenGroup
     * const screenGroup = await prisma.screenGroup.upsert({
     *   create: {
     *     // ... data to create a ScreenGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScreenGroup we want to update
     *   }
     * })
     */
    upsert<T extends ScreenGroupUpsertArgs>(args: SelectSubset<T, ScreenGroupUpsertArgs<ExtArgs>>): Prisma__ScreenGroupClient<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScreenGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenGroupCountArgs} args - Arguments to filter ScreenGroups to count.
     * @example
     * // Count the number of ScreenGroups
     * const count = await prisma.screenGroup.count({
     *   where: {
     *     // ... the filter for the ScreenGroups we want to count
     *   }
     * })
    **/
    count<T extends ScreenGroupCountArgs>(
      args?: Subset<T, ScreenGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScreenGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenGroupAggregateArgs>(args: Subset<T, ScreenGroupAggregateArgs>): Prisma.PrismaPromise<GetScreenGroupAggregateType<T>>

    /**
     * Group by ScreenGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenGroupGroupByArgs['orderBy'] }
        : { orderBy?: ScreenGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScreenGroup model
   */
  readonly fields: ScreenGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScreenGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    screens<T extends ScreenGroup$screensArgs<ExtArgs> = {}>(args?: Subset<T, ScreenGroup$screensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScreenGroup model
   */
  interface ScreenGroupFieldRefs {
    readonly id: FieldRef<"ScreenGroup", 'String'>
    readonly name: FieldRef<"ScreenGroup", 'String'>
    readonly workspaceId: FieldRef<"ScreenGroup", 'String'>
    readonly createdAt: FieldRef<"ScreenGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"ScreenGroup", 'DateTime'>
    readonly deletedAt: FieldRef<"ScreenGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScreenGroup findUnique
   */
  export type ScreenGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * Filter, which ScreenGroup to fetch.
     */
    where: ScreenGroupWhereUniqueInput
  }

  /**
   * ScreenGroup findUniqueOrThrow
   */
  export type ScreenGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * Filter, which ScreenGroup to fetch.
     */
    where: ScreenGroupWhereUniqueInput
  }

  /**
   * ScreenGroup findFirst
   */
  export type ScreenGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * Filter, which ScreenGroup to fetch.
     */
    where?: ScreenGroupWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenGroups to fetch.
     */
    orderBy?: ScreenGroupOrderByWithRelationInput | ScreenGroupOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenGroups.
     */
    cursor?: ScreenGroupWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenGroups from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenGroups.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenGroups.
     */
    distinct?: ScreenGroupScalarFieldEnum | ScreenGroupScalarFieldEnum[] | $Types.Skip
  }

  /**
   * ScreenGroup findFirstOrThrow
   */
  export type ScreenGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * Filter, which ScreenGroup to fetch.
     */
    where?: ScreenGroupWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenGroups to fetch.
     */
    orderBy?: ScreenGroupOrderByWithRelationInput | ScreenGroupOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenGroups.
     */
    cursor?: ScreenGroupWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenGroups from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenGroups.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenGroups.
     */
    distinct?: ScreenGroupScalarFieldEnum | ScreenGroupScalarFieldEnum[] | $Types.Skip
  }

  /**
   * ScreenGroup findMany
   */
  export type ScreenGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * Filter, which ScreenGroups to fetch.
     */
    where?: ScreenGroupWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenGroups to fetch.
     */
    orderBy?: ScreenGroupOrderByWithRelationInput | ScreenGroupOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScreenGroups.
     */
    cursor?: ScreenGroupWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenGroups from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenGroups.
     */
    skip?: number | $Types.Skip
    distinct?: ScreenGroupScalarFieldEnum | ScreenGroupScalarFieldEnum[] | $Types.Skip
  }

  /**
   * ScreenGroup create
   */
  export type ScreenGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ScreenGroup.
     */
    data: XOR<ScreenGroupCreateInput, ScreenGroupUncheckedCreateInput>
  }

  /**
   * ScreenGroup createMany
   */
  export type ScreenGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScreenGroups.
     */
    data: ScreenGroupCreateManyInput | ScreenGroupCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * ScreenGroup createManyAndReturn
   */
  export type ScreenGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * The data used to create many ScreenGroups.
     */
    data: ScreenGroupCreateManyInput | ScreenGroupCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenGroup update
   */
  export type ScreenGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ScreenGroup.
     */
    data: XOR<ScreenGroupUpdateInput, ScreenGroupUncheckedUpdateInput>
    /**
     * Choose, which ScreenGroup to update.
     */
    where: ScreenGroupWhereUniqueInput
  }

  /**
   * ScreenGroup updateMany
   */
  export type ScreenGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScreenGroups.
     */
    data: XOR<ScreenGroupUpdateManyMutationInput, ScreenGroupUncheckedUpdateManyInput>
    /**
     * Filter which ScreenGroups to update
     */
    where?: ScreenGroupWhereInput | $Types.Skip
    /**
     * Limit how many ScreenGroups to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * ScreenGroup updateManyAndReturn
   */
  export type ScreenGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * The data used to update ScreenGroups.
     */
    data: XOR<ScreenGroupUpdateManyMutationInput, ScreenGroupUncheckedUpdateManyInput>
    /**
     * Filter which ScreenGroups to update
     */
    where?: ScreenGroupWhereInput | $Types.Skip
    /**
     * Limit how many ScreenGroups to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScreenGroup upsert
   */
  export type ScreenGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ScreenGroup to update in case it exists.
     */
    where: ScreenGroupWhereUniqueInput
    /**
     * In case the ScreenGroup found by the `where` argument doesn't exist, create a new ScreenGroup with this data.
     */
    create: XOR<ScreenGroupCreateInput, ScreenGroupUncheckedCreateInput>
    /**
     * In case the ScreenGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenGroupUpdateInput, ScreenGroupUncheckedUpdateInput>
  }

  /**
   * ScreenGroup delete
   */
  export type ScreenGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    /**
     * Filter which ScreenGroup to delete.
     */
    where: ScreenGroupWhereUniqueInput
  }

  /**
   * ScreenGroup deleteMany
   */
  export type ScreenGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScreenGroups to delete
     */
    where?: ScreenGroupWhereInput | $Types.Skip
    /**
     * Limit how many ScreenGroups to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * ScreenGroup.screens
   */
  export type ScreenGroup$screensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    where?: ScreenWhereInput | $Types.Skip
    orderBy?: ScreenOrderByWithRelationInput | ScreenOrderByWithRelationInput[] | $Types.Skip
    cursor?: ScreenWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: ScreenScalarFieldEnum | ScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * ScreenGroup without action
   */
  export type ScreenGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    revokedAt: Date | null
    lastActivityAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    revokedAt: Date | null
    lastActivityAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    userAgent: number
    ipAddress: number
    createdAt: number
    revokedAt: number
    lastActivityAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true | $Types.Skip
    userId?: true | $Types.Skip
    token?: true | $Types.Skip
    userAgent?: true | $Types.Skip
    ipAddress?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    revokedAt?: true | $Types.Skip
    lastActivityAt?: true | $Types.Skip
  }

  export type SessionMaxAggregateInputType = {
    id?: true | $Types.Skip
    userId?: true | $Types.Skip
    token?: true | $Types.Skip
    userAgent?: true | $Types.Skip
    ipAddress?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    revokedAt?: true | $Types.Skip
    lastActivityAt?: true | $Types.Skip
  }

  export type SessionCountAggregateInputType = {
    id?: true | $Types.Skip
    userId?: true | $Types.Skip
    token?: true | $Types.Skip
    userAgent?: true | $Types.Skip
    ipAddress?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    revokedAt?: true | $Types.Skip
    lastActivityAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput | $Types.Skip
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[] | $Types.Skip
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    userAgent: string
    ipAddress: string
    createdAt: Date
    revokedAt: Date | null
    lastActivityAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    userAgent?: boolean | $Types.Skip
    ipAddress?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    revokedAt?: boolean | $Types.Skip
    lastActivityAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    userAgent?: boolean | $Types.Skip
    ipAddress?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    revokedAt?: boolean | $Types.Skip
    lastActivityAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    userAgent?: boolean | $Types.Skip
    ipAddress?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    revokedAt?: boolean | $Types.Skip
    lastActivityAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    token?: boolean | $Types.Skip
    userAgent?: boolean | $Types.Skip
    ipAddress?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    revokedAt?: boolean | $Types.Skip
    lastActivityAt?: boolean | $Types.Skip
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "userAgent" | "ipAddress" | "createdAt" | "revokedAt" | "lastActivityAt", ExtArgs["result"]["session"], $Types.Skip>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      userAgent: string
      ipAddress: string
      createdAt: Date
      revokedAt: Date | null
      lastActivityAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly revokedAt: FieldRef<"Session", 'DateTime'>
    readonly lastActivityAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number | $Types.Skip
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput | $Types.Skip
    /**
     * Limit how many Sessions to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput | $Types.Skip
    /**
     * Limit how many Sessions to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput | $Types.Skip
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerifiedAt: Date | null
    name: string | null
    password: string | null
    profilePhoto: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerifiedAt: Date | null
    name: string | null
    password: string | null
    profilePhoto: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerifiedAt: number
    name: number
    password: number
    profilePhoto: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true | $Types.Skip
    email?: true | $Types.Skip
    emailVerifiedAt?: true | $Types.Skip
    name?: true | $Types.Skip
    password?: true | $Types.Skip
    profilePhoto?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
  }

  export type UserMaxAggregateInputType = {
    id?: true | $Types.Skip
    email?: true | $Types.Skip
    emailVerifiedAt?: true | $Types.Skip
    name?: true | $Types.Skip
    password?: true | $Types.Skip
    profilePhoto?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
  }

  export type UserCountAggregateInputType = {
    id?: true | $Types.Skip
    email?: true | $Types.Skip
    emailVerifiedAt?: true | $Types.Skip
    name?: true | $Types.Skip
    password?: true | $Types.Skip
    profilePhoto?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    deletedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput | $Types.Skip
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[] | $Types.Skip
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerifiedAt: Date | null
    name: string
    password: string
    profilePhoto: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    email?: boolean | $Types.Skip
    emailVerifiedAt?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    password?: boolean | $Types.Skip
    profilePhoto?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
    emailVerificationTokens?: boolean | User$emailVerificationTokensArgs<ExtArgs> | $Types.Skip
    sessions?: boolean | User$sessionsArgs<ExtArgs> | $Types.Skip
    workspaces?: boolean | User$workspacesArgs<ExtArgs> | $Types.Skip
    userPreferences?: boolean | User$userPreferencesArgs<ExtArgs> | $Types.Skip
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs> | $Types.Skip
    fileUploadSessions?: boolean | User$fileUploadSessionsArgs<ExtArgs> | $Types.Skip
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    email?: boolean | $Types.Skip
    emailVerifiedAt?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    password?: boolean | $Types.Skip
    profilePhoto?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    email?: boolean | $Types.Skip
    emailVerifiedAt?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    password?: boolean | $Types.Skip
    profilePhoto?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean | $Types.Skip
    email?: boolean | $Types.Skip
    emailVerifiedAt?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    password?: boolean | $Types.Skip
    profilePhoto?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    deletedAt?: boolean | $Types.Skip
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "emailVerifiedAt" | "name" | "password" | "profilePhoto" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"], $Types.Skip>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailVerificationTokens?: boolean | User$emailVerificationTokensArgs<ExtArgs> | $Types.Skip
    sessions?: boolean | User$sessionsArgs<ExtArgs> | $Types.Skip
    workspaces?: boolean | User$workspacesArgs<ExtArgs> | $Types.Skip
    userPreferences?: boolean | User$userPreferencesArgs<ExtArgs> | $Types.Skip
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs> | $Types.Skip
    fileUploadSessions?: boolean | User$fileUploadSessionsArgs<ExtArgs> | $Types.Skip
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      emailVerificationTokens: Prisma.$EmailVerificationTokenPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      workspaces: Prisma.$UserWorkspacePayload<ExtArgs>[]
      userPreferences: Prisma.$UserPreferencesPayload<ExtArgs>[]
      uploadedFiles: Prisma.$FilePayload<ExtArgs>[]
      fileUploadSessions: Prisma.$FileUploadSessionPayload<ExtArgs>[]
      sentInvitations: Prisma.$WorkspaceUserInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerifiedAt: Date | null
      name: string
      password: string
      profilePhoto: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailVerificationTokens<T extends User$emailVerificationTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$emailVerificationTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPreferences<T extends User$userPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$userPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedFiles<T extends User$uploadedFilesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileUploadSessions<T extends User$fileUploadSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$fileUploadSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentInvitations<T extends User$sentInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly profilePhoto: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number | $Types.Skip
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput | $Types.Skip
    /**
     * Limit how many Users to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput | $Types.Skip
    /**
     * Limit how many Users to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput | $Types.Skip
    /**
     * Limit how many Users to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * User.emailVerificationTokens
   */
  export type User$emailVerificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    where?: EmailVerificationTokenWhereInput | $Types.Skip
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[] | $Types.Skip
    cursor?: EmailVerificationTokenWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput | $Types.Skip
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[] | $Types.Skip
    cursor?: SessionWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    where?: UserWorkspaceWhereInput | $Types.Skip
    orderBy?: UserWorkspaceOrderByWithRelationInput | UserWorkspaceOrderByWithRelationInput[] | $Types.Skip
    cursor?: UserWorkspaceWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: UserWorkspaceScalarFieldEnum | UserWorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User.userPreferences
   */
  export type User$userPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput | $Types.Skip
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[] | $Types.Skip
    cursor?: UserPreferencesWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User.uploadedFiles
   */
  export type User$uploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput | $Types.Skip
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[] | $Types.Skip
    cursor?: FileWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User.fileUploadSessions
   */
  export type User$fileUploadSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    where?: FileUploadSessionWhereInput | $Types.Skip
    orderBy?: FileUploadSessionOrderByWithRelationInput | FileUploadSessionOrderByWithRelationInput[] | $Types.Skip
    cursor?: FileUploadSessionWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: FileUploadSessionScalarFieldEnum | FileUploadSessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User.sentInvitations
   */
  export type User$sentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    orderBy?: WorkspaceUserInvitationOrderByWithRelationInput | WorkspaceUserInvitationOrderByWithRelationInput[] | $Types.Skip
    cursor?: WorkspaceUserInvitationWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: WorkspaceUserInvitationScalarFieldEnum | WorkspaceUserInvitationScalarFieldEnum[] | $Types.Skip
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locale: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locale: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    locale: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferencesMinAggregateInputType = {
    id?: true | $Types.Skip
    userId?: true | $Types.Skip
    locale?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true | $Types.Skip
    userId?: true | $Types.Skip
    locale?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true | $Types.Skip
    userId?: true | $Types.Skip
    locale?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput | $Types.Skip
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[] | $Types.Skip
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: UserPreferencesCountAggregateInputType | true
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: string
    userId: string
    locale: string
    createdAt: Date
    updatedAt: Date
    _count: UserPreferencesCountAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    locale?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    locale?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    locale?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean | $Types.Skip
    userId?: boolean | $Types.Skip
    locale?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locale" | "createdAt" | "updatedAt", ExtArgs["result"]["userPreferences"], $Types.Skip>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locale: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly userId: FieldRef<"UserPreferences", 'String'>
    readonly locale: FieldRef<"UserPreferences", 'String'>
    readonly createdAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[] | $Types.Skip
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[] | $Types.Skip
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number | $Types.Skip
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[] | $Types.Skip
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput | $Types.Skip
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput | $Types.Skip
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput | $Types.Skip
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model UserWorkspace
   */

  export type AggregateUserWorkspace = {
    _count: UserWorkspaceCountAggregateOutputType | null
    _min: UserWorkspaceMinAggregateOutputType | null
    _max: UserWorkspaceMaxAggregateOutputType | null
  }

  export type UserWorkspaceMinAggregateOutputType = {
    userId: string | null
    workspaceId: string | null
    workspaceInvitationId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserWorkspaceMaxAggregateOutputType = {
    userId: string | null
    workspaceId: string | null
    workspaceInvitationId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserWorkspaceCountAggregateOutputType = {
    userId: number
    workspaceId: number
    workspaceInvitationId: number
    role: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserWorkspaceMinAggregateInputType = {
    userId?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    workspaceInvitationId?: true | $Types.Skip
    role?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type UserWorkspaceMaxAggregateInputType = {
    userId?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    workspaceInvitationId?: true | $Types.Skip
    role?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type UserWorkspaceCountAggregateInputType = {
    userId?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    workspaceInvitationId?: true | $Types.Skip
    role?: true | $Types.Skip
    permissions?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type UserWorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWorkspace to aggregate.
     */
    where?: UserWorkspaceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWorkspaces to fetch.
     */
    orderBy?: UserWorkspaceOrderByWithRelationInput | UserWorkspaceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWorkspaceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWorkspaces from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWorkspaces.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserWorkspaces
    **/
    _count?: true | UserWorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserWorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserWorkspaceMaxAggregateInputType
  }

  export type GetUserWorkspaceAggregateType<T extends UserWorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserWorkspace[P]>
      : GetScalarType<T[P], AggregateUserWorkspace[P]>
  }




  export type UserWorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWorkspaceWhereInput | $Types.Skip
    orderBy?: UserWorkspaceOrderByWithAggregationInput | UserWorkspaceOrderByWithAggregationInput[] | $Types.Skip
    by: UserWorkspaceScalarFieldEnum[] | UserWorkspaceScalarFieldEnum
    having?: UserWorkspaceScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: UserWorkspaceCountAggregateInputType | true
    _min?: UserWorkspaceMinAggregateInputType
    _max?: UserWorkspaceMaxAggregateInputType
  }

  export type UserWorkspaceGroupByOutputType = {
    userId: string
    workspaceId: string
    workspaceInvitationId: string | null
    role: string
    permissions: string[]
    createdAt: Date
    updatedAt: Date
    _count: UserWorkspaceCountAggregateOutputType | null
    _min: UserWorkspaceMinAggregateOutputType | null
    _max: UserWorkspaceMaxAggregateOutputType | null
  }

  type GetUserWorkspaceGroupByPayload<T extends UserWorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserWorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserWorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserWorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], UserWorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type UserWorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    workspaceInvitationId?: boolean | $Types.Skip
    role?: boolean | $Types.Skip
    permissions?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    workspaceInvitation?: boolean | UserWorkspace$workspaceInvitationArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["userWorkspace"]>

  export type UserWorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    workspaceInvitationId?: boolean | $Types.Skip
    role?: boolean | $Types.Skip
    permissions?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    workspaceInvitation?: boolean | UserWorkspace$workspaceInvitationArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["userWorkspace"]>

  export type UserWorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    workspaceInvitationId?: boolean | $Types.Skip
    role?: boolean | $Types.Skip
    permissions?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    workspaceInvitation?: boolean | UserWorkspace$workspaceInvitationArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["userWorkspace"]>

  export type UserWorkspaceSelectScalar = {
    userId?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    workspaceInvitationId?: boolean | $Types.Skip
    role?: boolean | $Types.Skip
    permissions?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }

  export type UserWorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "workspaceId" | "workspaceInvitationId" | "role" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["userWorkspace"], $Types.Skip>
  export type UserWorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    workspaceInvitation?: boolean | UserWorkspace$workspaceInvitationArgs<ExtArgs> | $Types.Skip
  }
  export type UserWorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    workspaceInvitation?: boolean | UserWorkspace$workspaceInvitationArgs<ExtArgs> | $Types.Skip
  }
  export type UserWorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs> | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    workspaceInvitation?: boolean | UserWorkspace$workspaceInvitationArgs<ExtArgs> | $Types.Skip
  }

  export type $UserWorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserWorkspace"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      workspaceInvitation: Prisma.$WorkspaceUserInvitationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      workspaceId: string
      workspaceInvitationId: string | null
      role: string
      permissions: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userWorkspace"]>
    composites: {}
  }

  type UserWorkspaceGetPayload<S extends boolean | null | undefined | UserWorkspaceDefaultArgs> = $Result.GetResult<Prisma.$UserWorkspacePayload, S>

  type UserWorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserWorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserWorkspaceCountAggregateInputType | true
    }

  export interface UserWorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserWorkspace'], meta: { name: 'UserWorkspace' } }
    /**
     * Find zero or one UserWorkspace that matches the filter.
     * @param {UserWorkspaceFindUniqueArgs} args - Arguments to find a UserWorkspace
     * @example
     * // Get one UserWorkspace
     * const userWorkspace = await prisma.userWorkspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserWorkspaceFindUniqueArgs>(args: SelectSubset<T, UserWorkspaceFindUniqueArgs<ExtArgs>>): Prisma__UserWorkspaceClient<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserWorkspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserWorkspaceFindUniqueOrThrowArgs} args - Arguments to find a UserWorkspace
     * @example
     * // Get one UserWorkspace
     * const userWorkspace = await prisma.userWorkspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserWorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserWorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserWorkspaceClient<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserWorkspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWorkspaceFindFirstArgs} args - Arguments to find a UserWorkspace
     * @example
     * // Get one UserWorkspace
     * const userWorkspace = await prisma.userWorkspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserWorkspaceFindFirstArgs>(args?: SelectSubset<T, UserWorkspaceFindFirstArgs<ExtArgs>>): Prisma__UserWorkspaceClient<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserWorkspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWorkspaceFindFirstOrThrowArgs} args - Arguments to find a UserWorkspace
     * @example
     * // Get one UserWorkspace
     * const userWorkspace = await prisma.userWorkspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserWorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserWorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserWorkspaceClient<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserWorkspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserWorkspaces
     * const userWorkspaces = await prisma.userWorkspace.findMany()
     * 
     * // Get first 10 UserWorkspaces
     * const userWorkspaces = await prisma.userWorkspace.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userWorkspaceWithUserIdOnly = await prisma.userWorkspace.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserWorkspaceFindManyArgs>(args?: SelectSubset<T, UserWorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserWorkspace.
     * @param {UserWorkspaceCreateArgs} args - Arguments to create a UserWorkspace.
     * @example
     * // Create one UserWorkspace
     * const UserWorkspace = await prisma.userWorkspace.create({
     *   data: {
     *     // ... data to create a UserWorkspace
     *   }
     * })
     * 
     */
    create<T extends UserWorkspaceCreateArgs>(args: SelectSubset<T, UserWorkspaceCreateArgs<ExtArgs>>): Prisma__UserWorkspaceClient<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserWorkspaces.
     * @param {UserWorkspaceCreateManyArgs} args - Arguments to create many UserWorkspaces.
     * @example
     * // Create many UserWorkspaces
     * const userWorkspace = await prisma.userWorkspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserWorkspaceCreateManyArgs>(args?: SelectSubset<T, UserWorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserWorkspaces and returns the data saved in the database.
     * @param {UserWorkspaceCreateManyAndReturnArgs} args - Arguments to create many UserWorkspaces.
     * @example
     * // Create many UserWorkspaces
     * const userWorkspace = await prisma.userWorkspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserWorkspaces and only return the `userId`
     * const userWorkspaceWithUserIdOnly = await prisma.userWorkspace.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserWorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserWorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserWorkspace.
     * @param {UserWorkspaceDeleteArgs} args - Arguments to delete one UserWorkspace.
     * @example
     * // Delete one UserWorkspace
     * const UserWorkspace = await prisma.userWorkspace.delete({
     *   where: {
     *     // ... filter to delete one UserWorkspace
     *   }
     * })
     * 
     */
    delete<T extends UserWorkspaceDeleteArgs>(args: SelectSubset<T, UserWorkspaceDeleteArgs<ExtArgs>>): Prisma__UserWorkspaceClient<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserWorkspace.
     * @param {UserWorkspaceUpdateArgs} args - Arguments to update one UserWorkspace.
     * @example
     * // Update one UserWorkspace
     * const userWorkspace = await prisma.userWorkspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserWorkspaceUpdateArgs>(args: SelectSubset<T, UserWorkspaceUpdateArgs<ExtArgs>>): Prisma__UserWorkspaceClient<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserWorkspaces.
     * @param {UserWorkspaceDeleteManyArgs} args - Arguments to filter UserWorkspaces to delete.
     * @example
     * // Delete a few UserWorkspaces
     * const { count } = await prisma.userWorkspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserWorkspaceDeleteManyArgs>(args?: SelectSubset<T, UserWorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWorkspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserWorkspaces
     * const userWorkspace = await prisma.userWorkspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserWorkspaceUpdateManyArgs>(args: SelectSubset<T, UserWorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWorkspaces and returns the data updated in the database.
     * @param {UserWorkspaceUpdateManyAndReturnArgs} args - Arguments to update many UserWorkspaces.
     * @example
     * // Update many UserWorkspaces
     * const userWorkspace = await prisma.userWorkspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserWorkspaces and only return the `userId`
     * const userWorkspaceWithUserIdOnly = await prisma.userWorkspace.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserWorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserWorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserWorkspace.
     * @param {UserWorkspaceUpsertArgs} args - Arguments to update or create a UserWorkspace.
     * @example
     * // Update or create a UserWorkspace
     * const userWorkspace = await prisma.userWorkspace.upsert({
     *   create: {
     *     // ... data to create a UserWorkspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserWorkspace we want to update
     *   }
     * })
     */
    upsert<T extends UserWorkspaceUpsertArgs>(args: SelectSubset<T, UserWorkspaceUpsertArgs<ExtArgs>>): Prisma__UserWorkspaceClient<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserWorkspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWorkspaceCountArgs} args - Arguments to filter UserWorkspaces to count.
     * @example
     * // Count the number of UserWorkspaces
     * const count = await prisma.userWorkspace.count({
     *   where: {
     *     // ... the filter for the UserWorkspaces we want to count
     *   }
     * })
    **/
    count<T extends UserWorkspaceCountArgs>(
      args?: Subset<T, UserWorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserWorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserWorkspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserWorkspaceAggregateArgs>(args: Subset<T, UserWorkspaceAggregateArgs>): Prisma.PrismaPromise<GetUserWorkspaceAggregateType<T>>

    /**
     * Group by UserWorkspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserWorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserWorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: UserWorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserWorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserWorkspace model
   */
  readonly fields: UserWorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserWorkspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserWorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspaceInvitation<T extends UserWorkspace$workspaceInvitationArgs<ExtArgs> = {}>(args?: Subset<T, UserWorkspace$workspaceInvitationArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserWorkspace model
   */
  interface UserWorkspaceFieldRefs {
    readonly userId: FieldRef<"UserWorkspace", 'String'>
    readonly workspaceId: FieldRef<"UserWorkspace", 'String'>
    readonly workspaceInvitationId: FieldRef<"UserWorkspace", 'String'>
    readonly role: FieldRef<"UserWorkspace", 'String'>
    readonly permissions: FieldRef<"UserWorkspace", 'String[]'>
    readonly createdAt: FieldRef<"UserWorkspace", 'DateTime'>
    readonly updatedAt: FieldRef<"UserWorkspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserWorkspace findUnique
   */
  export type UserWorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which UserWorkspace to fetch.
     */
    where: UserWorkspaceWhereUniqueInput
  }

  /**
   * UserWorkspace findUniqueOrThrow
   */
  export type UserWorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which UserWorkspace to fetch.
     */
    where: UserWorkspaceWhereUniqueInput
  }

  /**
   * UserWorkspace findFirst
   */
  export type UserWorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which UserWorkspace to fetch.
     */
    where?: UserWorkspaceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWorkspaces to fetch.
     */
    orderBy?: UserWorkspaceOrderByWithRelationInput | UserWorkspaceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWorkspaces.
     */
    cursor?: UserWorkspaceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWorkspaces from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWorkspaces.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWorkspaces.
     */
    distinct?: UserWorkspaceScalarFieldEnum | UserWorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * UserWorkspace findFirstOrThrow
   */
  export type UserWorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which UserWorkspace to fetch.
     */
    where?: UserWorkspaceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWorkspaces to fetch.
     */
    orderBy?: UserWorkspaceOrderByWithRelationInput | UserWorkspaceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWorkspaces.
     */
    cursor?: UserWorkspaceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWorkspaces from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWorkspaces.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWorkspaces.
     */
    distinct?: UserWorkspaceScalarFieldEnum | UserWorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * UserWorkspace findMany
   */
  export type UserWorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which UserWorkspaces to fetch.
     */
    where?: UserWorkspaceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWorkspaces to fetch.
     */
    orderBy?: UserWorkspaceOrderByWithRelationInput | UserWorkspaceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserWorkspaces.
     */
    cursor?: UserWorkspaceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWorkspaces from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWorkspaces.
     */
    skip?: number | $Types.Skip
    distinct?: UserWorkspaceScalarFieldEnum | UserWorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * UserWorkspace create
   */
  export type UserWorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserWorkspace.
     */
    data: XOR<UserWorkspaceCreateInput, UserWorkspaceUncheckedCreateInput>
  }

  /**
   * UserWorkspace createMany
   */
  export type UserWorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserWorkspaces.
     */
    data: UserWorkspaceCreateManyInput | UserWorkspaceCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * UserWorkspace createManyAndReturn
   */
  export type UserWorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many UserWorkspaces.
     */
    data: UserWorkspaceCreateManyInput | UserWorkspaceCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWorkspace update
   */
  export type UserWorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserWorkspace.
     */
    data: XOR<UserWorkspaceUpdateInput, UserWorkspaceUncheckedUpdateInput>
    /**
     * Choose, which UserWorkspace to update.
     */
    where: UserWorkspaceWhereUniqueInput
  }

  /**
   * UserWorkspace updateMany
   */
  export type UserWorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserWorkspaces.
     */
    data: XOR<UserWorkspaceUpdateManyMutationInput, UserWorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which UserWorkspaces to update
     */
    where?: UserWorkspaceWhereInput | $Types.Skip
    /**
     * Limit how many UserWorkspaces to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * UserWorkspace updateManyAndReturn
   */
  export type UserWorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update UserWorkspaces.
     */
    data: XOR<UserWorkspaceUpdateManyMutationInput, UserWorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which UserWorkspaces to update
     */
    where?: UserWorkspaceWhereInput | $Types.Skip
    /**
     * Limit how many UserWorkspaces to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWorkspace upsert
   */
  export type UserWorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserWorkspace to update in case it exists.
     */
    where: UserWorkspaceWhereUniqueInput
    /**
     * In case the UserWorkspace found by the `where` argument doesn't exist, create a new UserWorkspace with this data.
     */
    create: XOR<UserWorkspaceCreateInput, UserWorkspaceUncheckedCreateInput>
    /**
     * In case the UserWorkspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserWorkspaceUpdateInput, UserWorkspaceUncheckedUpdateInput>
  }

  /**
   * UserWorkspace delete
   */
  export type UserWorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    /**
     * Filter which UserWorkspace to delete.
     */
    where: UserWorkspaceWhereUniqueInput
  }

  /**
   * UserWorkspace deleteMany
   */
  export type UserWorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWorkspaces to delete
     */
    where?: UserWorkspaceWhereInput | $Types.Skip
    /**
     * Limit how many UserWorkspaces to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * UserWorkspace.workspaceInvitation
   */
  export type UserWorkspace$workspaceInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
  }

  /**
   * UserWorkspace without action
   */
  export type UserWorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    status: string | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    status: string | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    status: number
    picture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    slug?: true | $Types.Skip
    status?: true | $Types.Skip
    picture?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    slug?: true | $Types.Skip
    status?: true | $Types.Skip
    picture?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true | $Types.Skip
    name?: true | $Types.Skip
    slug?: true | $Types.Skip
    status?: true | $Types.Skip
    picture?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput | $Types.Skip
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[] | $Types.Skip
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    slug: string
    status: string
    picture: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    slug?: boolean | $Types.Skip
    status?: boolean | $Types.Skip
    picture?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    members?: boolean | Workspace$membersArgs<ExtArgs> | $Types.Skip
    screens?: boolean | Workspace$screensArgs<ExtArgs> | $Types.Skip
    playlists?: boolean | Workspace$playlistsArgs<ExtArgs> | $Types.Skip
    layouts?: boolean | Workspace$layoutsArgs<ExtArgs> | $Types.Skip
    files?: boolean | Workspace$filesArgs<ExtArgs> | $Types.Skip
    folders?: boolean | Workspace$foldersArgs<ExtArgs> | $Types.Skip
    fileUploadSessions?: boolean | Workspace$fileUploadSessionsArgs<ExtArgs> | $Types.Skip
    userInvitations?: boolean | Workspace$userInvitationsArgs<ExtArgs> | $Types.Skip
    screenGroups?: boolean | Workspace$screenGroupsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    slug?: boolean | $Types.Skip
    status?: boolean | $Types.Skip
    picture?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    slug?: boolean | $Types.Skip
    status?: boolean | $Types.Skip
    picture?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean | $Types.Skip
    name?: boolean | $Types.Skip
    slug?: boolean | $Types.Skip
    status?: boolean | $Types.Skip
    picture?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }

  export type WorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "status" | "picture" | "createdAt" | "updatedAt", ExtArgs["result"]["workspace"], $Types.Skip>
  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Workspace$membersArgs<ExtArgs> | $Types.Skip
    screens?: boolean | Workspace$screensArgs<ExtArgs> | $Types.Skip
    playlists?: boolean | Workspace$playlistsArgs<ExtArgs> | $Types.Skip
    layouts?: boolean | Workspace$layoutsArgs<ExtArgs> | $Types.Skip
    files?: boolean | Workspace$filesArgs<ExtArgs> | $Types.Skip
    folders?: boolean | Workspace$foldersArgs<ExtArgs> | $Types.Skip
    fileUploadSessions?: boolean | Workspace$fileUploadSessionsArgs<ExtArgs> | $Types.Skip
    userInvitations?: boolean | Workspace$userInvitationsArgs<ExtArgs> | $Types.Skip
    screenGroups?: boolean | Workspace$screenGroupsArgs<ExtArgs> | $Types.Skip
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      members: Prisma.$UserWorkspacePayload<ExtArgs>[]
      screens: Prisma.$ScreenPayload<ExtArgs>[]
      playlists: Prisma.$PlaylistPayload<ExtArgs>[]
      layouts: Prisma.$PlaylistLayoutPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      folders: Prisma.$FolderPayload<ExtArgs>[]
      fileUploadSessions: Prisma.$FileUploadSessionPayload<ExtArgs>[]
      userInvitations: Prisma.$WorkspaceUserInvitationPayload<ExtArgs>[]
      screenGroups: Prisma.$ScreenGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      status: string
      picture: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces and returns the data updated in the database.
     * @param {WorkspaceUpdateManyAndReturnArgs} args - Arguments to update many Workspaces.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Workspace$membersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    screens<T extends Workspace$screensArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$screensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playlists<T extends Workspace$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    layouts<T extends Workspace$layoutsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$layoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistLayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Workspace$filesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folders<T extends Workspace$foldersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$foldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileUploadSessions<T extends Workspace$fileUploadSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$fileUploadSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileUploadSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userInvitations<T extends Workspace$userInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$userInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    screenGroups<T extends Workspace$screenGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$screenGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly slug: FieldRef<"Workspace", 'String'>
    readonly status: FieldRef<"Workspace", 'String'>
    readonly picture: FieldRef<"Workspace", 'String'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number | $Types.Skip
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput | $Types.Skip
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Workspace updateManyAndReturn
   */
  export type WorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput | $Types.Skip
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput | $Types.Skip
    /**
     * Limit how many Workspaces to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * Workspace.members
   */
  export type Workspace$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    where?: UserWorkspaceWhereInput | $Types.Skip
    orderBy?: UserWorkspaceOrderByWithRelationInput | UserWorkspaceOrderByWithRelationInput[] | $Types.Skip
    cursor?: UserWorkspaceWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: UserWorkspaceScalarFieldEnum | UserWorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace.screens
   */
  export type Workspace$screensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screen
     */
    select?: ScreenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screen
     */
    omit?: ScreenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenInclude<ExtArgs> | null
    where?: ScreenWhereInput | $Types.Skip
    orderBy?: ScreenOrderByWithRelationInput | ScreenOrderByWithRelationInput[] | $Types.Skip
    cursor?: ScreenWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: ScreenScalarFieldEnum | ScreenScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace.playlists
   */
  export type Workspace$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput | $Types.Skip
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace.layouts
   */
  export type Workspace$layoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistLayout
     */
    select?: PlaylistLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistLayout
     */
    omit?: PlaylistLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistLayoutInclude<ExtArgs> | null
    where?: PlaylistLayoutWhereInput | $Types.Skip
    orderBy?: PlaylistLayoutOrderByWithRelationInput | PlaylistLayoutOrderByWithRelationInput[] | $Types.Skip
    cursor?: PlaylistLayoutWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: PlaylistLayoutScalarFieldEnum | PlaylistLayoutScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace.files
   */
  export type Workspace$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput | $Types.Skip
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[] | $Types.Skip
    cursor?: FileWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace.folders
   */
  export type Workspace$foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput | $Types.Skip
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[] | $Types.Skip
    cursor?: FolderWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace.fileUploadSessions
   */
  export type Workspace$fileUploadSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileUploadSession
     */
    select?: FileUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileUploadSession
     */
    omit?: FileUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileUploadSessionInclude<ExtArgs> | null
    where?: FileUploadSessionWhereInput | $Types.Skip
    orderBy?: FileUploadSessionOrderByWithRelationInput | FileUploadSessionOrderByWithRelationInput[] | $Types.Skip
    cursor?: FileUploadSessionWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: FileUploadSessionScalarFieldEnum | FileUploadSessionScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace.userInvitations
   */
  export type Workspace$userInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    orderBy?: WorkspaceUserInvitationOrderByWithRelationInput | WorkspaceUserInvitationOrderByWithRelationInput[] | $Types.Skip
    cursor?: WorkspaceUserInvitationWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: WorkspaceUserInvitationScalarFieldEnum | WorkspaceUserInvitationScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace.screenGroups
   */
  export type Workspace$screenGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScreenGroup
     */
    select?: ScreenGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScreenGroup
     */
    omit?: ScreenGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenGroupInclude<ExtArgs> | null
    where?: ScreenGroupWhereInput | $Types.Skip
    orderBy?: ScreenGroupOrderByWithRelationInput | ScreenGroupOrderByWithRelationInput[] | $Types.Skip
    cursor?: ScreenGroupWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: ScreenGroupScalarFieldEnum | ScreenGroupScalarFieldEnum[] | $Types.Skip
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceUserInvitation
   */

  export type AggregateWorkspaceUserInvitation = {
    _count: WorkspaceUserInvitationCountAggregateOutputType | null
    _min: WorkspaceUserInvitationMinAggregateOutputType | null
    _max: WorkspaceUserInvitationMaxAggregateOutputType | null
  }

  export type WorkspaceUserInvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    status: string | null
    workspaceId: string | null
    invitorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceUserInvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    status: string | null
    workspaceId: string | null
    invitorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceUserInvitationCountAggregateOutputType = {
    id: number
    email: number
    status: number
    workspaceId: number
    invitorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceUserInvitationMinAggregateInputType = {
    id?: true | $Types.Skip
    email?: true | $Types.Skip
    status?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    invitorId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type WorkspaceUserInvitationMaxAggregateInputType = {
    id?: true | $Types.Skip
    email?: true | $Types.Skip
    status?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    invitorId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
  }

  export type WorkspaceUserInvitationCountAggregateInputType = {
    id?: true | $Types.Skip
    email?: true | $Types.Skip
    status?: true | $Types.Skip
    workspaceId?: true | $Types.Skip
    invitorId?: true | $Types.Skip
    createdAt?: true | $Types.Skip
    updatedAt?: true | $Types.Skip
    _all?: true | $Types.Skip
  }

  export type WorkspaceUserInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUserInvitation to aggregate.
     */
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUserInvitations to fetch.
     */
    orderBy?: WorkspaceUserInvitationOrderByWithRelationInput | WorkspaceUserInvitationOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceUserInvitationWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUserInvitations from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUserInvitations.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceUserInvitations
    **/
    _count?: true | WorkspaceUserInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceUserInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceUserInvitationMaxAggregateInputType
  }

  export type GetWorkspaceUserInvitationAggregateType<T extends WorkspaceUserInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceUserInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceUserInvitation[P]>
      : GetScalarType<T[P], AggregateWorkspaceUserInvitation[P]>
  }




  export type WorkspaceUserInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    orderBy?: WorkspaceUserInvitationOrderByWithAggregationInput | WorkspaceUserInvitationOrderByWithAggregationInput[] | $Types.Skip
    by: WorkspaceUserInvitationScalarFieldEnum[] | WorkspaceUserInvitationScalarFieldEnum
    having?: WorkspaceUserInvitationScalarWhereWithAggregatesInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    _count?: WorkspaceUserInvitationCountAggregateInputType | true
    _min?: WorkspaceUserInvitationMinAggregateInputType
    _max?: WorkspaceUserInvitationMaxAggregateInputType
  }

  export type WorkspaceUserInvitationGroupByOutputType = {
    id: string
    email: string
    status: string
    workspaceId: string
    invitorId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceUserInvitationCountAggregateOutputType | null
    _min: WorkspaceUserInvitationMinAggregateOutputType | null
    _max: WorkspaceUserInvitationMaxAggregateOutputType | null
  }

  type GetWorkspaceUserInvitationGroupByPayload<T extends WorkspaceUserInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceUserInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceUserInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceUserInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceUserInvitationGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceUserInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    email?: boolean | $Types.Skip
    status?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    invitorId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    invitor?: boolean | WorkspaceUserInvitation$invitorArgs<ExtArgs> | $Types.Skip
    members?: boolean | WorkspaceUserInvitation$membersArgs<ExtArgs> | $Types.Skip
    _count?: boolean | WorkspaceUserInvitationCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["workspaceUserInvitation"]>

  export type WorkspaceUserInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    email?: boolean | $Types.Skip
    status?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    invitorId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    invitor?: boolean | WorkspaceUserInvitation$invitorArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["workspaceUserInvitation"]>

  export type WorkspaceUserInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean | $Types.Skip
    email?: boolean | $Types.Skip
    status?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    invitorId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    invitor?: boolean | WorkspaceUserInvitation$invitorArgs<ExtArgs> | $Types.Skip
  }, ExtArgs["result"]["workspaceUserInvitation"]>

  export type WorkspaceUserInvitationSelectScalar = {
    id?: boolean | $Types.Skip
    email?: boolean | $Types.Skip
    status?: boolean | $Types.Skip
    workspaceId?: boolean | $Types.Skip
    invitorId?: boolean | $Types.Skip
    createdAt?: boolean | $Types.Skip
    updatedAt?: boolean | $Types.Skip
  }

  export type WorkspaceUserInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "status" | "workspaceId" | "invitorId" | "createdAt" | "updatedAt", ExtArgs["result"]["workspaceUserInvitation"], $Types.Skip>
  export type WorkspaceUserInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    invitor?: boolean | WorkspaceUserInvitation$invitorArgs<ExtArgs> | $Types.Skip
    members?: boolean | WorkspaceUserInvitation$membersArgs<ExtArgs> | $Types.Skip
    _count?: boolean | WorkspaceUserInvitationCountOutputTypeDefaultArgs<ExtArgs> | $Types.Skip
  }
  export type WorkspaceUserInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    invitor?: boolean | WorkspaceUserInvitation$invitorArgs<ExtArgs> | $Types.Skip
  }
  export type WorkspaceUserInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs> | $Types.Skip
    invitor?: boolean | WorkspaceUserInvitation$invitorArgs<ExtArgs> | $Types.Skip
  }

  export type $WorkspaceUserInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceUserInvitation"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      invitor: Prisma.$UserPayload<ExtArgs> | null
      members: Prisma.$UserWorkspacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      status: string
      workspaceId: string
      invitorId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspaceUserInvitation"]>
    composites: {}
  }

  type WorkspaceUserInvitationGetPayload<S extends boolean | null | undefined | WorkspaceUserInvitationDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceUserInvitationPayload, S>

  type WorkspaceUserInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceUserInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceUserInvitationCountAggregateInputType | true
    }

  export interface WorkspaceUserInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceUserInvitation'], meta: { name: 'WorkspaceUserInvitation' } }
    /**
     * Find zero or one WorkspaceUserInvitation that matches the filter.
     * @param {WorkspaceUserInvitationFindUniqueArgs} args - Arguments to find a WorkspaceUserInvitation
     * @example
     * // Get one WorkspaceUserInvitation
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceUserInvitationFindUniqueArgs>(args: SelectSubset<T, WorkspaceUserInvitationFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceUserInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceUserInvitationFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceUserInvitation
     * @example
     * // Get one WorkspaceUserInvitation
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceUserInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceUserInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUserInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserInvitationFindFirstArgs} args - Arguments to find a WorkspaceUserInvitation
     * @example
     * // Get one WorkspaceUserInvitation
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceUserInvitationFindFirstArgs>(args?: SelectSubset<T, WorkspaceUserInvitationFindFirstArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUserInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserInvitationFindFirstOrThrowArgs} args - Arguments to find a WorkspaceUserInvitation
     * @example
     * // Get one WorkspaceUserInvitation
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceUserInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceUserInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceUserInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceUserInvitations
     * const workspaceUserInvitations = await prisma.workspaceUserInvitation.findMany()
     * 
     * // Get first 10 WorkspaceUserInvitations
     * const workspaceUserInvitations = await prisma.workspaceUserInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceUserInvitationWithIdOnly = await prisma.workspaceUserInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceUserInvitationFindManyArgs>(args?: SelectSubset<T, WorkspaceUserInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceUserInvitation.
     * @param {WorkspaceUserInvitationCreateArgs} args - Arguments to create a WorkspaceUserInvitation.
     * @example
     * // Create one WorkspaceUserInvitation
     * const WorkspaceUserInvitation = await prisma.workspaceUserInvitation.create({
     *   data: {
     *     // ... data to create a WorkspaceUserInvitation
     *   }
     * })
     * 
     */
    create<T extends WorkspaceUserInvitationCreateArgs>(args: SelectSubset<T, WorkspaceUserInvitationCreateArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceUserInvitations.
     * @param {WorkspaceUserInvitationCreateManyArgs} args - Arguments to create many WorkspaceUserInvitations.
     * @example
     * // Create many WorkspaceUserInvitations
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceUserInvitationCreateManyArgs>(args?: SelectSubset<T, WorkspaceUserInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceUserInvitations and returns the data saved in the database.
     * @param {WorkspaceUserInvitationCreateManyAndReturnArgs} args - Arguments to create many WorkspaceUserInvitations.
     * @example
     * // Create many WorkspaceUserInvitations
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceUserInvitations and only return the `id`
     * const workspaceUserInvitationWithIdOnly = await prisma.workspaceUserInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceUserInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceUserInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceUserInvitation.
     * @param {WorkspaceUserInvitationDeleteArgs} args - Arguments to delete one WorkspaceUserInvitation.
     * @example
     * // Delete one WorkspaceUserInvitation
     * const WorkspaceUserInvitation = await prisma.workspaceUserInvitation.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceUserInvitation
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceUserInvitationDeleteArgs>(args: SelectSubset<T, WorkspaceUserInvitationDeleteArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceUserInvitation.
     * @param {WorkspaceUserInvitationUpdateArgs} args - Arguments to update one WorkspaceUserInvitation.
     * @example
     * // Update one WorkspaceUserInvitation
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUserInvitationUpdateArgs>(args: SelectSubset<T, WorkspaceUserInvitationUpdateArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceUserInvitations.
     * @param {WorkspaceUserInvitationDeleteManyArgs} args - Arguments to filter WorkspaceUserInvitations to delete.
     * @example
     * // Delete a few WorkspaceUserInvitations
     * const { count } = await prisma.workspaceUserInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceUserInvitationDeleteManyArgs>(args?: SelectSubset<T, WorkspaceUserInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceUserInvitations
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUserInvitationUpdateManyArgs>(args: SelectSubset<T, WorkspaceUserInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUserInvitations and returns the data updated in the database.
     * @param {WorkspaceUserInvitationUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceUserInvitations.
     * @example
     * // Update many WorkspaceUserInvitations
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceUserInvitations and only return the `id`
     * const workspaceUserInvitationWithIdOnly = await prisma.workspaceUserInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUserInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUserInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceUserInvitation.
     * @param {WorkspaceUserInvitationUpsertArgs} args - Arguments to update or create a WorkspaceUserInvitation.
     * @example
     * // Update or create a WorkspaceUserInvitation
     * const workspaceUserInvitation = await prisma.workspaceUserInvitation.upsert({
     *   create: {
     *     // ... data to create a WorkspaceUserInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceUserInvitation we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUserInvitationUpsertArgs>(args: SelectSubset<T, WorkspaceUserInvitationUpsertArgs<ExtArgs>>): Prisma__WorkspaceUserInvitationClient<$Result.GetResult<Prisma.$WorkspaceUserInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceUserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserInvitationCountArgs} args - Arguments to filter WorkspaceUserInvitations to count.
     * @example
     * // Count the number of WorkspaceUserInvitations
     * const count = await prisma.workspaceUserInvitation.count({
     *   where: {
     *     // ... the filter for the WorkspaceUserInvitations we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceUserInvitationCountArgs>(
      args?: Subset<T, WorkspaceUserInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceUserInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceUserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceUserInvitationAggregateArgs>(args: Subset<T, WorkspaceUserInvitationAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceUserInvitationAggregateType<T>>

    /**
     * Group by WorkspaceUserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceUserInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceUserInvitationGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceUserInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceUserInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceUserInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceUserInvitation model
   */
  readonly fields: WorkspaceUserInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceUserInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceUserInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitor<T extends WorkspaceUserInvitation$invitorArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceUserInvitation$invitorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends WorkspaceUserInvitation$membersArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceUserInvitation$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceUserInvitation model
   */
  interface WorkspaceUserInvitationFieldRefs {
    readonly id: FieldRef<"WorkspaceUserInvitation", 'String'>
    readonly email: FieldRef<"WorkspaceUserInvitation", 'String'>
    readonly status: FieldRef<"WorkspaceUserInvitation", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceUserInvitation", 'String'>
    readonly invitorId: FieldRef<"WorkspaceUserInvitation", 'String'>
    readonly createdAt: FieldRef<"WorkspaceUserInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkspaceUserInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceUserInvitation findUnique
   */
  export type WorkspaceUserInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserInvitation to fetch.
     */
    where: WorkspaceUserInvitationWhereUniqueInput
  }

  /**
   * WorkspaceUserInvitation findUniqueOrThrow
   */
  export type WorkspaceUserInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserInvitation to fetch.
     */
    where: WorkspaceUserInvitationWhereUniqueInput
  }

  /**
   * WorkspaceUserInvitation findFirst
   */
  export type WorkspaceUserInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserInvitation to fetch.
     */
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUserInvitations to fetch.
     */
    orderBy?: WorkspaceUserInvitationOrderByWithRelationInput | WorkspaceUserInvitationOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUserInvitations.
     */
    cursor?: WorkspaceUserInvitationWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUserInvitations from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUserInvitations.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUserInvitations.
     */
    distinct?: WorkspaceUserInvitationScalarFieldEnum | WorkspaceUserInvitationScalarFieldEnum[] | $Types.Skip
  }

  /**
   * WorkspaceUserInvitation findFirstOrThrow
   */
  export type WorkspaceUserInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserInvitation to fetch.
     */
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUserInvitations to fetch.
     */
    orderBy?: WorkspaceUserInvitationOrderByWithRelationInput | WorkspaceUserInvitationOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUserInvitations.
     */
    cursor?: WorkspaceUserInvitationWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUserInvitations from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUserInvitations.
     */
    skip?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUserInvitations.
     */
    distinct?: WorkspaceUserInvitationScalarFieldEnum | WorkspaceUserInvitationScalarFieldEnum[] | $Types.Skip
  }

  /**
   * WorkspaceUserInvitation findMany
   */
  export type WorkspaceUserInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserInvitations to fetch.
     */
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUserInvitations to fetch.
     */
    orderBy?: WorkspaceUserInvitationOrderByWithRelationInput | WorkspaceUserInvitationOrderByWithRelationInput[] | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceUserInvitations.
     */
    cursor?: WorkspaceUserInvitationWhereUniqueInput | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUserInvitations from the position of the cursor.
     */
    take?: number | $Types.Skip
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUserInvitations.
     */
    skip?: number | $Types.Skip
    distinct?: WorkspaceUserInvitationScalarFieldEnum | WorkspaceUserInvitationScalarFieldEnum[] | $Types.Skip
  }

  /**
   * WorkspaceUserInvitation create
   */
  export type WorkspaceUserInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceUserInvitation.
     */
    data: XOR<WorkspaceUserInvitationCreateInput, WorkspaceUserInvitationUncheckedCreateInput>
  }

  /**
   * WorkspaceUserInvitation createMany
   */
  export type WorkspaceUserInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceUserInvitations.
     */
    data: WorkspaceUserInvitationCreateManyInput | WorkspaceUserInvitationCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  /**
   * WorkspaceUserInvitation createManyAndReturn
   */
  export type WorkspaceUserInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceUserInvitations.
     */
    data: WorkspaceUserInvitationCreateManyInput | WorkspaceUserInvitationCreateManyInput[]
    skipDuplicates?: boolean | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUserInvitation update
   */
  export type WorkspaceUserInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceUserInvitation.
     */
    data: XOR<WorkspaceUserInvitationUpdateInput, WorkspaceUserInvitationUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceUserInvitation to update.
     */
    where: WorkspaceUserInvitationWhereUniqueInput
  }

  /**
   * WorkspaceUserInvitation updateMany
   */
  export type WorkspaceUserInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceUserInvitations.
     */
    data: XOR<WorkspaceUserInvitationUpdateManyMutationInput, WorkspaceUserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUserInvitations to update
     */
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    /**
     * Limit how many WorkspaceUserInvitations to update.
     */
    limit?: number | $Types.Skip
  }

  /**
   * WorkspaceUserInvitation updateManyAndReturn
   */
  export type WorkspaceUserInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceUserInvitations.
     */
    data: XOR<WorkspaceUserInvitationUpdateManyMutationInput, WorkspaceUserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUserInvitations to update
     */
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    /**
     * Limit how many WorkspaceUserInvitations to update.
     */
    limit?: number | $Types.Skip
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUserInvitation upsert
   */
  export type WorkspaceUserInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceUserInvitation to update in case it exists.
     */
    where: WorkspaceUserInvitationWhereUniqueInput
    /**
     * In case the WorkspaceUserInvitation found by the `where` argument doesn't exist, create a new WorkspaceUserInvitation with this data.
     */
    create: XOR<WorkspaceUserInvitationCreateInput, WorkspaceUserInvitationUncheckedCreateInput>
    /**
     * In case the WorkspaceUserInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUserInvitationUpdateInput, WorkspaceUserInvitationUncheckedUpdateInput>
  }

  /**
   * WorkspaceUserInvitation delete
   */
  export type WorkspaceUserInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceUserInvitation to delete.
     */
    where: WorkspaceUserInvitationWhereUniqueInput
  }

  /**
   * WorkspaceUserInvitation deleteMany
   */
  export type WorkspaceUserInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUserInvitations to delete
     */
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    /**
     * Limit how many WorkspaceUserInvitations to delete.
     */
    limit?: number | $Types.Skip
  }

  /**
   * WorkspaceUserInvitation.invitor
   */
  export type WorkspaceUserInvitation$invitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput | $Types.Skip
  }

  /**
   * WorkspaceUserInvitation.members
   */
  export type WorkspaceUserInvitation$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWorkspace
     */
    select?: UserWorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWorkspace
     */
    omit?: UserWorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWorkspaceInclude<ExtArgs> | null
    where?: UserWorkspaceWhereInput | $Types.Skip
    orderBy?: UserWorkspaceOrderByWithRelationInput | UserWorkspaceOrderByWithRelationInput[] | $Types.Skip
    cursor?: UserWorkspaceWhereUniqueInput | $Types.Skip
    take?: number | $Types.Skip
    skip?: number | $Types.Skip
    distinct?: UserWorkspaceScalarFieldEnum | UserWorkspaceScalarFieldEnum[] | $Types.Skip
  }

  /**
   * WorkspaceUserInvitation without action
   */
  export type WorkspaceUserInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserInvitation
     */
    select?: WorkspaceUserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserInvitation
     */
    omit?: WorkspaceUserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInvitationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    screenId: 'screenId',
    token: 'token',
    connectionCode: 'connectionCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isOnline: 'isOnline'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const DeviceStatusScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    isOnline: 'isOnline',
    createdAt: 'createdAt'
  };

  export type DeviceStatusScalarFieldEnum = (typeof DeviceStatusScalarFieldEnum)[keyof typeof DeviceStatusScalarFieldEnum]


  export const DeviceTelemetryScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    localIpAddress: 'localIpAddress',
    publicIpAddress: 'publicIpAddress',
    macAddress: 'macAddress',
    softwareVersion: 'softwareVersion',
    platform: 'platform',
    osRelease: 'osRelease',
    screenResolutionWidth: 'screenResolutionWidth',
    screenResolutionHeight: 'screenResolutionHeight',
    hostname: 'hostname',
    timezone: 'timezone',
    totalMemory: 'totalMemory',
    freeMemory: 'freeMemory',
    createdAt: 'createdAt'
  };

  export type DeviceTelemetryScalarFieldEnum = (typeof DeviceTelemetryScalarFieldEnum)[keyof typeof DeviceTelemetryScalarFieldEnum]


  export const EmailVerificationTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    newEmail: 'newEmail',
    createdAt: 'createdAt'
  };

  export type EmailVerificationTokenScalarFieldEnum = (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    extension: 'extension',
    mimeType: 'mimeType',
    previewPath: 'previewPath',
    size: 'size',
    type: 'type',
    path: 'path',
    width: 'width',
    height: 'height',
    duration: 'duration',
    defaultDuration: 'defaultDuration',
    md5: 'md5',
    folderId: 'folderId',
    availabilityStartAt: 'availabilityStartAt',
    availabilityEndAt: 'availabilityEndAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    uploaderId: 'uploaderId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const FileUploadSessionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    path: 'path',
    size: 'size',
    uploaded: 'uploaded',
    parts: 'parts',
    mimeType: 'mimeType',
    workspaceId: 'workspaceId',
    uploadId: 'uploadId',
    folderId: 'folderId',
    userId: 'userId',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type FileUploadSessionScalarFieldEnum = (typeof FileUploadSessionScalarFieldEnum)[keyof typeof FileUploadSessionScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    workspaceId: 'workspaceId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const PlaylistScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    playlistLayoutId: 'playlistLayoutId',
    name: 'name',
    description: 'description',
    size: 'size',
    type: 'type',
    isPublished: 'isPublished',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PlaylistScalarFieldEnum = (typeof PlaylistScalarFieldEnum)[keyof typeof PlaylistScalarFieldEnum]


  export const PlaylistItemScalarFieldEnum: {
    id: 'id',
    playlistId: 'playlistId',
    type: 'type',
    duration: 'duration',
    playlistLayoutSectionId: 'playlistLayoutSectionId',
    fileId: 'fileId',
    nestedPlaylistId: 'nestedPlaylistId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlaylistItemScalarFieldEnum = (typeof PlaylistItemScalarFieldEnum)[keyof typeof PlaylistItemScalarFieldEnum]


  export const PlaylistLayoutScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    resolutionWidth: 'resolutionWidth',
    resolutionHeight: 'resolutionHeight',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlaylistLayoutScalarFieldEnum = (typeof PlaylistLayoutScalarFieldEnum)[keyof typeof PlaylistLayoutScalarFieldEnum]


  export const PlaylistLayoutSectionScalarFieldEnum: {
    id: 'id',
    playlistLayoutId: 'playlistLayoutId',
    name: 'name',
    top: 'top',
    left: 'left',
    width: 'width',
    height: 'height',
    zIndex: 'zIndex'
  };

  export type PlaylistLayoutSectionScalarFieldEnum = (typeof PlaylistLayoutSectionScalarFieldEnum)[keyof typeof PlaylistLayoutSectionScalarFieldEnum]


  export const PlaylistScheduleScalarFieldEnum: {
    id: 'id',
    playlistId: 'playlistId',
    startAt: 'startAt',
    endAt: 'endAt',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    weekdays: 'weekdays'
  };

  export type PlaylistScheduleScalarFieldEnum = (typeof PlaylistScheduleScalarFieldEnum)[keyof typeof PlaylistScheduleScalarFieldEnum]


  export const PlaylistScreenScalarFieldEnum: {
    playlistId: 'playlistId',
    screenId: 'screenId'
  };

  export type PlaylistScreenScalarFieldEnum = (typeof PlaylistScreenScalarFieldEnum)[keyof typeof PlaylistScreenScalarFieldEnum]


  export const ScreenScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    groupId: 'groupId',
    name: 'name',
    layoutRotation: 'layoutRotation',
    resolutionWidth: 'resolutionWidth',
    resolutionHeight: 'resolutionHeight',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScreenScalarFieldEnum = (typeof ScreenScalarFieldEnum)[keyof typeof ScreenScalarFieldEnum]


  export const ScreenGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    workspaceId: 'workspaceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ScreenGroupScalarFieldEnum = (typeof ScreenGroupScalarFieldEnum)[keyof typeof ScreenGroupScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt',
    lastActivityAt: 'lastActivityAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerifiedAt: 'emailVerifiedAt',
    name: 'name',
    password: 'password',
    profilePhoto: 'profilePhoto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locale: 'locale',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const UserWorkspaceScalarFieldEnum: {
    userId: 'userId',
    workspaceId: 'workspaceId',
    workspaceInvitationId: 'workspaceInvitationId',
    role: 'role',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserWorkspaceScalarFieldEnum = (typeof UserWorkspaceScalarFieldEnum)[keyof typeof UserWorkspaceScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    status: 'status',
    picture: 'picture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceUserInvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    status: 'status',
    workspaceId: 'workspaceId',
    invitorId: 'invitorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceUserInvitationScalarFieldEnum = (typeof WorkspaceUserInvitationScalarFieldEnum)[keyof typeof WorkspaceUserInvitationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'PlaylistItemType'
   */
  export type EnumPlaylistItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlaylistItemType'>
    


  /**
   * Reference to a field of type 'PlaylistItemType[]'
   */
  export type ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlaylistItemType[]'>
    


  /**
   * Reference to a field of type 'Weekday[]'
   */
  export type ListEnumWeekdayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Weekday[]'>
    


  /**
   * Reference to a field of type 'Weekday'
   */
  export type EnumWeekdayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Weekday'>
    


  /**
   * Reference to a field of type 'LayoutRotation'
   */
  export type EnumLayoutRotationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LayoutRotation'>
    


  /**
   * Reference to a field of type 'LayoutRotation[]'
   */
  export type ListEnumLayoutRotationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LayoutRotation[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[] | $Types.Skip
    OR?: DeviceWhereInput[] | $Types.Skip
    NOT?: DeviceWhereInput | DeviceWhereInput[] | $Types.Skip
    id?: StringFilter<"Device"> | string | $Types.Skip
    screenId?: StringNullableFilter<"Device"> | string | null | $Types.Skip
    token?: StringFilter<"Device"> | string | $Types.Skip
    connectionCode?: StringFilter<"Device"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"Device"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Device"> | Date | string | $Types.Skip
    isOnline?: BoolFilter<"Device"> | boolean | $Types.Skip
    screen?: XOR<ScreenNullableScalarRelationFilter, ScreenWhereInput> | null | $Types.Skip
    telemetry?: DeviceTelemetryListRelationFilter | $Types.Skip
    statusLog?: DeviceStatusListRelationFilter | $Types.Skip
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    screenId?: SortOrderInput | SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    connectionCode?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
    screen?: ScreenOrderByWithRelationInput | $Types.Skip
    telemetry?: DeviceTelemetryOrderByRelationAggregateInput | $Types.Skip
    statusLog?: DeviceStatusOrderByRelationAggregateInput | $Types.Skip
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    screenId?: string | $Types.Skip
    token?: string | $Types.Skip
    connectionCode?: string | $Types.Skip
    AND?: DeviceWhereInput | DeviceWhereInput[] | $Types.Skip
    OR?: DeviceWhereInput[] | $Types.Skip
    NOT?: DeviceWhereInput | DeviceWhereInput[] | $Types.Skip
    createdAt?: DateTimeFilter<"Device"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Device"> | Date | string | $Types.Skip
    isOnline?: BoolFilter<"Device"> | boolean | $Types.Skip
    screen?: XOR<ScreenNullableScalarRelationFilter, ScreenWhereInput> | null | $Types.Skip
    telemetry?: DeviceTelemetryListRelationFilter | $Types.Skip
    statusLog?: DeviceStatusListRelationFilter | $Types.Skip
  }, "id" | "screenId" | "token" | "connectionCode">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    screenId?: SortOrderInput | SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    connectionCode?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
    _count?: DeviceCountOrderByAggregateInput | $Types.Skip
    _max?: DeviceMaxOrderByAggregateInput | $Types.Skip
    _min?: DeviceMinOrderByAggregateInput | $Types.Skip
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: DeviceScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"Device"> | string | $Types.Skip
    screenId?: StringNullableWithAggregatesFilter<"Device"> | string | null | $Types.Skip
    token?: StringWithAggregatesFilter<"Device"> | string | $Types.Skip
    connectionCode?: StringWithAggregatesFilter<"Device"> | string | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string | $Types.Skip
    isOnline?: BoolWithAggregatesFilter<"Device"> | boolean | $Types.Skip
  }

  export type DeviceStatusWhereInput = {
    AND?: DeviceStatusWhereInput | DeviceStatusWhereInput[] | $Types.Skip
    OR?: DeviceStatusWhereInput[] | $Types.Skip
    NOT?: DeviceStatusWhereInput | DeviceStatusWhereInput[] | $Types.Skip
    id?: StringFilter<"DeviceStatus"> | string | $Types.Skip
    deviceId?: StringFilter<"DeviceStatus"> | string | $Types.Skip
    isOnline?: BoolFilter<"DeviceStatus"> | boolean | $Types.Skip
    createdAt?: DateTimeFilter<"DeviceStatus"> | Date | string | $Types.Skip
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput> | $Types.Skip
  }

  export type DeviceStatusOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    device?: DeviceOrderByWithRelationInput | $Types.Skip
  }

  export type DeviceStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: DeviceStatusWhereInput | DeviceStatusWhereInput[] | $Types.Skip
    OR?: DeviceStatusWhereInput[] | $Types.Skip
    NOT?: DeviceStatusWhereInput | DeviceStatusWhereInput[] | $Types.Skip
    deviceId?: StringFilter<"DeviceStatus"> | string | $Types.Skip
    isOnline?: BoolFilter<"DeviceStatus"> | boolean | $Types.Skip
    createdAt?: DateTimeFilter<"DeviceStatus"> | Date | string | $Types.Skip
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput> | $Types.Skip
  }, "id">

  export type DeviceStatusOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    _count?: DeviceStatusCountOrderByAggregateInput | $Types.Skip
    _max?: DeviceStatusMaxOrderByAggregateInput | $Types.Skip
    _min?: DeviceStatusMinOrderByAggregateInput | $Types.Skip
  }

  export type DeviceStatusScalarWhereWithAggregatesInput = {
    AND?: DeviceStatusScalarWhereWithAggregatesInput | DeviceStatusScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: DeviceStatusScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: DeviceStatusScalarWhereWithAggregatesInput | DeviceStatusScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"DeviceStatus"> | string | $Types.Skip
    deviceId?: StringWithAggregatesFilter<"DeviceStatus"> | string | $Types.Skip
    isOnline?: BoolWithAggregatesFilter<"DeviceStatus"> | boolean | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"DeviceStatus"> | Date | string | $Types.Skip
  }

  export type DeviceTelemetryWhereInput = {
    AND?: DeviceTelemetryWhereInput | DeviceTelemetryWhereInput[] | $Types.Skip
    OR?: DeviceTelemetryWhereInput[] | $Types.Skip
    NOT?: DeviceTelemetryWhereInput | DeviceTelemetryWhereInput[] | $Types.Skip
    id?: StringFilter<"DeviceTelemetry"> | string | $Types.Skip
    deviceId?: StringFilter<"DeviceTelemetry"> | string | $Types.Skip
    localIpAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    publicIpAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    macAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    softwareVersion?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    platform?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    osRelease?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    screenResolutionWidth?: IntNullableFilter<"DeviceTelemetry"> | number | null | $Types.Skip
    screenResolutionHeight?: IntNullableFilter<"DeviceTelemetry"> | number | null | $Types.Skip
    hostname?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    timezone?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    totalMemory?: BigIntNullableFilter<"DeviceTelemetry"> | bigint | number | null | $Types.Skip
    freeMemory?: BigIntNullableFilter<"DeviceTelemetry"> | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFilter<"DeviceTelemetry"> | Date | string | $Types.Skip
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput> | $Types.Skip
  }

  export type DeviceTelemetryOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    localIpAddress?: SortOrderInput | SortOrder | $Types.Skip
    publicIpAddress?: SortOrderInput | SortOrder | $Types.Skip
    macAddress?: SortOrderInput | SortOrder | $Types.Skip
    softwareVersion?: SortOrderInput | SortOrder | $Types.Skip
    platform?: SortOrderInput | SortOrder | $Types.Skip
    osRelease?: SortOrderInput | SortOrder | $Types.Skip
    screenResolutionWidth?: SortOrderInput | SortOrder | $Types.Skip
    screenResolutionHeight?: SortOrderInput | SortOrder | $Types.Skip
    hostname?: SortOrderInput | SortOrder | $Types.Skip
    timezone?: SortOrderInput | SortOrder | $Types.Skip
    totalMemory?: SortOrderInput | SortOrder | $Types.Skip
    freeMemory?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    device?: DeviceOrderByWithRelationInput | $Types.Skip
  }

  export type DeviceTelemetryWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: DeviceTelemetryWhereInput | DeviceTelemetryWhereInput[] | $Types.Skip
    OR?: DeviceTelemetryWhereInput[] | $Types.Skip
    NOT?: DeviceTelemetryWhereInput | DeviceTelemetryWhereInput[] | $Types.Skip
    deviceId?: StringFilter<"DeviceTelemetry"> | string | $Types.Skip
    localIpAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    publicIpAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    macAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    softwareVersion?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    platform?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    osRelease?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    screenResolutionWidth?: IntNullableFilter<"DeviceTelemetry"> | number | null | $Types.Skip
    screenResolutionHeight?: IntNullableFilter<"DeviceTelemetry"> | number | null | $Types.Skip
    hostname?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    timezone?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    totalMemory?: BigIntNullableFilter<"DeviceTelemetry"> | bigint | number | null | $Types.Skip
    freeMemory?: BigIntNullableFilter<"DeviceTelemetry"> | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFilter<"DeviceTelemetry"> | Date | string | $Types.Skip
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput> | $Types.Skip
  }, "id">

  export type DeviceTelemetryOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    localIpAddress?: SortOrderInput | SortOrder | $Types.Skip
    publicIpAddress?: SortOrderInput | SortOrder | $Types.Skip
    macAddress?: SortOrderInput | SortOrder | $Types.Skip
    softwareVersion?: SortOrderInput | SortOrder | $Types.Skip
    platform?: SortOrderInput | SortOrder | $Types.Skip
    osRelease?: SortOrderInput | SortOrder | $Types.Skip
    screenResolutionWidth?: SortOrderInput | SortOrder | $Types.Skip
    screenResolutionHeight?: SortOrderInput | SortOrder | $Types.Skip
    hostname?: SortOrderInput | SortOrder | $Types.Skip
    timezone?: SortOrderInput | SortOrder | $Types.Skip
    totalMemory?: SortOrderInput | SortOrder | $Types.Skip
    freeMemory?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    _count?: DeviceTelemetryCountOrderByAggregateInput | $Types.Skip
    _avg?: DeviceTelemetryAvgOrderByAggregateInput | $Types.Skip
    _max?: DeviceTelemetryMaxOrderByAggregateInput | $Types.Skip
    _min?: DeviceTelemetryMinOrderByAggregateInput | $Types.Skip
    _sum?: DeviceTelemetrySumOrderByAggregateInput | $Types.Skip
  }

  export type DeviceTelemetryScalarWhereWithAggregatesInput = {
    AND?: DeviceTelemetryScalarWhereWithAggregatesInput | DeviceTelemetryScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: DeviceTelemetryScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: DeviceTelemetryScalarWhereWithAggregatesInput | DeviceTelemetryScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"DeviceTelemetry"> | string | $Types.Skip
    deviceId?: StringWithAggregatesFilter<"DeviceTelemetry"> | string | $Types.Skip
    localIpAddress?: StringNullableWithAggregatesFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    publicIpAddress?: StringNullableWithAggregatesFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    macAddress?: StringNullableWithAggregatesFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    softwareVersion?: StringNullableWithAggregatesFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    platform?: StringNullableWithAggregatesFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    osRelease?: StringNullableWithAggregatesFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    screenResolutionWidth?: IntNullableWithAggregatesFilter<"DeviceTelemetry"> | number | null | $Types.Skip
    screenResolutionHeight?: IntNullableWithAggregatesFilter<"DeviceTelemetry"> | number | null | $Types.Skip
    hostname?: StringNullableWithAggregatesFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    timezone?: StringNullableWithAggregatesFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    totalMemory?: BigIntNullableWithAggregatesFilter<"DeviceTelemetry"> | bigint | number | null | $Types.Skip
    freeMemory?: BigIntNullableWithAggregatesFilter<"DeviceTelemetry"> | bigint | number | null | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"DeviceTelemetry"> | Date | string | $Types.Skip
  }

  export type EmailVerificationTokenWhereInput = {
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[] | $Types.Skip
    OR?: EmailVerificationTokenWhereInput[] | $Types.Skip
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[] | $Types.Skip
    id?: StringFilter<"EmailVerificationToken"> | string | $Types.Skip
    token?: StringFilter<"EmailVerificationToken"> | string | $Types.Skip
    userId?: StringFilter<"EmailVerificationToken"> | string | $Types.Skip
    newEmail?: StringNullableFilter<"EmailVerificationToken"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
  }

  export type EmailVerificationTokenOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    newEmail?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    user?: UserOrderByWithRelationInput | $Types.Skip
  }

  export type EmailVerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    token?: string | $Types.Skip
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[] | $Types.Skip
    OR?: EmailVerificationTokenWhereInput[] | $Types.Skip
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[] | $Types.Skip
    userId?: StringFilter<"EmailVerificationToken"> | string | $Types.Skip
    newEmail?: StringNullableFilter<"EmailVerificationToken"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
  }, "id" | "token">

  export type EmailVerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    newEmail?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    _count?: EmailVerificationTokenCountOrderByAggregateInput | $Types.Skip
    _max?: EmailVerificationTokenMaxOrderByAggregateInput | $Types.Skip
    _min?: EmailVerificationTokenMinOrderByAggregateInput | $Types.Skip
  }

  export type EmailVerificationTokenScalarWhereWithAggregatesInput = {
    AND?: EmailVerificationTokenScalarWhereWithAggregatesInput | EmailVerificationTokenScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: EmailVerificationTokenScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: EmailVerificationTokenScalarWhereWithAggregatesInput | EmailVerificationTokenScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"EmailVerificationToken"> | string | $Types.Skip
    token?: StringWithAggregatesFilter<"EmailVerificationToken"> | string | $Types.Skip
    userId?: StringWithAggregatesFilter<"EmailVerificationToken"> | string | $Types.Skip
    newEmail?: StringNullableWithAggregatesFilter<"EmailVerificationToken"> | string | null | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"EmailVerificationToken"> | Date | string | $Types.Skip
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[] | $Types.Skip
    OR?: FileWhereInput[] | $Types.Skip
    NOT?: FileWhereInput | FileWhereInput[] | $Types.Skip
    id?: StringFilter<"File"> | string | $Types.Skip
    workspaceId?: StringFilter<"File"> | string | $Types.Skip
    name?: StringFilter<"File"> | string | $Types.Skip
    extension?: StringFilter<"File"> | string | $Types.Skip
    mimeType?: StringFilter<"File"> | string | $Types.Skip
    previewPath?: StringNullableFilter<"File"> | string | null | $Types.Skip
    size?: BigIntFilter<"File"> | bigint | number | $Types.Skip
    type?: StringFilter<"File"> | string | $Types.Skip
    path?: StringFilter<"File"> | string | $Types.Skip
    width?: IntNullableFilter<"File"> | number | null | $Types.Skip
    height?: IntNullableFilter<"File"> | number | null | $Types.Skip
    duration?: IntNullableFilter<"File"> | number | null | $Types.Skip
    defaultDuration?: IntNullableFilter<"File"> | number | null | $Types.Skip
    md5?: StringNullableFilter<"File"> | string | null | $Types.Skip
    folderId?: StringNullableFilter<"File"> | string | null | $Types.Skip
    availabilityStartAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    availabilityEndAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"File"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"File"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    uploaderId?: StringNullableFilter<"File"> | string | null | $Types.Skip
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    uploader?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null | $Types.Skip
    playlistItems?: PlaylistItemListRelationFilter | $Types.Skip
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    extension?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    previewPath?: SortOrderInput | SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    width?: SortOrderInput | SortOrder | $Types.Skip
    height?: SortOrderInput | SortOrder | $Types.Skip
    duration?: SortOrderInput | SortOrder | $Types.Skip
    defaultDuration?: SortOrderInput | SortOrder | $Types.Skip
    md5?: SortOrderInput | SortOrder | $Types.Skip
    folderId?: SortOrderInput | SortOrder | $Types.Skip
    availabilityStartAt?: SortOrderInput | SortOrder | $Types.Skip
    availabilityEndAt?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    uploaderId?: SortOrderInput | SortOrder | $Types.Skip
    folder?: FolderOrderByWithRelationInput | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    uploader?: UserOrderByWithRelationInput | $Types.Skip
    playlistItems?: PlaylistItemOrderByRelationAggregateInput | $Types.Skip
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    path?: string | $Types.Skip
    AND?: FileWhereInput | FileWhereInput[] | $Types.Skip
    OR?: FileWhereInput[] | $Types.Skip
    NOT?: FileWhereInput | FileWhereInput[] | $Types.Skip
    workspaceId?: StringFilter<"File"> | string | $Types.Skip
    name?: StringFilter<"File"> | string | $Types.Skip
    extension?: StringFilter<"File"> | string | $Types.Skip
    mimeType?: StringFilter<"File"> | string | $Types.Skip
    previewPath?: StringNullableFilter<"File"> | string | null | $Types.Skip
    size?: BigIntFilter<"File"> | bigint | number | $Types.Skip
    type?: StringFilter<"File"> | string | $Types.Skip
    width?: IntNullableFilter<"File"> | number | null | $Types.Skip
    height?: IntNullableFilter<"File"> | number | null | $Types.Skip
    duration?: IntNullableFilter<"File"> | number | null | $Types.Skip
    defaultDuration?: IntNullableFilter<"File"> | number | null | $Types.Skip
    md5?: StringNullableFilter<"File"> | string | null | $Types.Skip
    folderId?: StringNullableFilter<"File"> | string | null | $Types.Skip
    availabilityStartAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    availabilityEndAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"File"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"File"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    uploaderId?: StringNullableFilter<"File"> | string | null | $Types.Skip
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    uploader?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null | $Types.Skip
    playlistItems?: PlaylistItemListRelationFilter | $Types.Skip
  }, "id" | "path">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    extension?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    previewPath?: SortOrderInput | SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    width?: SortOrderInput | SortOrder | $Types.Skip
    height?: SortOrderInput | SortOrder | $Types.Skip
    duration?: SortOrderInput | SortOrder | $Types.Skip
    defaultDuration?: SortOrderInput | SortOrder | $Types.Skip
    md5?: SortOrderInput | SortOrder | $Types.Skip
    folderId?: SortOrderInput | SortOrder | $Types.Skip
    availabilityStartAt?: SortOrderInput | SortOrder | $Types.Skip
    availabilityEndAt?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    uploaderId?: SortOrderInput | SortOrder | $Types.Skip
    _count?: FileCountOrderByAggregateInput | $Types.Skip
    _avg?: FileAvgOrderByAggregateInput | $Types.Skip
    _max?: FileMaxOrderByAggregateInput | $Types.Skip
    _min?: FileMinOrderByAggregateInput | $Types.Skip
    _sum?: FileSumOrderByAggregateInput | $Types.Skip
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: FileScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"File"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"File"> | string | $Types.Skip
    name?: StringWithAggregatesFilter<"File"> | string | $Types.Skip
    extension?: StringWithAggregatesFilter<"File"> | string | $Types.Skip
    mimeType?: StringWithAggregatesFilter<"File"> | string | $Types.Skip
    previewPath?: StringNullableWithAggregatesFilter<"File"> | string | null | $Types.Skip
    size?: BigIntWithAggregatesFilter<"File"> | bigint | number | $Types.Skip
    type?: StringWithAggregatesFilter<"File"> | string | $Types.Skip
    path?: StringWithAggregatesFilter<"File"> | string | $Types.Skip
    width?: IntNullableWithAggregatesFilter<"File"> | number | null | $Types.Skip
    height?: IntNullableWithAggregatesFilter<"File"> | number | null | $Types.Skip
    duration?: IntNullableWithAggregatesFilter<"File"> | number | null | $Types.Skip
    defaultDuration?: IntNullableWithAggregatesFilter<"File"> | number | null | $Types.Skip
    md5?: StringNullableWithAggregatesFilter<"File"> | string | null | $Types.Skip
    folderId?: StringNullableWithAggregatesFilter<"File"> | string | null | $Types.Skip
    availabilityStartAt?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null | $Types.Skip
    availabilityEndAt?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null | $Types.Skip
    uploaderId?: StringNullableWithAggregatesFilter<"File"> | string | null | $Types.Skip
  }

  export type FileUploadSessionWhereInput = {
    AND?: FileUploadSessionWhereInput | FileUploadSessionWhereInput[] | $Types.Skip
    OR?: FileUploadSessionWhereInput[] | $Types.Skip
    NOT?: FileUploadSessionWhereInput | FileUploadSessionWhereInput[] | $Types.Skip
    id?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    name?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    path?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    size?: BigIntFilter<"FileUploadSession"> | bigint | number | $Types.Skip
    uploaded?: BigIntFilter<"FileUploadSession"> | bigint | number | $Types.Skip
    parts?: IntFilter<"FileUploadSession"> | number | $Types.Skip
    mimeType?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    workspaceId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    uploadId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    folderId?: StringNullableFilter<"FileUploadSession"> | string | null | $Types.Skip
    userId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"FileUploadSession"> | Date | string | $Types.Skip
    completedAt?: DateTimeNullableFilter<"FileUploadSession"> | Date | string | null | $Types.Skip
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
  }

  export type FileUploadSessionOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    uploaded?: SortOrder | $Types.Skip
    parts?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    uploadId?: SortOrder | $Types.Skip
    folderId?: SortOrderInput | SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    completedAt?: SortOrderInput | SortOrder | $Types.Skip
    folder?: FolderOrderByWithRelationInput | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    user?: UserOrderByWithRelationInput | $Types.Skip
  }

  export type FileUploadSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: FileUploadSessionWhereInput | FileUploadSessionWhereInput[] | $Types.Skip
    OR?: FileUploadSessionWhereInput[] | $Types.Skip
    NOT?: FileUploadSessionWhereInput | FileUploadSessionWhereInput[] | $Types.Skip
    name?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    path?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    size?: BigIntFilter<"FileUploadSession"> | bigint | number | $Types.Skip
    uploaded?: BigIntFilter<"FileUploadSession"> | bigint | number | $Types.Skip
    parts?: IntFilter<"FileUploadSession"> | number | $Types.Skip
    mimeType?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    workspaceId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    uploadId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    folderId?: StringNullableFilter<"FileUploadSession"> | string | null | $Types.Skip
    userId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"FileUploadSession"> | Date | string | $Types.Skip
    completedAt?: DateTimeNullableFilter<"FileUploadSession"> | Date | string | null | $Types.Skip
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
  }, "id">

  export type FileUploadSessionOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    uploaded?: SortOrder | $Types.Skip
    parts?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    uploadId?: SortOrder | $Types.Skip
    folderId?: SortOrderInput | SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    completedAt?: SortOrderInput | SortOrder | $Types.Skip
    _count?: FileUploadSessionCountOrderByAggregateInput | $Types.Skip
    _avg?: FileUploadSessionAvgOrderByAggregateInput | $Types.Skip
    _max?: FileUploadSessionMaxOrderByAggregateInput | $Types.Skip
    _min?: FileUploadSessionMinOrderByAggregateInput | $Types.Skip
    _sum?: FileUploadSessionSumOrderByAggregateInput | $Types.Skip
  }

  export type FileUploadSessionScalarWhereWithAggregatesInput = {
    AND?: FileUploadSessionScalarWhereWithAggregatesInput | FileUploadSessionScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: FileUploadSessionScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: FileUploadSessionScalarWhereWithAggregatesInput | FileUploadSessionScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"FileUploadSession"> | string | $Types.Skip
    name?: StringWithAggregatesFilter<"FileUploadSession"> | string | $Types.Skip
    path?: StringWithAggregatesFilter<"FileUploadSession"> | string | $Types.Skip
    size?: BigIntWithAggregatesFilter<"FileUploadSession"> | bigint | number | $Types.Skip
    uploaded?: BigIntWithAggregatesFilter<"FileUploadSession"> | bigint | number | $Types.Skip
    parts?: IntWithAggregatesFilter<"FileUploadSession"> | number | $Types.Skip
    mimeType?: StringWithAggregatesFilter<"FileUploadSession"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"FileUploadSession"> | string | $Types.Skip
    uploadId?: StringWithAggregatesFilter<"FileUploadSession"> | string | $Types.Skip
    folderId?: StringNullableWithAggregatesFilter<"FileUploadSession"> | string | null | $Types.Skip
    userId?: StringWithAggregatesFilter<"FileUploadSession"> | string | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"FileUploadSession"> | Date | string | $Types.Skip
    completedAt?: DateTimeNullableWithAggregatesFilter<"FileUploadSession"> | Date | string | null | $Types.Skip
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[] | $Types.Skip
    OR?: FolderWhereInput[] | $Types.Skip
    NOT?: FolderWhereInput | FolderWhereInput[] | $Types.Skip
    id?: StringFilter<"Folder"> | string | $Types.Skip
    name?: StringFilter<"Folder"> | string | $Types.Skip
    workspaceId?: StringFilter<"Folder"> | string | $Types.Skip
    parentId?: StringNullableFilter<"Folder"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"Folder"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Folder"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"Folder"> | Date | string | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null | $Types.Skip
    subfolders?: FolderListRelationFilter | $Types.Skip
    files?: FileListRelationFilter | $Types.Skip
    fileUploadSessions?: FileUploadSessionListRelationFilter | $Types.Skip
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    parentId?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    parent?: FolderOrderByWithRelationInput | $Types.Skip
    subfolders?: FolderOrderByRelationAggregateInput | $Types.Skip
    files?: FileOrderByRelationAggregateInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionOrderByRelationAggregateInput | $Types.Skip
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: FolderWhereInput | FolderWhereInput[] | $Types.Skip
    OR?: FolderWhereInput[] | $Types.Skip
    NOT?: FolderWhereInput | FolderWhereInput[] | $Types.Skip
    name?: StringFilter<"Folder"> | string | $Types.Skip
    workspaceId?: StringFilter<"Folder"> | string | $Types.Skip
    parentId?: StringNullableFilter<"Folder"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"Folder"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Folder"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"Folder"> | Date | string | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null | $Types.Skip
    subfolders?: FolderListRelationFilter | $Types.Skip
    files?: FileListRelationFilter | $Types.Skip
    fileUploadSessions?: FileUploadSessionListRelationFilter | $Types.Skip
  }, "id">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    parentId?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    _count?: FolderCountOrderByAggregateInput | $Types.Skip
    _max?: FolderMaxOrderByAggregateInput | $Types.Skip
    _min?: FolderMinOrderByAggregateInput | $Types.Skip
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: FolderScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"Folder"> | string | $Types.Skip
    name?: StringWithAggregatesFilter<"Folder"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"Folder"> | string | $Types.Skip
    parentId?: StringNullableWithAggregatesFilter<"Folder"> | string | null | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Folder"> | Date | string | null | $Types.Skip
  }

  export type PlaylistWhereInput = {
    AND?: PlaylistWhereInput | PlaylistWhereInput[] | $Types.Skip
    OR?: PlaylistWhereInput[] | $Types.Skip
    NOT?: PlaylistWhereInput | PlaylistWhereInput[] | $Types.Skip
    id?: StringFilter<"Playlist"> | string | $Types.Skip
    workspaceId?: StringFilter<"Playlist"> | string | $Types.Skip
    playlistLayoutId?: StringNullableFilter<"Playlist"> | string | null | $Types.Skip
    name?: StringFilter<"Playlist"> | string | $Types.Skip
    description?: StringFilter<"Playlist"> | string | $Types.Skip
    size?: BigIntFilter<"Playlist"> | bigint | number | $Types.Skip
    type?: StringFilter<"Playlist"> | string | $Types.Skip
    isPublished?: BoolFilter<"Playlist"> | boolean | $Types.Skip
    priority?: IntFilter<"Playlist"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"Playlist"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"Playlist"> | Date | string | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    layout?: XOR<PlaylistLayoutNullableScalarRelationFilter, PlaylistLayoutWhereInput> | null | $Types.Skip
    items?: PlaylistItemListRelationFilter | $Types.Skip
    parentItems?: PlaylistItemListRelationFilter | $Types.Skip
    screens?: PlaylistScreenListRelationFilter | $Types.Skip
    schedules?: PlaylistScheduleListRelationFilter | $Types.Skip
  }

  export type PlaylistOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrderInput | SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    description?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    isPublished?: SortOrder | $Types.Skip
    priority?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    layout?: PlaylistLayoutOrderByWithRelationInput | $Types.Skip
    items?: PlaylistItemOrderByRelationAggregateInput | $Types.Skip
    parentItems?: PlaylistItemOrderByRelationAggregateInput | $Types.Skip
    screens?: PlaylistScreenOrderByRelationAggregateInput | $Types.Skip
    schedules?: PlaylistScheduleOrderByRelationAggregateInput | $Types.Skip
  }

  export type PlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: PlaylistWhereInput | PlaylistWhereInput[] | $Types.Skip
    OR?: PlaylistWhereInput[] | $Types.Skip
    NOT?: PlaylistWhereInput | PlaylistWhereInput[] | $Types.Skip
    workspaceId?: StringFilter<"Playlist"> | string | $Types.Skip
    playlistLayoutId?: StringNullableFilter<"Playlist"> | string | null | $Types.Skip
    name?: StringFilter<"Playlist"> | string | $Types.Skip
    description?: StringFilter<"Playlist"> | string | $Types.Skip
    size?: BigIntFilter<"Playlist"> | bigint | number | $Types.Skip
    type?: StringFilter<"Playlist"> | string | $Types.Skip
    isPublished?: BoolFilter<"Playlist"> | boolean | $Types.Skip
    priority?: IntFilter<"Playlist"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"Playlist"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"Playlist"> | Date | string | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    layout?: XOR<PlaylistLayoutNullableScalarRelationFilter, PlaylistLayoutWhereInput> | null | $Types.Skip
    items?: PlaylistItemListRelationFilter | $Types.Skip
    parentItems?: PlaylistItemListRelationFilter | $Types.Skip
    screens?: PlaylistScreenListRelationFilter | $Types.Skip
    schedules?: PlaylistScheduleListRelationFilter | $Types.Skip
  }, "id">

  export type PlaylistOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrderInput | SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    description?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    isPublished?: SortOrder | $Types.Skip
    priority?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    _count?: PlaylistCountOrderByAggregateInput | $Types.Skip
    _avg?: PlaylistAvgOrderByAggregateInput | $Types.Skip
    _max?: PlaylistMaxOrderByAggregateInput | $Types.Skip
    _min?: PlaylistMinOrderByAggregateInput | $Types.Skip
    _sum?: PlaylistSumOrderByAggregateInput | $Types.Skip
  }

  export type PlaylistScalarWhereWithAggregatesInput = {
    AND?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: PlaylistScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"Playlist"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"Playlist"> | string | $Types.Skip
    playlistLayoutId?: StringNullableWithAggregatesFilter<"Playlist"> | string | null | $Types.Skip
    name?: StringWithAggregatesFilter<"Playlist"> | string | $Types.Skip
    description?: StringWithAggregatesFilter<"Playlist"> | string | $Types.Skip
    size?: BigIntWithAggregatesFilter<"Playlist"> | bigint | number | $Types.Skip
    type?: StringWithAggregatesFilter<"Playlist"> | string | $Types.Skip
    isPublished?: BoolWithAggregatesFilter<"Playlist"> | boolean | $Types.Skip
    priority?: IntWithAggregatesFilter<"Playlist"> | number | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Playlist"> | Date | string | null | $Types.Skip
  }

  export type PlaylistItemWhereInput = {
    AND?: PlaylistItemWhereInput | PlaylistItemWhereInput[] | $Types.Skip
    OR?: PlaylistItemWhereInput[] | $Types.Skip
    NOT?: PlaylistItemWhereInput | PlaylistItemWhereInput[] | $Types.Skip
    id?: StringFilter<"PlaylistItem"> | string | $Types.Skip
    playlistId?: StringFilter<"PlaylistItem"> | string | $Types.Skip
    type?: EnumPlaylistItemTypeFilter<"PlaylistItem"> | $Enums.PlaylistItemType | $Types.Skip
    duration?: IntNullableFilter<"PlaylistItem"> | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFilter<"PlaylistItem"> | string | $Types.Skip
    fileId?: StringNullableFilter<"PlaylistItem"> | string | null | $Types.Skip
    nestedPlaylistId?: StringNullableFilter<"PlaylistItem"> | string | null | $Types.Skip
    order?: IntFilter<"PlaylistItem"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistItem"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistItem"> | Date | string | $Types.Skip
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput> | $Types.Skip
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null | $Types.Skip
    nestedPlaylist?: XOR<PlaylistNullableScalarRelationFilter, PlaylistWhereInput> | null | $Types.Skip
    playlistLayoutSection?: XOR<PlaylistLayoutSectionScalarRelationFilter, PlaylistLayoutSectionWhereInput> | $Types.Skip
  }

  export type PlaylistItemOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    duration?: SortOrderInput | SortOrder | $Types.Skip
    playlistLayoutSectionId?: SortOrder | $Types.Skip
    fileId?: SortOrderInput | SortOrder | $Types.Skip
    nestedPlaylistId?: SortOrderInput | SortOrder | $Types.Skip
    order?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    playlist?: PlaylistOrderByWithRelationInput | $Types.Skip
    file?: FileOrderByWithRelationInput | $Types.Skip
    nestedPlaylist?: PlaylistOrderByWithRelationInput | $Types.Skip
    playlistLayoutSection?: PlaylistLayoutSectionOrderByWithRelationInput | $Types.Skip
  }

  export type PlaylistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: PlaylistItemWhereInput | PlaylistItemWhereInput[] | $Types.Skip
    OR?: PlaylistItemWhereInput[] | $Types.Skip
    NOT?: PlaylistItemWhereInput | PlaylistItemWhereInput[] | $Types.Skip
    playlistId?: StringFilter<"PlaylistItem"> | string | $Types.Skip
    type?: EnumPlaylistItemTypeFilter<"PlaylistItem"> | $Enums.PlaylistItemType | $Types.Skip
    duration?: IntNullableFilter<"PlaylistItem"> | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFilter<"PlaylistItem"> | string | $Types.Skip
    fileId?: StringNullableFilter<"PlaylistItem"> | string | null | $Types.Skip
    nestedPlaylistId?: StringNullableFilter<"PlaylistItem"> | string | null | $Types.Skip
    order?: IntFilter<"PlaylistItem"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistItem"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistItem"> | Date | string | $Types.Skip
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput> | $Types.Skip
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null | $Types.Skip
    nestedPlaylist?: XOR<PlaylistNullableScalarRelationFilter, PlaylistWhereInput> | null | $Types.Skip
    playlistLayoutSection?: XOR<PlaylistLayoutSectionScalarRelationFilter, PlaylistLayoutSectionWhereInput> | $Types.Skip
  }, "id">

  export type PlaylistItemOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    duration?: SortOrderInput | SortOrder | $Types.Skip
    playlistLayoutSectionId?: SortOrder | $Types.Skip
    fileId?: SortOrderInput | SortOrder | $Types.Skip
    nestedPlaylistId?: SortOrderInput | SortOrder | $Types.Skip
    order?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    _count?: PlaylistItemCountOrderByAggregateInput | $Types.Skip
    _avg?: PlaylistItemAvgOrderByAggregateInput | $Types.Skip
    _max?: PlaylistItemMaxOrderByAggregateInput | $Types.Skip
    _min?: PlaylistItemMinOrderByAggregateInput | $Types.Skip
    _sum?: PlaylistItemSumOrderByAggregateInput | $Types.Skip
  }

  export type PlaylistItemScalarWhereWithAggregatesInput = {
    AND?: PlaylistItemScalarWhereWithAggregatesInput | PlaylistItemScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: PlaylistItemScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: PlaylistItemScalarWhereWithAggregatesInput | PlaylistItemScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"PlaylistItem"> | string | $Types.Skip
    playlistId?: StringWithAggregatesFilter<"PlaylistItem"> | string | $Types.Skip
    type?: EnumPlaylistItemTypeWithAggregatesFilter<"PlaylistItem"> | $Enums.PlaylistItemType | $Types.Skip
    duration?: IntNullableWithAggregatesFilter<"PlaylistItem"> | number | null | $Types.Skip
    playlistLayoutSectionId?: StringWithAggregatesFilter<"PlaylistItem"> | string | $Types.Skip
    fileId?: StringNullableWithAggregatesFilter<"PlaylistItem"> | string | null | $Types.Skip
    nestedPlaylistId?: StringNullableWithAggregatesFilter<"PlaylistItem"> | string | null | $Types.Skip
    order?: IntWithAggregatesFilter<"PlaylistItem"> | number | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"PlaylistItem"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"PlaylistItem"> | Date | string | $Types.Skip
  }

  export type PlaylistLayoutWhereInput = {
    AND?: PlaylistLayoutWhereInput | PlaylistLayoutWhereInput[] | $Types.Skip
    OR?: PlaylistLayoutWhereInput[] | $Types.Skip
    NOT?: PlaylistLayoutWhereInput | PlaylistLayoutWhereInput[] | $Types.Skip
    id?: StringFilter<"PlaylistLayout"> | string | $Types.Skip
    workspaceId?: StringFilter<"PlaylistLayout"> | string | $Types.Skip
    name?: StringFilter<"PlaylistLayout"> | string | $Types.Skip
    resolutionWidth?: IntFilter<"PlaylistLayout"> | number | $Types.Skip
    resolutionHeight?: IntFilter<"PlaylistLayout"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistLayout"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistLayout"> | Date | string | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    playlists?: PlaylistListRelationFilter | $Types.Skip
    sections?: PlaylistLayoutSectionListRelationFilter | $Types.Skip
  }

  export type PlaylistLayoutOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    playlists?: PlaylistOrderByRelationAggregateInput | $Types.Skip
    sections?: PlaylistLayoutSectionOrderByRelationAggregateInput | $Types.Skip
  }

  export type PlaylistLayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: PlaylistLayoutWhereInput | PlaylistLayoutWhereInput[] | $Types.Skip
    OR?: PlaylistLayoutWhereInput[] | $Types.Skip
    NOT?: PlaylistLayoutWhereInput | PlaylistLayoutWhereInput[] | $Types.Skip
    workspaceId?: StringFilter<"PlaylistLayout"> | string | $Types.Skip
    name?: StringFilter<"PlaylistLayout"> | string | $Types.Skip
    resolutionWidth?: IntFilter<"PlaylistLayout"> | number | $Types.Skip
    resolutionHeight?: IntFilter<"PlaylistLayout"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistLayout"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistLayout"> | Date | string | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    playlists?: PlaylistListRelationFilter | $Types.Skip
    sections?: PlaylistLayoutSectionListRelationFilter | $Types.Skip
  }, "id">

  export type PlaylistLayoutOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    _count?: PlaylistLayoutCountOrderByAggregateInput | $Types.Skip
    _avg?: PlaylistLayoutAvgOrderByAggregateInput | $Types.Skip
    _max?: PlaylistLayoutMaxOrderByAggregateInput | $Types.Skip
    _min?: PlaylistLayoutMinOrderByAggregateInput | $Types.Skip
    _sum?: PlaylistLayoutSumOrderByAggregateInput | $Types.Skip
  }

  export type PlaylistLayoutScalarWhereWithAggregatesInput = {
    AND?: PlaylistLayoutScalarWhereWithAggregatesInput | PlaylistLayoutScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: PlaylistLayoutScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: PlaylistLayoutScalarWhereWithAggregatesInput | PlaylistLayoutScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"PlaylistLayout"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"PlaylistLayout"> | string | $Types.Skip
    name?: StringWithAggregatesFilter<"PlaylistLayout"> | string | $Types.Skip
    resolutionWidth?: IntWithAggregatesFilter<"PlaylistLayout"> | number | $Types.Skip
    resolutionHeight?: IntWithAggregatesFilter<"PlaylistLayout"> | number | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"PlaylistLayout"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"PlaylistLayout"> | Date | string | $Types.Skip
  }

  export type PlaylistLayoutSectionWhereInput = {
    AND?: PlaylistLayoutSectionWhereInput | PlaylistLayoutSectionWhereInput[] | $Types.Skip
    OR?: PlaylistLayoutSectionWhereInput[] | $Types.Skip
    NOT?: PlaylistLayoutSectionWhereInput | PlaylistLayoutSectionWhereInput[] | $Types.Skip
    id?: StringFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    playlistLayoutId?: StringFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    name?: StringFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    top?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    left?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    width?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    height?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    zIndex?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    playlistLayout?: XOR<PlaylistLayoutScalarRelationFilter, PlaylistLayoutWhereInput> | $Types.Skip
    playlistItems?: PlaylistItemListRelationFilter | $Types.Skip
  }

  export type PlaylistLayoutSectionOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    top?: SortOrder | $Types.Skip
    left?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    zIndex?: SortOrder | $Types.Skip
    playlistLayout?: PlaylistLayoutOrderByWithRelationInput | $Types.Skip
    playlistItems?: PlaylistItemOrderByRelationAggregateInput | $Types.Skip
  }

  export type PlaylistLayoutSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: PlaylistLayoutSectionWhereInput | PlaylistLayoutSectionWhereInput[] | $Types.Skip
    OR?: PlaylistLayoutSectionWhereInput[] | $Types.Skip
    NOT?: PlaylistLayoutSectionWhereInput | PlaylistLayoutSectionWhereInput[] | $Types.Skip
    playlistLayoutId?: StringFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    name?: StringFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    top?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    left?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    width?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    height?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    zIndex?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    playlistLayout?: XOR<PlaylistLayoutScalarRelationFilter, PlaylistLayoutWhereInput> | $Types.Skip
    playlistItems?: PlaylistItemListRelationFilter | $Types.Skip
  }, "id">

  export type PlaylistLayoutSectionOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    top?: SortOrder | $Types.Skip
    left?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    zIndex?: SortOrder | $Types.Skip
    _count?: PlaylistLayoutSectionCountOrderByAggregateInput | $Types.Skip
    _avg?: PlaylistLayoutSectionAvgOrderByAggregateInput | $Types.Skip
    _max?: PlaylistLayoutSectionMaxOrderByAggregateInput | $Types.Skip
    _min?: PlaylistLayoutSectionMinOrderByAggregateInput | $Types.Skip
    _sum?: PlaylistLayoutSectionSumOrderByAggregateInput | $Types.Skip
  }

  export type PlaylistLayoutSectionScalarWhereWithAggregatesInput = {
    AND?: PlaylistLayoutSectionScalarWhereWithAggregatesInput | PlaylistLayoutSectionScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: PlaylistLayoutSectionScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: PlaylistLayoutSectionScalarWhereWithAggregatesInput | PlaylistLayoutSectionScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    playlistLayoutId?: StringWithAggregatesFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    name?: StringWithAggregatesFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    top?: IntWithAggregatesFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    left?: IntWithAggregatesFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    width?: IntWithAggregatesFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    height?: IntWithAggregatesFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    zIndex?: IntWithAggregatesFilter<"PlaylistLayoutSection"> | number | $Types.Skip
  }

  export type PlaylistScheduleWhereInput = {
    AND?: PlaylistScheduleWhereInput | PlaylistScheduleWhereInput[] | $Types.Skip
    OR?: PlaylistScheduleWhereInput[] | $Types.Skip
    NOT?: PlaylistScheduleWhereInput | PlaylistScheduleWhereInput[] | $Types.Skip
    id?: StringFilter<"PlaylistSchedule"> | string | $Types.Skip
    playlistId?: StringFilter<"PlaylistSchedule"> | string | $Types.Skip
    startAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    endAt?: DateTimeNullableFilter<"PlaylistSchedule"> | Date | string | null | $Types.Skip
    startTime?: StringNullableFilter<"PlaylistSchedule"> | string | null | $Types.Skip
    endTime?: StringNullableFilter<"PlaylistSchedule"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    weekdays?: EnumWeekdayNullableListFilter<"PlaylistSchedule"> | $Types.Skip
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput> | $Types.Skip
  }

  export type PlaylistScheduleOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    startAt?: SortOrder | $Types.Skip
    endAt?: SortOrderInput | SortOrder | $Types.Skip
    startTime?: SortOrderInput | SortOrder | $Types.Skip
    endTime?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    weekdays?: SortOrder | $Types.Skip
    playlist?: PlaylistOrderByWithRelationInput | $Types.Skip
  }

  export type PlaylistScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: PlaylistScheduleWhereInput | PlaylistScheduleWhereInput[] | $Types.Skip
    OR?: PlaylistScheduleWhereInput[] | $Types.Skip
    NOT?: PlaylistScheduleWhereInput | PlaylistScheduleWhereInput[] | $Types.Skip
    playlistId?: StringFilter<"PlaylistSchedule"> | string | $Types.Skip
    startAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    endAt?: DateTimeNullableFilter<"PlaylistSchedule"> | Date | string | null | $Types.Skip
    startTime?: StringNullableFilter<"PlaylistSchedule"> | string | null | $Types.Skip
    endTime?: StringNullableFilter<"PlaylistSchedule"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    weekdays?: EnumWeekdayNullableListFilter<"PlaylistSchedule"> | $Types.Skip
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput> | $Types.Skip
  }, "id">

  export type PlaylistScheduleOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    startAt?: SortOrder | $Types.Skip
    endAt?: SortOrderInput | SortOrder | $Types.Skip
    startTime?: SortOrderInput | SortOrder | $Types.Skip
    endTime?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    weekdays?: SortOrder | $Types.Skip
    _count?: PlaylistScheduleCountOrderByAggregateInput | $Types.Skip
    _max?: PlaylistScheduleMaxOrderByAggregateInput | $Types.Skip
    _min?: PlaylistScheduleMinOrderByAggregateInput | $Types.Skip
  }

  export type PlaylistScheduleScalarWhereWithAggregatesInput = {
    AND?: PlaylistScheduleScalarWhereWithAggregatesInput | PlaylistScheduleScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: PlaylistScheduleScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: PlaylistScheduleScalarWhereWithAggregatesInput | PlaylistScheduleScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"PlaylistSchedule"> | string | $Types.Skip
    playlistId?: StringWithAggregatesFilter<"PlaylistSchedule"> | string | $Types.Skip
    startAt?: DateTimeWithAggregatesFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    endAt?: DateTimeNullableWithAggregatesFilter<"PlaylistSchedule"> | Date | string | null | $Types.Skip
    startTime?: StringNullableWithAggregatesFilter<"PlaylistSchedule"> | string | null | $Types.Skip
    endTime?: StringNullableWithAggregatesFilter<"PlaylistSchedule"> | string | null | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    weekdays?: EnumWeekdayNullableListFilter<"PlaylistSchedule"> | $Types.Skip
  }

  export type PlaylistScreenWhereInput = {
    AND?: PlaylistScreenWhereInput | PlaylistScreenWhereInput[] | $Types.Skip
    OR?: PlaylistScreenWhereInput[] | $Types.Skip
    NOT?: PlaylistScreenWhereInput | PlaylistScreenWhereInput[] | $Types.Skip
    playlistId?: StringFilter<"PlaylistScreen"> | string | $Types.Skip
    screenId?: StringFilter<"PlaylistScreen"> | string | $Types.Skip
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput> | $Types.Skip
    screen?: XOR<ScreenScalarRelationFilter, ScreenWhereInput> | $Types.Skip
  }

  export type PlaylistScreenOrderByWithRelationInput = {
    playlistId?: SortOrder | $Types.Skip
    screenId?: SortOrder | $Types.Skip
    playlist?: PlaylistOrderByWithRelationInput | $Types.Skip
    screen?: ScreenOrderByWithRelationInput | $Types.Skip
  }

  export type PlaylistScreenWhereUniqueInput = Prisma.AtLeast<{
    playlistId_screenId?: PlaylistScreenPlaylistIdScreenIdCompoundUniqueInput | $Types.Skip
    AND?: PlaylistScreenWhereInput | PlaylistScreenWhereInput[] | $Types.Skip
    OR?: PlaylistScreenWhereInput[] | $Types.Skip
    NOT?: PlaylistScreenWhereInput | PlaylistScreenWhereInput[] | $Types.Skip
    playlistId?: StringFilter<"PlaylistScreen"> | string | $Types.Skip
    screenId?: StringFilter<"PlaylistScreen"> | string | $Types.Skip
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput> | $Types.Skip
    screen?: XOR<ScreenScalarRelationFilter, ScreenWhereInput> | $Types.Skip
  }, "playlistId_screenId">

  export type PlaylistScreenOrderByWithAggregationInput = {
    playlistId?: SortOrder | $Types.Skip
    screenId?: SortOrder | $Types.Skip
    _count?: PlaylistScreenCountOrderByAggregateInput | $Types.Skip
    _max?: PlaylistScreenMaxOrderByAggregateInput | $Types.Skip
    _min?: PlaylistScreenMinOrderByAggregateInput | $Types.Skip
  }

  export type PlaylistScreenScalarWhereWithAggregatesInput = {
    AND?: PlaylistScreenScalarWhereWithAggregatesInput | PlaylistScreenScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: PlaylistScreenScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: PlaylistScreenScalarWhereWithAggregatesInput | PlaylistScreenScalarWhereWithAggregatesInput[] | $Types.Skip
    playlistId?: StringWithAggregatesFilter<"PlaylistScreen"> | string | $Types.Skip
    screenId?: StringWithAggregatesFilter<"PlaylistScreen"> | string | $Types.Skip
  }

  export type ScreenWhereInput = {
    AND?: ScreenWhereInput | ScreenWhereInput[] | $Types.Skip
    OR?: ScreenWhereInput[] | $Types.Skip
    NOT?: ScreenWhereInput | ScreenWhereInput[] | $Types.Skip
    id?: StringFilter<"Screen"> | string | $Types.Skip
    workspaceId?: StringFilter<"Screen"> | string | $Types.Skip
    groupId?: StringNullableFilter<"Screen"> | string | null | $Types.Skip
    name?: StringFilter<"Screen"> | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFilter<"Screen"> | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFilter<"Screen"> | number | $Types.Skip
    resolutionHeight?: IntFilter<"Screen"> | number | $Types.Skip
    type?: StringFilter<"Screen"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"Screen"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Screen"> | Date | string | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null | $Types.Skip
    playlists?: PlaylistScreenListRelationFilter | $Types.Skip
    group?: XOR<ScreenGroupNullableScalarRelationFilter, ScreenGroupWhereInput> | null | $Types.Skip
  }

  export type ScreenOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    groupId?: SortOrderInput | SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    layoutRotation?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    device?: DeviceOrderByWithRelationInput | $Types.Skip
    playlists?: PlaylistScreenOrderByRelationAggregateInput | $Types.Skip
    group?: ScreenGroupOrderByWithRelationInput | $Types.Skip
  }

  export type ScreenWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: ScreenWhereInput | ScreenWhereInput[] | $Types.Skip
    OR?: ScreenWhereInput[] | $Types.Skip
    NOT?: ScreenWhereInput | ScreenWhereInput[] | $Types.Skip
    workspaceId?: StringFilter<"Screen"> | string | $Types.Skip
    groupId?: StringNullableFilter<"Screen"> | string | null | $Types.Skip
    name?: StringFilter<"Screen"> | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFilter<"Screen"> | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFilter<"Screen"> | number | $Types.Skip
    resolutionHeight?: IntFilter<"Screen"> | number | $Types.Skip
    type?: StringFilter<"Screen"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"Screen"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Screen"> | Date | string | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null | $Types.Skip
    playlists?: PlaylistScreenListRelationFilter | $Types.Skip
    group?: XOR<ScreenGroupNullableScalarRelationFilter, ScreenGroupWhereInput> | null | $Types.Skip
  }, "id">

  export type ScreenOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    groupId?: SortOrderInput | SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    layoutRotation?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    _count?: ScreenCountOrderByAggregateInput | $Types.Skip
    _avg?: ScreenAvgOrderByAggregateInput | $Types.Skip
    _max?: ScreenMaxOrderByAggregateInput | $Types.Skip
    _min?: ScreenMinOrderByAggregateInput | $Types.Skip
    _sum?: ScreenSumOrderByAggregateInput | $Types.Skip
  }

  export type ScreenScalarWhereWithAggregatesInput = {
    AND?: ScreenScalarWhereWithAggregatesInput | ScreenScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: ScreenScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: ScreenScalarWhereWithAggregatesInput | ScreenScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"Screen"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"Screen"> | string | $Types.Skip
    groupId?: StringNullableWithAggregatesFilter<"Screen"> | string | null | $Types.Skip
    name?: StringWithAggregatesFilter<"Screen"> | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationWithAggregatesFilter<"Screen"> | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntWithAggregatesFilter<"Screen"> | number | $Types.Skip
    resolutionHeight?: IntWithAggregatesFilter<"Screen"> | number | $Types.Skip
    type?: StringWithAggregatesFilter<"Screen"> | string | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"Screen"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"Screen"> | Date | string | $Types.Skip
  }

  export type ScreenGroupWhereInput = {
    AND?: ScreenGroupWhereInput | ScreenGroupWhereInput[] | $Types.Skip
    OR?: ScreenGroupWhereInput[] | $Types.Skip
    NOT?: ScreenGroupWhereInput | ScreenGroupWhereInput[] | $Types.Skip
    id?: StringFilter<"ScreenGroup"> | string | $Types.Skip
    name?: StringFilter<"ScreenGroup"> | string | $Types.Skip
    workspaceId?: StringFilter<"ScreenGroup"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"ScreenGroup"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"ScreenGroup"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"ScreenGroup"> | Date | string | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    screens?: ScreenListRelationFilter | $Types.Skip
  }

  export type ScreenGroupOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    screens?: ScreenOrderByRelationAggregateInput | $Types.Skip
  }

  export type ScreenGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: ScreenGroupWhereInput | ScreenGroupWhereInput[] | $Types.Skip
    OR?: ScreenGroupWhereInput[] | $Types.Skip
    NOT?: ScreenGroupWhereInput | ScreenGroupWhereInput[] | $Types.Skip
    name?: StringFilter<"ScreenGroup"> | string | $Types.Skip
    workspaceId?: StringFilter<"ScreenGroup"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"ScreenGroup"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"ScreenGroup"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"ScreenGroup"> | Date | string | null | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    screens?: ScreenListRelationFilter | $Types.Skip
  }, "id">

  export type ScreenGroupOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    _count?: ScreenGroupCountOrderByAggregateInput | $Types.Skip
    _max?: ScreenGroupMaxOrderByAggregateInput | $Types.Skip
    _min?: ScreenGroupMinOrderByAggregateInput | $Types.Skip
  }

  export type ScreenGroupScalarWhereWithAggregatesInput = {
    AND?: ScreenGroupScalarWhereWithAggregatesInput | ScreenGroupScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: ScreenGroupScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: ScreenGroupScalarWhereWithAggregatesInput | ScreenGroupScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"ScreenGroup"> | string | $Types.Skip
    name?: StringWithAggregatesFilter<"ScreenGroup"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"ScreenGroup"> | string | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"ScreenGroup"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"ScreenGroup"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ScreenGroup"> | Date | string | null | $Types.Skip
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[] | $Types.Skip
    OR?: SessionWhereInput[] | $Types.Skip
    NOT?: SessionWhereInput | SessionWhereInput[] | $Types.Skip
    id?: StringFilter<"Session"> | string | $Types.Skip
    userId?: StringFilter<"Session"> | string | $Types.Skip
    token?: StringFilter<"Session"> | string | $Types.Skip
    userAgent?: StringFilter<"Session"> | string | $Types.Skip
    ipAddress?: StringFilter<"Session"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"Session"> | Date | string | $Types.Skip
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFilter<"Session"> | Date | string | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userAgent?: SortOrder | $Types.Skip
    ipAddress?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    revokedAt?: SortOrderInput | SortOrder | $Types.Skip
    lastActivityAt?: SortOrder | $Types.Skip
    user?: UserOrderByWithRelationInput | $Types.Skip
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    token?: string | $Types.Skip
    AND?: SessionWhereInput | SessionWhereInput[] | $Types.Skip
    OR?: SessionWhereInput[] | $Types.Skip
    NOT?: SessionWhereInput | SessionWhereInput[] | $Types.Skip
    userId?: StringFilter<"Session"> | string | $Types.Skip
    userAgent?: StringFilter<"Session"> | string | $Types.Skip
    ipAddress?: StringFilter<"Session"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"Session"> | Date | string | $Types.Skip
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFilter<"Session"> | Date | string | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userAgent?: SortOrder | $Types.Skip
    ipAddress?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    revokedAt?: SortOrderInput | SortOrder | $Types.Skip
    lastActivityAt?: SortOrder | $Types.Skip
    _count?: SessionCountOrderByAggregateInput | $Types.Skip
    _max?: SessionMaxOrderByAggregateInput | $Types.Skip
    _min?: SessionMinOrderByAggregateInput | $Types.Skip
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: SessionScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"Session"> | string | $Types.Skip
    userId?: StringWithAggregatesFilter<"Session"> | string | $Types.Skip
    token?: StringWithAggregatesFilter<"Session"> | string | $Types.Skip
    userAgent?: StringWithAggregatesFilter<"Session"> | string | $Types.Skip
    ipAddress?: StringWithAggregatesFilter<"Session"> | string | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string | $Types.Skip
    revokedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string | $Types.Skip
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[] | $Types.Skip
    OR?: UserWhereInput[] | $Types.Skip
    NOT?: UserWhereInput | UserWhereInput[] | $Types.Skip
    id?: StringFilter<"User"> | string | $Types.Skip
    email?: StringFilter<"User"> | string | $Types.Skip
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null | $Types.Skip
    name?: StringFilter<"User"> | string | $Types.Skip
    password?: StringFilter<"User"> | string | $Types.Skip
    profilePhoto?: StringNullableFilter<"User"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"User"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"User"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenListRelationFilter | $Types.Skip
    sessions?: SessionListRelationFilter | $Types.Skip
    workspaces?: UserWorkspaceListRelationFilter | $Types.Skip
    userPreferences?: UserPreferencesListRelationFilter | $Types.Skip
    uploadedFiles?: FileListRelationFilter | $Types.Skip
    fileUploadSessions?: FileUploadSessionListRelationFilter | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationListRelationFilter | $Types.Skip
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    emailVerifiedAt?: SortOrderInput | SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    password?: SortOrder | $Types.Skip
    profilePhoto?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenOrderByRelationAggregateInput | $Types.Skip
    sessions?: SessionOrderByRelationAggregateInput | $Types.Skip
    workspaces?: UserWorkspaceOrderByRelationAggregateInput | $Types.Skip
    userPreferences?: UserPreferencesOrderByRelationAggregateInput | $Types.Skip
    uploadedFiles?: FileOrderByRelationAggregateInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionOrderByRelationAggregateInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationOrderByRelationAggregateInput | $Types.Skip
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    email?: string | $Types.Skip
    AND?: UserWhereInput | UserWhereInput[] | $Types.Skip
    OR?: UserWhereInput[] | $Types.Skip
    NOT?: UserWhereInput | UserWhereInput[] | $Types.Skip
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null | $Types.Skip
    name?: StringFilter<"User"> | string | $Types.Skip
    password?: StringFilter<"User"> | string | $Types.Skip
    profilePhoto?: StringNullableFilter<"User"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"User"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"User"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenListRelationFilter | $Types.Skip
    sessions?: SessionListRelationFilter | $Types.Skip
    workspaces?: UserWorkspaceListRelationFilter | $Types.Skip
    userPreferences?: UserPreferencesListRelationFilter | $Types.Skip
    uploadedFiles?: FileListRelationFilter | $Types.Skip
    fileUploadSessions?: FileUploadSessionListRelationFilter | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationListRelationFilter | $Types.Skip
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    emailVerifiedAt?: SortOrderInput | SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    password?: SortOrder | $Types.Skip
    profilePhoto?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrderInput | SortOrder | $Types.Skip
    _count?: UserCountOrderByAggregateInput | $Types.Skip
    _max?: UserMaxOrderByAggregateInput | $Types.Skip
    _min?: UserMinOrderByAggregateInput | $Types.Skip
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: UserScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"User"> | string | $Types.Skip
    email?: StringWithAggregatesFilter<"User"> | string | $Types.Skip
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null | $Types.Skip
    name?: StringWithAggregatesFilter<"User"> | string | $Types.Skip
    password?: StringWithAggregatesFilter<"User"> | string | $Types.Skip
    profilePhoto?: StringNullableWithAggregatesFilter<"User"> | string | null | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null | $Types.Skip
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[] | $Types.Skip
    OR?: UserPreferencesWhereInput[] | $Types.Skip
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[] | $Types.Skip
    id?: StringFilter<"UserPreferences"> | string | $Types.Skip
    userId?: StringFilter<"UserPreferences"> | string | $Types.Skip
    locale?: StringFilter<"UserPreferences"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    locale?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    user?: UserOrderByWithRelationInput | $Types.Skip
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[] | $Types.Skip
    OR?: UserPreferencesWhereInput[] | $Types.Skip
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[] | $Types.Skip
    userId?: StringFilter<"UserPreferences"> | string | $Types.Skip
    locale?: StringFilter<"UserPreferences"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
  }, "id">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    locale?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    _count?: UserPreferencesCountOrderByAggregateInput | $Types.Skip
    _max?: UserPreferencesMaxOrderByAggregateInput | $Types.Skip
    _min?: UserPreferencesMinOrderByAggregateInput | $Types.Skip
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: UserPreferencesScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"UserPreferences"> | string | $Types.Skip
    userId?: StringWithAggregatesFilter<"UserPreferences"> | string | $Types.Skip
    locale?: StringWithAggregatesFilter<"UserPreferences"> | string | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string | $Types.Skip
  }

  export type UserWorkspaceWhereInput = {
    AND?: UserWorkspaceWhereInput | UserWorkspaceWhereInput[] | $Types.Skip
    OR?: UserWorkspaceWhereInput[] | $Types.Skip
    NOT?: UserWorkspaceWhereInput | UserWorkspaceWhereInput[] | $Types.Skip
    userId?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    workspaceId?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    workspaceInvitationId?: StringNullableFilter<"UserWorkspace"> | string | null | $Types.Skip
    role?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    permissions?: StringNullableListFilter<"UserWorkspace"> | $Types.Skip
    createdAt?: DateTimeFilter<"UserWorkspace"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"UserWorkspace"> | Date | string | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    workspaceInvitation?: XOR<WorkspaceUserInvitationNullableScalarRelationFilter, WorkspaceUserInvitationWhereInput> | null | $Types.Skip
  }

  export type UserWorkspaceOrderByWithRelationInput = {
    userId?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    workspaceInvitationId?: SortOrderInput | SortOrder | $Types.Skip
    role?: SortOrder | $Types.Skip
    permissions?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    user?: UserOrderByWithRelationInput | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    workspaceInvitation?: WorkspaceUserInvitationOrderByWithRelationInput | $Types.Skip
  }

  export type UserWorkspaceWhereUniqueInput = Prisma.AtLeast<{
    workspaceInvitationId?: string | $Types.Skip
    userId_workspaceId?: UserWorkspaceUserIdWorkspaceIdCompoundUniqueInput | $Types.Skip
    AND?: UserWorkspaceWhereInput | UserWorkspaceWhereInput[] | $Types.Skip
    OR?: UserWorkspaceWhereInput[] | $Types.Skip
    NOT?: UserWorkspaceWhereInput | UserWorkspaceWhereInput[] | $Types.Skip
    userId?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    workspaceId?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    role?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    permissions?: StringNullableListFilter<"UserWorkspace"> | $Types.Skip
    createdAt?: DateTimeFilter<"UserWorkspace"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"UserWorkspace"> | Date | string | $Types.Skip
    user?: XOR<UserScalarRelationFilter, UserWhereInput> | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    workspaceInvitation?: XOR<WorkspaceUserInvitationNullableScalarRelationFilter, WorkspaceUserInvitationWhereInput> | null | $Types.Skip
  }, "userId_workspaceId" | "workspaceInvitationId">

  export type UserWorkspaceOrderByWithAggregationInput = {
    userId?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    workspaceInvitationId?: SortOrderInput | SortOrder | $Types.Skip
    role?: SortOrder | $Types.Skip
    permissions?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    _count?: UserWorkspaceCountOrderByAggregateInput | $Types.Skip
    _max?: UserWorkspaceMaxOrderByAggregateInput | $Types.Skip
    _min?: UserWorkspaceMinOrderByAggregateInput | $Types.Skip
  }

  export type UserWorkspaceScalarWhereWithAggregatesInput = {
    AND?: UserWorkspaceScalarWhereWithAggregatesInput | UserWorkspaceScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: UserWorkspaceScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: UserWorkspaceScalarWhereWithAggregatesInput | UserWorkspaceScalarWhereWithAggregatesInput[] | $Types.Skip
    userId?: StringWithAggregatesFilter<"UserWorkspace"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"UserWorkspace"> | string | $Types.Skip
    workspaceInvitationId?: StringNullableWithAggregatesFilter<"UserWorkspace"> | string | null | $Types.Skip
    role?: StringWithAggregatesFilter<"UserWorkspace"> | string | $Types.Skip
    permissions?: StringNullableListFilter<"UserWorkspace"> | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"UserWorkspace"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"UserWorkspace"> | Date | string | $Types.Skip
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[] | $Types.Skip
    OR?: WorkspaceWhereInput[] | $Types.Skip
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[] | $Types.Skip
    id?: StringFilter<"Workspace"> | string | $Types.Skip
    name?: StringFilter<"Workspace"> | string | $Types.Skip
    slug?: StringFilter<"Workspace"> | string | $Types.Skip
    status?: StringFilter<"Workspace"> | string | $Types.Skip
    picture?: StringNullableFilter<"Workspace"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"Workspace"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string | $Types.Skip
    members?: UserWorkspaceListRelationFilter | $Types.Skip
    screens?: ScreenListRelationFilter | $Types.Skip
    playlists?: PlaylistListRelationFilter | $Types.Skip
    layouts?: PlaylistLayoutListRelationFilter | $Types.Skip
    files?: FileListRelationFilter | $Types.Skip
    folders?: FolderListRelationFilter | $Types.Skip
    fileUploadSessions?: FileUploadSessionListRelationFilter | $Types.Skip
    userInvitations?: WorkspaceUserInvitationListRelationFilter | $Types.Skip
    screenGroups?: ScreenGroupListRelationFilter | $Types.Skip
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    slug?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    picture?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    members?: UserWorkspaceOrderByRelationAggregateInput | $Types.Skip
    screens?: ScreenOrderByRelationAggregateInput | $Types.Skip
    playlists?: PlaylistOrderByRelationAggregateInput | $Types.Skip
    layouts?: PlaylistLayoutOrderByRelationAggregateInput | $Types.Skip
    files?: FileOrderByRelationAggregateInput | $Types.Skip
    folders?: FolderOrderByRelationAggregateInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionOrderByRelationAggregateInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationOrderByRelationAggregateInput | $Types.Skip
    screenGroups?: ScreenGroupOrderByRelationAggregateInput | $Types.Skip
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    slug?: string | $Types.Skip
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[] | $Types.Skip
    OR?: WorkspaceWhereInput[] | $Types.Skip
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[] | $Types.Skip
    name?: StringFilter<"Workspace"> | string | $Types.Skip
    status?: StringFilter<"Workspace"> | string | $Types.Skip
    picture?: StringNullableFilter<"Workspace"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"Workspace"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string | $Types.Skip
    members?: UserWorkspaceListRelationFilter | $Types.Skip
    screens?: ScreenListRelationFilter | $Types.Skip
    playlists?: PlaylistListRelationFilter | $Types.Skip
    layouts?: PlaylistLayoutListRelationFilter | $Types.Skip
    files?: FileListRelationFilter | $Types.Skip
    folders?: FolderListRelationFilter | $Types.Skip
    fileUploadSessions?: FileUploadSessionListRelationFilter | $Types.Skip
    userInvitations?: WorkspaceUserInvitationListRelationFilter | $Types.Skip
    screenGroups?: ScreenGroupListRelationFilter | $Types.Skip
  }, "id" | "slug">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    slug?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    picture?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    _count?: WorkspaceCountOrderByAggregateInput | $Types.Skip
    _max?: WorkspaceMaxOrderByAggregateInput | $Types.Skip
    _min?: WorkspaceMinOrderByAggregateInput | $Types.Skip
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: WorkspaceScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"Workspace"> | string | $Types.Skip
    name?: StringWithAggregatesFilter<"Workspace"> | string | $Types.Skip
    slug?: StringWithAggregatesFilter<"Workspace"> | string | $Types.Skip
    status?: StringWithAggregatesFilter<"Workspace"> | string | $Types.Skip
    picture?: StringNullableWithAggregatesFilter<"Workspace"> | string | null | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string | $Types.Skip
  }

  export type WorkspaceUserInvitationWhereInput = {
    AND?: WorkspaceUserInvitationWhereInput | WorkspaceUserInvitationWhereInput[] | $Types.Skip
    OR?: WorkspaceUserInvitationWhereInput[] | $Types.Skip
    NOT?: WorkspaceUserInvitationWhereInput | WorkspaceUserInvitationWhereInput[] | $Types.Skip
    id?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    email?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    status?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    workspaceId?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    invitorId?: StringNullableFilter<"WorkspaceUserInvitation"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"WorkspaceUserInvitation"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"WorkspaceUserInvitation"> | Date | string | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    invitor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null | $Types.Skip
    members?: UserWorkspaceListRelationFilter | $Types.Skip
  }

  export type WorkspaceUserInvitationOrderByWithRelationInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    invitorId?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    workspace?: WorkspaceOrderByWithRelationInput | $Types.Skip
    invitor?: UserOrderByWithRelationInput | $Types.Skip
    members?: UserWorkspaceOrderByRelationAggregateInput | $Types.Skip
  }

  export type WorkspaceUserInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string | $Types.Skip
    AND?: WorkspaceUserInvitationWhereInput | WorkspaceUserInvitationWhereInput[] | $Types.Skip
    OR?: WorkspaceUserInvitationWhereInput[] | $Types.Skip
    NOT?: WorkspaceUserInvitationWhereInput | WorkspaceUserInvitationWhereInput[] | $Types.Skip
    email?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    status?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    workspaceId?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    invitorId?: StringNullableFilter<"WorkspaceUserInvitation"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"WorkspaceUserInvitation"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"WorkspaceUserInvitation"> | Date | string | $Types.Skip
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput> | $Types.Skip
    invitor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null | $Types.Skip
    members?: UserWorkspaceListRelationFilter | $Types.Skip
  }, "id">

  export type WorkspaceUserInvitationOrderByWithAggregationInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    invitorId?: SortOrderInput | SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    _count?: WorkspaceUserInvitationCountOrderByAggregateInput | $Types.Skip
    _max?: WorkspaceUserInvitationMaxOrderByAggregateInput | $Types.Skip
    _min?: WorkspaceUserInvitationMinOrderByAggregateInput | $Types.Skip
  }

  export type WorkspaceUserInvitationScalarWhereWithAggregatesInput = {
    AND?: WorkspaceUserInvitationScalarWhereWithAggregatesInput | WorkspaceUserInvitationScalarWhereWithAggregatesInput[] | $Types.Skip
    OR?: WorkspaceUserInvitationScalarWhereWithAggregatesInput[] | $Types.Skip
    NOT?: WorkspaceUserInvitationScalarWhereWithAggregatesInput | WorkspaceUserInvitationScalarWhereWithAggregatesInput[] | $Types.Skip
    id?: StringWithAggregatesFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    email?: StringWithAggregatesFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    status?: StringWithAggregatesFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    workspaceId?: StringWithAggregatesFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    invitorId?: StringNullableWithAggregatesFilter<"WorkspaceUserInvitation"> | string | null | $Types.Skip
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceUserInvitation"> | Date | string | $Types.Skip
    updatedAt?: DateTimeWithAggregatesFilter<"WorkspaceUserInvitation"> | Date | string | $Types.Skip
  }

  export type DeviceCreateInput = {
    id?: string | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
    screen?: ScreenCreateNestedOneWithoutDeviceInput | $Types.Skip
    telemetry?: DeviceTelemetryCreateNestedManyWithoutDeviceInput | $Types.Skip
    statusLog?: DeviceStatusCreateNestedManyWithoutDeviceInput | $Types.Skip
  }

  export type DeviceUncheckedCreateInput = {
    id?: string | $Types.Skip
    screenId?: string | null | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
    telemetry?: DeviceTelemetryUncheckedCreateNestedManyWithoutDeviceInput | $Types.Skip
    statusLog?: DeviceStatusUncheckedCreateNestedManyWithoutDeviceInput | $Types.Skip
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    screen?: ScreenUpdateOneWithoutDeviceNestedInput | $Types.Skip
    telemetry?: DeviceTelemetryUpdateManyWithoutDeviceNestedInput | $Types.Skip
    statusLog?: DeviceStatusUpdateManyWithoutDeviceNestedInput | $Types.Skip
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    screenId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    telemetry?: DeviceTelemetryUncheckedUpdateManyWithoutDeviceNestedInput | $Types.Skip
    statusLog?: DeviceStatusUncheckedUpdateManyWithoutDeviceNestedInput | $Types.Skip
  }

  export type DeviceCreateManyInput = {
    id?: string | $Types.Skip
    screenId?: string | null | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    screenId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
  }

  export type DeviceStatusCreateInput = {
    id?: string | $Types.Skip
    isOnline: boolean
    createdAt?: Date | string | $Types.Skip
    device: DeviceCreateNestedOneWithoutStatusLogInput
  }

  export type DeviceStatusUncheckedCreateInput = {
    id?: string | $Types.Skip
    deviceId: string
    isOnline: boolean
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    device?: DeviceUpdateOneRequiredWithoutStatusLogNestedInput | $Types.Skip
  }

  export type DeviceStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    deviceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceStatusCreateManyInput = {
    id?: string | $Types.Skip
    deviceId: string
    isOnline: boolean
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    deviceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceTelemetryCreateInput = {
    id?: string | $Types.Skip
    localIpAddress?: string | null | $Types.Skip
    publicIpAddress?: string | null | $Types.Skip
    macAddress?: string | null | $Types.Skip
    softwareVersion?: string | null | $Types.Skip
    platform?: string | null | $Types.Skip
    osRelease?: string | null | $Types.Skip
    screenResolutionWidth?: number | null | $Types.Skip
    screenResolutionHeight?: number | null | $Types.Skip
    hostname?: string | null | $Types.Skip
    timezone?: string | null | $Types.Skip
    totalMemory?: bigint | number | null | $Types.Skip
    freeMemory?: bigint | number | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    device: DeviceCreateNestedOneWithoutTelemetryInput
  }

  export type DeviceTelemetryUncheckedCreateInput = {
    id?: string | $Types.Skip
    deviceId: string
    localIpAddress?: string | null | $Types.Skip
    publicIpAddress?: string | null | $Types.Skip
    macAddress?: string | null | $Types.Skip
    softwareVersion?: string | null | $Types.Skip
    platform?: string | null | $Types.Skip
    osRelease?: string | null | $Types.Skip
    screenResolutionWidth?: number | null | $Types.Skip
    screenResolutionHeight?: number | null | $Types.Skip
    hostname?: string | null | $Types.Skip
    timezone?: string | null | $Types.Skip
    totalMemory?: bigint | number | null | $Types.Skip
    freeMemory?: bigint | number | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceTelemetryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    localIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    publicIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    softwareVersion?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    platform?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    osRelease?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    screenResolutionWidth?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    screenResolutionHeight?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    hostname?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    timezone?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    totalMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    freeMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    device?: DeviceUpdateOneRequiredWithoutTelemetryNestedInput | $Types.Skip
  }

  export type DeviceTelemetryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    deviceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    localIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    publicIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    softwareVersion?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    platform?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    osRelease?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    screenResolutionWidth?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    screenResolutionHeight?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    hostname?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    timezone?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    totalMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    freeMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceTelemetryCreateManyInput = {
    id?: string | $Types.Skip
    deviceId: string
    localIpAddress?: string | null | $Types.Skip
    publicIpAddress?: string | null | $Types.Skip
    macAddress?: string | null | $Types.Skip
    softwareVersion?: string | null | $Types.Skip
    platform?: string | null | $Types.Skip
    osRelease?: string | null | $Types.Skip
    screenResolutionWidth?: number | null | $Types.Skip
    screenResolutionHeight?: number | null | $Types.Skip
    hostname?: string | null | $Types.Skip
    timezone?: string | null | $Types.Skip
    totalMemory?: bigint | number | null | $Types.Skip
    freeMemory?: bigint | number | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceTelemetryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    localIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    publicIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    softwareVersion?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    platform?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    osRelease?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    screenResolutionWidth?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    screenResolutionHeight?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    hostname?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    timezone?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    totalMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    freeMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceTelemetryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    deviceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    localIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    publicIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    softwareVersion?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    platform?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    osRelease?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    screenResolutionWidth?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    screenResolutionHeight?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    hostname?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    timezone?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    totalMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    freeMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type EmailVerificationTokenCreateInput = {
    id?: string | $Types.Skip
    token: string
    newEmail?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    user: UserCreateNestedOneWithoutEmailVerificationTokensInput
  }

  export type EmailVerificationTokenUncheckedCreateInput = {
    id?: string | $Types.Skip
    token: string
    userId: string
    newEmail?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type EmailVerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    newEmail?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    user?: UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput | $Types.Skip
  }

  export type EmailVerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    newEmail?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type EmailVerificationTokenCreateManyInput = {
    id?: string | $Types.Skip
    token: string
    userId: string
    newEmail?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type EmailVerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    newEmail?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type EmailVerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    newEmail?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type FileCreateInput = {
    id?: string | $Types.Skip
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    folder?: FolderCreateNestedOneWithoutFilesInput | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFilesInput
    uploader?: UserCreateNestedOneWithoutUploadedFilesInput | $Types.Skip
    playlistItems?: PlaylistItemCreateNestedManyWithoutFileInput | $Types.Skip
  }

  export type FileUncheckedCreateInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    folderId?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    uploaderId?: string | null | $Types.Skip
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutFileInput | $Types.Skip
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    folder?: FolderUpdateOneWithoutFilesNestedInput | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFilesNestedInput | $Types.Skip
    uploader?: UserUpdateOneWithoutUploadedFilesNestedInput | $Types.Skip
    playlistItems?: PlaylistItemUpdateManyWithoutFileNestedInput | $Types.Skip
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutFileNestedInput | $Types.Skip
  }

  export type FileCreateManyInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    folderId?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    uploaderId?: string | null | $Types.Skip
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
  }

  export type FileUploadSessionCreateInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    uploadId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
    folder?: FolderCreateNestedOneWithoutFileUploadSessionsInput | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFileUploadSessionsInput
    user: UserCreateNestedOneWithoutFileUploadSessionsInput
  }

  export type FileUploadSessionUncheckedCreateInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    workspaceId: string
    uploadId: string
    folderId?: string | null | $Types.Skip
    userId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
  }

  export type FileUploadSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    folder?: FolderUpdateOneWithoutFileUploadSessionsNestedInput | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFileUploadSessionsNestedInput | $Types.Skip
    user?: UserUpdateOneRequiredWithoutFileUploadSessionsNestedInput | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUploadSessionCreateManyInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    workspaceId: string
    uploadId: string
    folderId?: string | null | $Types.Skip
    userId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
  }

  export type FileUploadSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FolderCreateInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFoldersInput
    parent?: FolderCreateNestedOneWithoutSubfoldersInput | $Types.Skip
    subfolders?: FolderCreateNestedManyWithoutParentInput | $Types.Skip
    files?: FileCreateNestedManyWithoutFolderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderUncheckedCreateInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    parentId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedCreateNestedManyWithoutParentInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFoldersNestedInput | $Types.Skip
    parent?: FolderUpdateOneWithoutSubfoldersNestedInput | $Types.Skip
    subfolders?: FolderUpdateManyWithoutParentNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutFolderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    parentId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedUpdateManyWithoutParentNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderCreateManyInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    parentId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    parentId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type PlaylistCreateInput = {
    id?: string | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutPlaylistsInput
    layout?: PlaylistLayoutCreateNestedOneWithoutPlaylistsInput | $Types.Skip
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistUncheckedCreateInput = {
    id?: string | $Types.Skip
    workspaceId: string
    playlistLayoutId?: string | null | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutPlaylistsNestedInput | $Types.Skip
    layout?: PlaylistLayoutUpdateOneWithoutPlaylistsNestedInput | $Types.Skip
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistCreateManyInput = {
    id?: string | $Types.Skip
    workspaceId: string
    playlistLayoutId?: string | null | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type PlaylistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type PlaylistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type PlaylistItemCreateInput = {
    id?: string | $Types.Skip
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlist: PlaylistCreateNestedOneWithoutItemsInput
    file?: FileCreateNestedOneWithoutPlaylistItemsInput | $Types.Skip
    nestedPlaylist?: PlaylistCreateNestedOneWithoutParentItemsInput | $Types.Skip
    playlistLayoutSection: PlaylistLayoutSectionCreateNestedOneWithoutPlaylistItemsInput
  }

  export type PlaylistItemUncheckedCreateInput = {
    id?: string | $Types.Skip
    playlistId: string
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    playlistLayoutSectionId: string
    fileId?: string | null | $Types.Skip
    nestedPlaylistId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlist?: PlaylistUpdateOneRequiredWithoutItemsNestedInput | $Types.Skip
    file?: FileUpdateOneWithoutPlaylistItemsNestedInput | $Types.Skip
    nestedPlaylist?: PlaylistUpdateOneWithoutParentItemsNestedInput | $Types.Skip
    playlistLayoutSection?: PlaylistLayoutSectionUpdateOneRequiredWithoutPlaylistItemsNestedInput | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    fileId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    nestedPlaylistId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistItemCreateManyInput = {
    id?: string | $Types.Skip
    playlistId: string
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    playlistLayoutSectionId: string
    fileId?: string | null | $Types.Skip
    nestedPlaylistId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    fileId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    nestedPlaylistId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistLayoutCreateInput = {
    id?: string | $Types.Skip
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutLayoutsInput
    playlists?: PlaylistCreateNestedManyWithoutLayoutInput | $Types.Skip
    sections?: PlaylistLayoutSectionCreateNestedManyWithoutPlaylistLayoutInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedCreateInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutLayoutInput | $Types.Skip
    sections?: PlaylistLayoutSectionUncheckedCreateNestedManyWithoutPlaylistLayoutInput | $Types.Skip
  }

  export type PlaylistLayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutLayoutsNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutLayoutNestedInput | $Types.Skip
    sections?: PlaylistLayoutSectionUpdateManyWithoutPlaylistLayoutNestedInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutLayoutNestedInput | $Types.Skip
    sections?: PlaylistLayoutSectionUncheckedUpdateManyWithoutPlaylistLayoutNestedInput | $Types.Skip
  }

  export type PlaylistLayoutCreateManyInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistLayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistLayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistLayoutSectionCreateInput = {
    id?: string | $Types.Skip
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
    playlistLayout: PlaylistLayoutCreateNestedOneWithoutSectionsInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutPlaylistLayoutSectionInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedCreateInput = {
    id?: string | $Types.Skip
    playlistLayoutId: string
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistLayoutSectionInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
    playlistLayout?: PlaylistLayoutUpdateOneRequiredWithoutSectionsNestedInput | $Types.Skip
    playlistItems?: PlaylistItemUpdateManyWithoutPlaylistLayoutSectionNestedInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutPlaylistLayoutSectionNestedInput | $Types.Skip
  }

  export type PlaylistLayoutSectionCreateManyInput = {
    id?: string | $Types.Skip
    playlistLayoutId: string
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
  }

  export type PlaylistLayoutSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
  }

  export type PlaylistScheduleCreateInput = {
    id?: string | $Types.Skip
    startAt: Date | string
    endAt?: Date | string | null | $Types.Skip
    startTime?: string | null | $Types.Skip
    endTime?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    weekdays?: PlaylistScheduleCreateweekdaysInput | $Enums.Weekday[] | $Types.Skip
    playlist: PlaylistCreateNestedOneWithoutSchedulesInput
  }

  export type PlaylistScheduleUncheckedCreateInput = {
    id?: string | $Types.Skip
    playlistId: string
    startAt: Date | string
    endAt?: Date | string | null | $Types.Skip
    startTime?: string | null | $Types.Skip
    endTime?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    weekdays?: PlaylistScheduleCreateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    startTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    endTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    weekdays?: PlaylistScheduleUpdateweekdaysInput | $Enums.Weekday[] | $Types.Skip
    playlist?: PlaylistUpdateOneRequiredWithoutSchedulesNestedInput | $Types.Skip
  }

  export type PlaylistScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    startTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    endTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    weekdays?: PlaylistScheduleUpdateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScheduleCreateManyInput = {
    id?: string | $Types.Skip
    playlistId: string
    startAt: Date | string
    endAt?: Date | string | null | $Types.Skip
    startTime?: string | null | $Types.Skip
    endTime?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    weekdays?: PlaylistScheduleCreateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    startTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    endTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    weekdays?: PlaylistScheduleUpdateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    startTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    endTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    weekdays?: PlaylistScheduleUpdateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScreenCreateInput = {
    playlist: PlaylistCreateNestedOneWithoutScreensInput
    screen: ScreenCreateNestedOneWithoutPlaylistsInput
  }

  export type PlaylistScreenUncheckedCreateInput = {
    playlistId: string
    screenId: string
  }

  export type PlaylistScreenUpdateInput = {
    playlist?: PlaylistUpdateOneRequiredWithoutScreensNestedInput | $Types.Skip
    screen?: ScreenUpdateOneRequiredWithoutPlaylistsNestedInput | $Types.Skip
  }

  export type PlaylistScreenUncheckedUpdateInput = {
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    screenId?: StringFieldUpdateOperationsInput | string | $Types.Skip
  }

  export type PlaylistScreenCreateManyInput = {
    playlistId: string
    screenId: string
  }

  export type PlaylistScreenUpdateManyMutationInput = {

  }

  export type PlaylistScreenUncheckedUpdateManyInput = {
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    screenId?: StringFieldUpdateOperationsInput | string | $Types.Skip
  }

  export type ScreenCreateInput = {
    id?: string | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutScreensInput
    device?: DeviceCreateNestedOneWithoutScreenInput | $Types.Skip
    playlists?: PlaylistScreenCreateNestedManyWithoutScreenInput | $Types.Skip
    group?: ScreenGroupCreateNestedOneWithoutScreensInput | $Types.Skip
  }

  export type ScreenUncheckedCreateInput = {
    id?: string | $Types.Skip
    workspaceId: string
    groupId?: string | null | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    device?: DeviceUncheckedCreateNestedOneWithoutScreenInput | $Types.Skip
    playlists?: PlaylistScreenUncheckedCreateNestedManyWithoutScreenInput | $Types.Skip
  }

  export type ScreenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutScreensNestedInput | $Types.Skip
    device?: DeviceUpdateOneWithoutScreenNestedInput | $Types.Skip
    playlists?: PlaylistScreenUpdateManyWithoutScreenNestedInput | $Types.Skip
    group?: ScreenGroupUpdateOneWithoutScreensNestedInput | $Types.Skip
  }

  export type ScreenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    groupId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    device?: DeviceUncheckedUpdateOneWithoutScreenNestedInput | $Types.Skip
    playlists?: PlaylistScreenUncheckedUpdateManyWithoutScreenNestedInput | $Types.Skip
  }

  export type ScreenCreateManyInput = {
    id?: string | $Types.Skip
    workspaceId: string
    groupId?: string | null | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type ScreenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type ScreenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    groupId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type ScreenGroupCreateInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutScreenGroupsInput
    screens?: ScreenCreateNestedManyWithoutGroupInput | $Types.Skip
  }

  export type ScreenGroupUncheckedCreateInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutGroupInput | $Types.Skip
  }

  export type ScreenGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutScreenGroupsNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutGroupNestedInput | $Types.Skip
  }

  export type ScreenGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutGroupNestedInput | $Types.Skip
  }

  export type ScreenGroupCreateManyInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type ScreenGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type ScreenGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type SessionCreateInput = {
    id?: string | $Types.Skip
    token: string
    userAgent: string
    ipAddress: string
    createdAt?: Date | string | $Types.Skip
    revokedAt?: Date | string | null | $Types.Skip
    lastActivityAt?: Date | string | $Types.Skip
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string | $Types.Skip
    userId: string
    token: string
    userAgent: string
    ipAddress: string
    createdAt?: Date | string | $Types.Skip
    revokedAt?: Date | string | null | $Types.Skip
    lastActivityAt?: Date | string | $Types.Skip
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userAgent?: StringFieldUpdateOperationsInput | string | $Types.Skip
    ipAddress?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput | $Types.Skip
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userAgent?: StringFieldUpdateOperationsInput | string | $Types.Skip
    ipAddress?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type SessionCreateManyInput = {
    id?: string | $Types.Skip
    userId: string
    token: string
    userAgent: string
    ipAddress: string
    createdAt?: Date | string | $Types.Skip
    revokedAt?: Date | string | null | $Types.Skip
    lastActivityAt?: Date | string | $Types.Skip
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userAgent?: StringFieldUpdateOperationsInput | string | $Types.Skip
    ipAddress?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userAgent?: StringFieldUpdateOperationsInput | string | $Types.Skip
    ipAddress?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserCreateInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserUncheckedCreateInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserCreateManyInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type UserPreferencesCreateInput = {
    id?: string | $Types.Skip
    locale: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    user: UserCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string | $Types.Skip
    userId: string
    locale: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    locale?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    user?: UserUpdateOneRequiredWithoutUserPreferencesNestedInput | $Types.Skip
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    locale?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserPreferencesCreateManyInput = {
    id?: string | $Types.Skip
    userId: string
    locale: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    locale?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    locale?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceCreateInput = {
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
    workspaceInvitation?: WorkspaceUserInvitationCreateNestedOneWithoutMembersInput | $Types.Skip
  }

  export type UserWorkspaceUncheckedCreateInput = {
    userId: string
    workspaceId: string
    workspaceInvitationId?: string | null | $Types.Skip
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserWorkspaceUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput | $Types.Skip
    workspaceInvitation?: WorkspaceUserInvitationUpdateOneWithoutMembersNestedInput | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceInvitationId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceCreateManyInput = {
    userId: string
    workspaceId: string
    workspaceInvitationId?: string | null | $Types.Skip
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserWorkspaceUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceInvitationId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type WorkspaceCreateInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceCreateManyInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutUserInvitationsInput
    invitor?: UserCreateNestedOneWithoutSentInvitationsInput | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInvitationInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedCreateInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    workspaceId: string
    invitorId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInvitationInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutUserInvitationsNestedInput | $Types.Skip
    invitor?: UserUpdateOneWithoutSentInvitationsNestedInput | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceInvitationNestedInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    invitorId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceInvitationNestedInput | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateManyInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    workspaceId: string
    invitorId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type WorkspaceUserInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    invitorId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    contains?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    startsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    endsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    mode?: QueryMode | $Types.Skip
    not?: NestedStringFilter<$PrismaModel> | string | $Types.Skip
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    contains?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    startsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    endsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    mode?: QueryMode | $Types.Skip
    not?: NestedStringNullableFilter<$PrismaModel> | string | null | $Types.Skip
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string | $Types.Skip
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBoolFilter<$PrismaModel> | boolean | $Types.Skip
  }

  export type ScreenNullableScalarRelationFilter = {
    is?: ScreenWhereInput | null | $Types.Skip
    isNot?: ScreenWhereInput | null | $Types.Skip
  }

  export type DeviceTelemetryListRelationFilter = {
    every?: DeviceTelemetryWhereInput | $Types.Skip
    some?: DeviceTelemetryWhereInput | $Types.Skip
    none?: DeviceTelemetryWhereInput | $Types.Skip
  }

  export type DeviceStatusListRelationFilter = {
    every?: DeviceStatusWhereInput | $Types.Skip
    some?: DeviceStatusWhereInput | $Types.Skip
    none?: DeviceStatusWhereInput | $Types.Skip
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder | $Types.Skip
  }

  export type DeviceTelemetryOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type DeviceStatusOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    screenId?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    connectionCode?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    screenId?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    connectionCode?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    screenId?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    connectionCode?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    contains?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    startsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    endsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    mode?: QueryMode | $Types.Skip
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedStringFilter<$PrismaModel> | $Types.Skip
    _max?: NestedStringFilter<$PrismaModel> | $Types.Skip
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    contains?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    startsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    endsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    mode?: QueryMode | $Types.Skip
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null | $Types.Skip
    _count?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _min?: NestedStringNullableFilter<$PrismaModel> | $Types.Skip
    _max?: NestedStringNullableFilter<$PrismaModel> | $Types.Skip
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedDateTimeFilter<$PrismaModel> | $Types.Skip
    _max?: NestedDateTimeFilter<$PrismaModel> | $Types.Skip
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedBoolFilter<$PrismaModel> | $Types.Skip
    _max?: NestedBoolFilter<$PrismaModel> | $Types.Skip
  }

  export type DeviceScalarRelationFilter = {
    is?: DeviceWhereInput | $Types.Skip
    isNot?: DeviceWhereInput | $Types.Skip
  }

  export type DeviceStatusCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type DeviceStatusMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type DeviceStatusMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    isOnline?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedIntNullableFilter<$PrismaModel> | number | null | $Types.Skip
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null | $Types.Skip
  }

  export type DeviceTelemetryCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    localIpAddress?: SortOrder | $Types.Skip
    publicIpAddress?: SortOrder | $Types.Skip
    macAddress?: SortOrder | $Types.Skip
    softwareVersion?: SortOrder | $Types.Skip
    platform?: SortOrder | $Types.Skip
    osRelease?: SortOrder | $Types.Skip
    screenResolutionWidth?: SortOrder | $Types.Skip
    screenResolutionHeight?: SortOrder | $Types.Skip
    hostname?: SortOrder | $Types.Skip
    timezone?: SortOrder | $Types.Skip
    totalMemory?: SortOrder | $Types.Skip
    freeMemory?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type DeviceTelemetryAvgOrderByAggregateInput = {
    screenResolutionWidth?: SortOrder | $Types.Skip
    screenResolutionHeight?: SortOrder | $Types.Skip
    totalMemory?: SortOrder | $Types.Skip
    freeMemory?: SortOrder | $Types.Skip
  }

  export type DeviceTelemetryMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    localIpAddress?: SortOrder | $Types.Skip
    publicIpAddress?: SortOrder | $Types.Skip
    macAddress?: SortOrder | $Types.Skip
    softwareVersion?: SortOrder | $Types.Skip
    platform?: SortOrder | $Types.Skip
    osRelease?: SortOrder | $Types.Skip
    screenResolutionWidth?: SortOrder | $Types.Skip
    screenResolutionHeight?: SortOrder | $Types.Skip
    hostname?: SortOrder | $Types.Skip
    timezone?: SortOrder | $Types.Skip
    totalMemory?: SortOrder | $Types.Skip
    freeMemory?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type DeviceTelemetryMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    deviceId?: SortOrder | $Types.Skip
    localIpAddress?: SortOrder | $Types.Skip
    publicIpAddress?: SortOrder | $Types.Skip
    macAddress?: SortOrder | $Types.Skip
    softwareVersion?: SortOrder | $Types.Skip
    platform?: SortOrder | $Types.Skip
    osRelease?: SortOrder | $Types.Skip
    screenResolutionWidth?: SortOrder | $Types.Skip
    screenResolutionHeight?: SortOrder | $Types.Skip
    hostname?: SortOrder | $Types.Skip
    timezone?: SortOrder | $Types.Skip
    totalMemory?: SortOrder | $Types.Skip
    freeMemory?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type DeviceTelemetrySumOrderByAggregateInput = {
    screenResolutionWidth?: SortOrder | $Types.Skip
    screenResolutionHeight?: SortOrder | $Types.Skip
    totalMemory?: SortOrder | $Types.Skip
    freeMemory?: SortOrder | $Types.Skip
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null | $Types.Skip
    _count?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _avg?: NestedFloatNullableFilter<$PrismaModel> | $Types.Skip
    _sum?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _min?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _max?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null | $Types.Skip
    _count?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _avg?: NestedFloatNullableFilter<$PrismaModel> | $Types.Skip
    _sum?: NestedBigIntNullableFilter<$PrismaModel> | $Types.Skip
    _min?: NestedBigIntNullableFilter<$PrismaModel> | $Types.Skip
    _max?: NestedBigIntNullableFilter<$PrismaModel> | $Types.Skip
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput | $Types.Skip
    isNot?: UserWhereInput | $Types.Skip
  }

  export type EmailVerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    newEmail?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type EmailVerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    newEmail?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type EmailVerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    newEmail?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number | $Types.Skip
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null | $Types.Skip
  }

  export type FolderNullableScalarRelationFilter = {
    is?: FolderWhereInput | null | $Types.Skip
    isNot?: FolderWhereInput | null | $Types.Skip
  }

  export type WorkspaceScalarRelationFilter = {
    is?: WorkspaceWhereInput | $Types.Skip
    isNot?: WorkspaceWhereInput | $Types.Skip
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null | $Types.Skip
    isNot?: UserWhereInput | null | $Types.Skip
  }

  export type PlaylistItemListRelationFilter = {
    every?: PlaylistItemWhereInput | $Types.Skip
    some?: PlaylistItemWhereInput | $Types.Skip
    none?: PlaylistItemWhereInput | $Types.Skip
  }

  export type PlaylistItemOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    extension?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    previewPath?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    duration?: SortOrder | $Types.Skip
    defaultDuration?: SortOrder | $Types.Skip
    md5?: SortOrder | $Types.Skip
    folderId?: SortOrder | $Types.Skip
    availabilityStartAt?: SortOrder | $Types.Skip
    availabilityEndAt?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
    uploaderId?: SortOrder | $Types.Skip
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    duration?: SortOrder | $Types.Skip
    defaultDuration?: SortOrder | $Types.Skip
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    extension?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    previewPath?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    duration?: SortOrder | $Types.Skip
    defaultDuration?: SortOrder | $Types.Skip
    md5?: SortOrder | $Types.Skip
    folderId?: SortOrder | $Types.Skip
    availabilityStartAt?: SortOrder | $Types.Skip
    availabilityEndAt?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
    uploaderId?: SortOrder | $Types.Skip
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    extension?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    previewPath?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    duration?: SortOrder | $Types.Skip
    defaultDuration?: SortOrder | $Types.Skip
    md5?: SortOrder | $Types.Skip
    folderId?: SortOrder | $Types.Skip
    availabilityStartAt?: SortOrder | $Types.Skip
    availabilityEndAt?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
    uploaderId?: SortOrder | $Types.Skip
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    duration?: SortOrder | $Types.Skip
    defaultDuration?: SortOrder | $Types.Skip
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _avg?: NestedFloatFilter<$PrismaModel> | $Types.Skip
    _sum?: NestedBigIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedBigIntFilter<$PrismaModel> | $Types.Skip
    _max?: NestedBigIntFilter<$PrismaModel> | $Types.Skip
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null | $Types.Skip
    _count?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _min?: NestedDateTimeNullableFilter<$PrismaModel> | $Types.Skip
    _max?: NestedDateTimeNullableFilter<$PrismaModel> | $Types.Skip
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedIntFilter<$PrismaModel> | number | $Types.Skip
  }

  export type FileUploadSessionCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    uploaded?: SortOrder | $Types.Skip
    parts?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    uploadId?: SortOrder | $Types.Skip
    folderId?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    completedAt?: SortOrder | $Types.Skip
  }

  export type FileUploadSessionAvgOrderByAggregateInput = {
    size?: SortOrder | $Types.Skip
    uploaded?: SortOrder | $Types.Skip
    parts?: SortOrder | $Types.Skip
  }

  export type FileUploadSessionMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    uploaded?: SortOrder | $Types.Skip
    parts?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    uploadId?: SortOrder | $Types.Skip
    folderId?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    completedAt?: SortOrder | $Types.Skip
  }

  export type FileUploadSessionMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    path?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    uploaded?: SortOrder | $Types.Skip
    parts?: SortOrder | $Types.Skip
    mimeType?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    uploadId?: SortOrder | $Types.Skip
    folderId?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    completedAt?: SortOrder | $Types.Skip
  }

  export type FileUploadSessionSumOrderByAggregateInput = {
    size?: SortOrder | $Types.Skip
    uploaded?: SortOrder | $Types.Skip
    parts?: SortOrder | $Types.Skip
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _avg?: NestedFloatFilter<$PrismaModel> | $Types.Skip
    _sum?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _max?: NestedIntFilter<$PrismaModel> | $Types.Skip
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput | $Types.Skip
    some?: FolderWhereInput | $Types.Skip
    none?: FolderWhereInput | $Types.Skip
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput | $Types.Skip
    some?: FileWhereInput | $Types.Skip
    none?: FileWhereInput | $Types.Skip
  }

  export type FileUploadSessionListRelationFilter = {
    every?: FileUploadSessionWhereInput | $Types.Skip
    some?: FileUploadSessionWhereInput | $Types.Skip
    none?: FileUploadSessionWhereInput | $Types.Skip
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type FileUploadSessionOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    parentId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    parentId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    parentId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutNullableScalarRelationFilter = {
    is?: PlaylistLayoutWhereInput | null | $Types.Skip
    isNot?: PlaylistLayoutWhereInput | null | $Types.Skip
  }

  export type PlaylistScreenListRelationFilter = {
    every?: PlaylistScreenWhereInput | $Types.Skip
    some?: PlaylistScreenWhereInput | $Types.Skip
    none?: PlaylistScreenWhereInput | $Types.Skip
  }

  export type PlaylistScheduleListRelationFilter = {
    every?: PlaylistScheduleWhereInput | $Types.Skip
    some?: PlaylistScheduleWhereInput | $Types.Skip
    none?: PlaylistScheduleWhereInput | $Types.Skip
  }

  export type PlaylistScreenOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type PlaylistScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type PlaylistCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    description?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    isPublished?: SortOrder | $Types.Skip
    priority?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistAvgOrderByAggregateInput = {
    size?: SortOrder | $Types.Skip
    priority?: SortOrder | $Types.Skip
  }

  export type PlaylistMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    description?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    isPublished?: SortOrder | $Types.Skip
    priority?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    description?: SortOrder | $Types.Skip
    size?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    isPublished?: SortOrder | $Types.Skip
    priority?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistSumOrderByAggregateInput = {
    size?: SortOrder | $Types.Skip
    priority?: SortOrder | $Types.Skip
  }

  export type EnumPlaylistItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlaylistItemType | EnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    in?: $Enums.PlaylistItemType[] | ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: $Enums.PlaylistItemType[] | ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedEnumPlaylistItemTypeFilter<$PrismaModel> | $Enums.PlaylistItemType | $Types.Skip
  }

  export type PlaylistScalarRelationFilter = {
    is?: PlaylistWhereInput | $Types.Skip
    isNot?: PlaylistWhereInput | $Types.Skip
  }

  export type FileNullableScalarRelationFilter = {
    is?: FileWhereInput | null | $Types.Skip
    isNot?: FileWhereInput | null | $Types.Skip
  }

  export type PlaylistNullableScalarRelationFilter = {
    is?: PlaylistWhereInput | null | $Types.Skip
    isNot?: PlaylistWhereInput | null | $Types.Skip
  }

  export type PlaylistLayoutSectionScalarRelationFilter = {
    is?: PlaylistLayoutSectionWhereInput | $Types.Skip
    isNot?: PlaylistLayoutSectionWhereInput | $Types.Skip
  }

  export type PlaylistItemCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    duration?: SortOrder | $Types.Skip
    playlistLayoutSectionId?: SortOrder | $Types.Skip
    fileId?: SortOrder | $Types.Skip
    nestedPlaylistId?: SortOrder | $Types.Skip
    order?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistItemAvgOrderByAggregateInput = {
    duration?: SortOrder | $Types.Skip
    order?: SortOrder | $Types.Skip
  }

  export type PlaylistItemMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    duration?: SortOrder | $Types.Skip
    playlistLayoutSectionId?: SortOrder | $Types.Skip
    fileId?: SortOrder | $Types.Skip
    nestedPlaylistId?: SortOrder | $Types.Skip
    order?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistItemMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    duration?: SortOrder | $Types.Skip
    playlistLayoutSectionId?: SortOrder | $Types.Skip
    fileId?: SortOrder | $Types.Skip
    nestedPlaylistId?: SortOrder | $Types.Skip
    order?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistItemSumOrderByAggregateInput = {
    duration?: SortOrder | $Types.Skip
    order?: SortOrder | $Types.Skip
  }

  export type EnumPlaylistItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlaylistItemType | EnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    in?: $Enums.PlaylistItemType[] | ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: $Enums.PlaylistItemType[] | ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedEnumPlaylistItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlaylistItemType | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedEnumPlaylistItemTypeFilter<$PrismaModel> | $Types.Skip
    _max?: NestedEnumPlaylistItemTypeFilter<$PrismaModel> | $Types.Skip
  }

  export type PlaylistListRelationFilter = {
    every?: PlaylistWhereInput | $Types.Skip
    some?: PlaylistWhereInput | $Types.Skip
    none?: PlaylistWhereInput | $Types.Skip
  }

  export type PlaylistLayoutSectionListRelationFilter = {
    every?: PlaylistLayoutSectionWhereInput | $Types.Skip
    some?: PlaylistLayoutSectionWhereInput | $Types.Skip
    none?: PlaylistLayoutSectionWhereInput | $Types.Skip
  }

  export type PlaylistOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutSectionOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutAvgOrderByAggregateInput = {
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutSumOrderByAggregateInput = {
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutScalarRelationFilter = {
    is?: PlaylistLayoutWhereInput | $Types.Skip
    isNot?: PlaylistLayoutWhereInput | $Types.Skip
  }

  export type PlaylistLayoutSectionCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    top?: SortOrder | $Types.Skip
    left?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    zIndex?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutSectionAvgOrderByAggregateInput = {
    top?: SortOrder | $Types.Skip
    left?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    zIndex?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutSectionMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    top?: SortOrder | $Types.Skip
    left?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    zIndex?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutSectionMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistLayoutId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    top?: SortOrder | $Types.Skip
    left?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    zIndex?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutSectionSumOrderByAggregateInput = {
    top?: SortOrder | $Types.Skip
    left?: SortOrder | $Types.Skip
    width?: SortOrder | $Types.Skip
    height?: SortOrder | $Types.Skip
    zIndex?: SortOrder | $Types.Skip
  }

  export type EnumWeekdayNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Weekday[] | ListEnumWeekdayFieldRefInput<$PrismaModel> | null | $Types.Skip
    has?: $Enums.Weekday | EnumWeekdayFieldRefInput<$PrismaModel> | null | $Types.Skip
    hasEvery?: $Enums.Weekday[] | ListEnumWeekdayFieldRefInput<$PrismaModel> | $Types.Skip
    hasSome?: $Enums.Weekday[] | ListEnumWeekdayFieldRefInput<$PrismaModel> | $Types.Skip
    isEmpty?: boolean | $Types.Skip
  }

  export type PlaylistScheduleCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    startAt?: SortOrder | $Types.Skip
    endAt?: SortOrder | $Types.Skip
    startTime?: SortOrder | $Types.Skip
    endTime?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    weekdays?: SortOrder | $Types.Skip
  }

  export type PlaylistScheduleMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    startAt?: SortOrder | $Types.Skip
    endAt?: SortOrder | $Types.Skip
    startTime?: SortOrder | $Types.Skip
    endTime?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistScheduleMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    playlistId?: SortOrder | $Types.Skip
    startAt?: SortOrder | $Types.Skip
    endAt?: SortOrder | $Types.Skip
    startTime?: SortOrder | $Types.Skip
    endTime?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type ScreenScalarRelationFilter = {
    is?: ScreenWhereInput | $Types.Skip
    isNot?: ScreenWhereInput | $Types.Skip
  }

  export type PlaylistScreenPlaylistIdScreenIdCompoundUniqueInput = {
    playlistId: string
    screenId: string
  }

  export type PlaylistScreenCountOrderByAggregateInput = {
    playlistId?: SortOrder | $Types.Skip
    screenId?: SortOrder | $Types.Skip
  }

  export type PlaylistScreenMaxOrderByAggregateInput = {
    playlistId?: SortOrder | $Types.Skip
    screenId?: SortOrder | $Types.Skip
  }

  export type PlaylistScreenMinOrderByAggregateInput = {
    playlistId?: SortOrder | $Types.Skip
    screenId?: SortOrder | $Types.Skip
  }

  export type EnumLayoutRotationFilter<$PrismaModel = never> = {
    equals?: $Enums.LayoutRotation | EnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    in?: $Enums.LayoutRotation[] | ListEnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: $Enums.LayoutRotation[] | ListEnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedEnumLayoutRotationFilter<$PrismaModel> | $Enums.LayoutRotation | $Types.Skip
  }

  export type DeviceNullableScalarRelationFilter = {
    is?: DeviceWhereInput | null | $Types.Skip
    isNot?: DeviceWhereInput | null | $Types.Skip
  }

  export type ScreenGroupNullableScalarRelationFilter = {
    is?: ScreenGroupWhereInput | null | $Types.Skip
    isNot?: ScreenGroupWhereInput | null | $Types.Skip
  }

  export type ScreenCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    groupId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    layoutRotation?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type ScreenAvgOrderByAggregateInput = {
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
  }

  export type ScreenMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    groupId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    layoutRotation?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type ScreenMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    groupId?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    layoutRotation?: SortOrder | $Types.Skip
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
    type?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type ScreenSumOrderByAggregateInput = {
    resolutionWidth?: SortOrder | $Types.Skip
    resolutionHeight?: SortOrder | $Types.Skip
  }

  export type EnumLayoutRotationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LayoutRotation | EnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    in?: $Enums.LayoutRotation[] | ListEnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: $Enums.LayoutRotation[] | ListEnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedEnumLayoutRotationWithAggregatesFilter<$PrismaModel> | $Enums.LayoutRotation | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedEnumLayoutRotationFilter<$PrismaModel> | $Types.Skip
    _max?: NestedEnumLayoutRotationFilter<$PrismaModel> | $Types.Skip
  }

  export type ScreenListRelationFilter = {
    every?: ScreenWhereInput | $Types.Skip
    some?: ScreenWhereInput | $Types.Skip
    none?: ScreenWhereInput | $Types.Skip
  }

  export type ScreenOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type ScreenGroupCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type ScreenGroupMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type ScreenGroupMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userAgent?: SortOrder | $Types.Skip
    ipAddress?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    revokedAt?: SortOrder | $Types.Skip
    lastActivityAt?: SortOrder | $Types.Skip
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userAgent?: SortOrder | $Types.Skip
    ipAddress?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    revokedAt?: SortOrder | $Types.Skip
    lastActivityAt?: SortOrder | $Types.Skip
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    token?: SortOrder | $Types.Skip
    userAgent?: SortOrder | $Types.Skip
    ipAddress?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    revokedAt?: SortOrder | $Types.Skip
    lastActivityAt?: SortOrder | $Types.Skip
  }

  export type EmailVerificationTokenListRelationFilter = {
    every?: EmailVerificationTokenWhereInput | $Types.Skip
    some?: EmailVerificationTokenWhereInput | $Types.Skip
    none?: EmailVerificationTokenWhereInput | $Types.Skip
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput | $Types.Skip
    some?: SessionWhereInput | $Types.Skip
    none?: SessionWhereInput | $Types.Skip
  }

  export type UserWorkspaceListRelationFilter = {
    every?: UserWorkspaceWhereInput | $Types.Skip
    some?: UserWorkspaceWhereInput | $Types.Skip
    none?: UserWorkspaceWhereInput | $Types.Skip
  }

  export type UserPreferencesListRelationFilter = {
    every?: UserPreferencesWhereInput | $Types.Skip
    some?: UserPreferencesWhereInput | $Types.Skip
    none?: UserPreferencesWhereInput | $Types.Skip
  }

  export type WorkspaceUserInvitationListRelationFilter = {
    every?: WorkspaceUserInvitationWhereInput | $Types.Skip
    some?: WorkspaceUserInvitationWhereInput | $Types.Skip
    none?: WorkspaceUserInvitationWhereInput | $Types.Skip
  }

  export type EmailVerificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type UserWorkspaceOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type UserPreferencesOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type WorkspaceUserInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    emailVerifiedAt?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    password?: SortOrder | $Types.Skip
    profilePhoto?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    emailVerifiedAt?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    password?: SortOrder | $Types.Skip
    profilePhoto?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    emailVerifiedAt?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    password?: SortOrder | $Types.Skip
    profilePhoto?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
    deletedAt?: SortOrder | $Types.Skip
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    locale?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    locale?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    userId?: SortOrder | $Types.Skip
    locale?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    has?: string | StringFieldRefInput<$PrismaModel> | null | $Types.Skip
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    isEmpty?: boolean | $Types.Skip
  }

  export type WorkspaceUserInvitationNullableScalarRelationFilter = {
    is?: WorkspaceUserInvitationWhereInput | null | $Types.Skip
    isNot?: WorkspaceUserInvitationWhereInput | null | $Types.Skip
  }

  export type UserWorkspaceUserIdWorkspaceIdCompoundUniqueInput = {
    userId: string
    workspaceId: string
  }

  export type UserWorkspaceCountOrderByAggregateInput = {
    userId?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    workspaceInvitationId?: SortOrder | $Types.Skip
    role?: SortOrder | $Types.Skip
    permissions?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type UserWorkspaceMaxOrderByAggregateInput = {
    userId?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    workspaceInvitationId?: SortOrder | $Types.Skip
    role?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type UserWorkspaceMinOrderByAggregateInput = {
    userId?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    workspaceInvitationId?: SortOrder | $Types.Skip
    role?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type PlaylistLayoutListRelationFilter = {
    every?: PlaylistLayoutWhereInput | $Types.Skip
    some?: PlaylistLayoutWhereInput | $Types.Skip
    none?: PlaylistLayoutWhereInput | $Types.Skip
  }

  export type ScreenGroupListRelationFilter = {
    every?: ScreenGroupWhereInput | $Types.Skip
    some?: ScreenGroupWhereInput | $Types.Skip
    none?: ScreenGroupWhereInput | $Types.Skip
  }

  export type PlaylistLayoutOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type ScreenGroupOrderByRelationAggregateInput = {
    _count?: SortOrder | $Types.Skip
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    slug?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    picture?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    slug?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    picture?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    name?: SortOrder | $Types.Skip
    slug?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    picture?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type WorkspaceUserInvitationCountOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    invitorId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type WorkspaceUserInvitationMaxOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    invitorId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type WorkspaceUserInvitationMinOrderByAggregateInput = {
    id?: SortOrder | $Types.Skip
    email?: SortOrder | $Types.Skip
    status?: SortOrder | $Types.Skip
    workspaceId?: SortOrder | $Types.Skip
    invitorId?: SortOrder | $Types.Skip
    createdAt?: SortOrder | $Types.Skip
    updatedAt?: SortOrder | $Types.Skip
  }

  export type ScreenCreateNestedOneWithoutDeviceInput = {
    create?: XOR<ScreenCreateWithoutDeviceInput, ScreenUncheckedCreateWithoutDeviceInput> | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutDeviceInput | $Types.Skip
    connect?: ScreenWhereUniqueInput | $Types.Skip
  }

  export type DeviceTelemetryCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceTelemetryCreateWithoutDeviceInput, DeviceTelemetryUncheckedCreateWithoutDeviceInput> | DeviceTelemetryCreateWithoutDeviceInput[] | DeviceTelemetryUncheckedCreateWithoutDeviceInput[] | $Types.Skip
    connectOrCreate?: DeviceTelemetryCreateOrConnectWithoutDeviceInput | DeviceTelemetryCreateOrConnectWithoutDeviceInput[] | $Types.Skip
    createMany?: DeviceTelemetryCreateManyDeviceInputEnvelope | $Types.Skip
    connect?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
  }

  export type DeviceStatusCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceStatusCreateWithoutDeviceInput, DeviceStatusUncheckedCreateWithoutDeviceInput> | DeviceStatusCreateWithoutDeviceInput[] | DeviceStatusUncheckedCreateWithoutDeviceInput[] | $Types.Skip
    connectOrCreate?: DeviceStatusCreateOrConnectWithoutDeviceInput | DeviceStatusCreateOrConnectWithoutDeviceInput[] | $Types.Skip
    createMany?: DeviceStatusCreateManyDeviceInputEnvelope | $Types.Skip
    connect?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
  }

  export type DeviceTelemetryUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceTelemetryCreateWithoutDeviceInput, DeviceTelemetryUncheckedCreateWithoutDeviceInput> | DeviceTelemetryCreateWithoutDeviceInput[] | DeviceTelemetryUncheckedCreateWithoutDeviceInput[] | $Types.Skip
    connectOrCreate?: DeviceTelemetryCreateOrConnectWithoutDeviceInput | DeviceTelemetryCreateOrConnectWithoutDeviceInput[] | $Types.Skip
    createMany?: DeviceTelemetryCreateManyDeviceInputEnvelope | $Types.Skip
    connect?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
  }

  export type DeviceStatusUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceStatusCreateWithoutDeviceInput, DeviceStatusUncheckedCreateWithoutDeviceInput> | DeviceStatusCreateWithoutDeviceInput[] | DeviceStatusUncheckedCreateWithoutDeviceInput[] | $Types.Skip
    connectOrCreate?: DeviceStatusCreateOrConnectWithoutDeviceInput | DeviceStatusCreateOrConnectWithoutDeviceInput[] | $Types.Skip
    createMany?: DeviceStatusCreateManyDeviceInputEnvelope | $Types.Skip
    connect?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string | $Types.Skip
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string | $Types.Skip
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean | $Types.Skip
  }

  export type ScreenUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<ScreenCreateWithoutDeviceInput, ScreenUncheckedCreateWithoutDeviceInput> | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutDeviceInput | $Types.Skip
    upsert?: ScreenUpsertWithoutDeviceInput | $Types.Skip
    disconnect?: ScreenWhereInput | boolean | $Types.Skip
    delete?: ScreenWhereInput | boolean | $Types.Skip
    connect?: ScreenWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<ScreenUpdateToOneWithWhereWithoutDeviceInput, ScreenUpdateWithoutDeviceInput>, ScreenUncheckedUpdateWithoutDeviceInput> | $Types.Skip
  }

  export type DeviceTelemetryUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceTelemetryCreateWithoutDeviceInput, DeviceTelemetryUncheckedCreateWithoutDeviceInput> | DeviceTelemetryCreateWithoutDeviceInput[] | DeviceTelemetryUncheckedCreateWithoutDeviceInput[] | $Types.Skip
    connectOrCreate?: DeviceTelemetryCreateOrConnectWithoutDeviceInput | DeviceTelemetryCreateOrConnectWithoutDeviceInput[] | $Types.Skip
    upsert?: DeviceTelemetryUpsertWithWhereUniqueWithoutDeviceInput | DeviceTelemetryUpsertWithWhereUniqueWithoutDeviceInput[] | $Types.Skip
    createMany?: DeviceTelemetryCreateManyDeviceInputEnvelope | $Types.Skip
    set?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
    disconnect?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
    delete?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
    connect?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
    update?: DeviceTelemetryUpdateWithWhereUniqueWithoutDeviceInput | DeviceTelemetryUpdateWithWhereUniqueWithoutDeviceInput[] | $Types.Skip
    updateMany?: DeviceTelemetryUpdateManyWithWhereWithoutDeviceInput | DeviceTelemetryUpdateManyWithWhereWithoutDeviceInput[] | $Types.Skip
    deleteMany?: DeviceTelemetryScalarWhereInput | DeviceTelemetryScalarWhereInput[] | $Types.Skip
  }

  export type DeviceStatusUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceStatusCreateWithoutDeviceInput, DeviceStatusUncheckedCreateWithoutDeviceInput> | DeviceStatusCreateWithoutDeviceInput[] | DeviceStatusUncheckedCreateWithoutDeviceInput[] | $Types.Skip
    connectOrCreate?: DeviceStatusCreateOrConnectWithoutDeviceInput | DeviceStatusCreateOrConnectWithoutDeviceInput[] | $Types.Skip
    upsert?: DeviceStatusUpsertWithWhereUniqueWithoutDeviceInput | DeviceStatusUpsertWithWhereUniqueWithoutDeviceInput[] | $Types.Skip
    createMany?: DeviceStatusCreateManyDeviceInputEnvelope | $Types.Skip
    set?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
    disconnect?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
    delete?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
    connect?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
    update?: DeviceStatusUpdateWithWhereUniqueWithoutDeviceInput | DeviceStatusUpdateWithWhereUniqueWithoutDeviceInput[] | $Types.Skip
    updateMany?: DeviceStatusUpdateManyWithWhereWithoutDeviceInput | DeviceStatusUpdateManyWithWhereWithoutDeviceInput[] | $Types.Skip
    deleteMany?: DeviceStatusScalarWhereInput | DeviceStatusScalarWhereInput[] | $Types.Skip
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null | $Types.Skip
  }

  export type DeviceTelemetryUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceTelemetryCreateWithoutDeviceInput, DeviceTelemetryUncheckedCreateWithoutDeviceInput> | DeviceTelemetryCreateWithoutDeviceInput[] | DeviceTelemetryUncheckedCreateWithoutDeviceInput[] | $Types.Skip
    connectOrCreate?: DeviceTelemetryCreateOrConnectWithoutDeviceInput | DeviceTelemetryCreateOrConnectWithoutDeviceInput[] | $Types.Skip
    upsert?: DeviceTelemetryUpsertWithWhereUniqueWithoutDeviceInput | DeviceTelemetryUpsertWithWhereUniqueWithoutDeviceInput[] | $Types.Skip
    createMany?: DeviceTelemetryCreateManyDeviceInputEnvelope | $Types.Skip
    set?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
    disconnect?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
    delete?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
    connect?: DeviceTelemetryWhereUniqueInput | DeviceTelemetryWhereUniqueInput[] | $Types.Skip
    update?: DeviceTelemetryUpdateWithWhereUniqueWithoutDeviceInput | DeviceTelemetryUpdateWithWhereUniqueWithoutDeviceInput[] | $Types.Skip
    updateMany?: DeviceTelemetryUpdateManyWithWhereWithoutDeviceInput | DeviceTelemetryUpdateManyWithWhereWithoutDeviceInput[] | $Types.Skip
    deleteMany?: DeviceTelemetryScalarWhereInput | DeviceTelemetryScalarWhereInput[] | $Types.Skip
  }

  export type DeviceStatusUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceStatusCreateWithoutDeviceInput, DeviceStatusUncheckedCreateWithoutDeviceInput> | DeviceStatusCreateWithoutDeviceInput[] | DeviceStatusUncheckedCreateWithoutDeviceInput[] | $Types.Skip
    connectOrCreate?: DeviceStatusCreateOrConnectWithoutDeviceInput | DeviceStatusCreateOrConnectWithoutDeviceInput[] | $Types.Skip
    upsert?: DeviceStatusUpsertWithWhereUniqueWithoutDeviceInput | DeviceStatusUpsertWithWhereUniqueWithoutDeviceInput[] | $Types.Skip
    createMany?: DeviceStatusCreateManyDeviceInputEnvelope | $Types.Skip
    set?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
    disconnect?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
    delete?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
    connect?: DeviceStatusWhereUniqueInput | DeviceStatusWhereUniqueInput[] | $Types.Skip
    update?: DeviceStatusUpdateWithWhereUniqueWithoutDeviceInput | DeviceStatusUpdateWithWhereUniqueWithoutDeviceInput[] | $Types.Skip
    updateMany?: DeviceStatusUpdateManyWithWhereWithoutDeviceInput | DeviceStatusUpdateManyWithWhereWithoutDeviceInput[] | $Types.Skip
    deleteMany?: DeviceStatusScalarWhereInput | DeviceStatusScalarWhereInput[] | $Types.Skip
  }

  export type DeviceCreateNestedOneWithoutStatusLogInput = {
    create?: XOR<DeviceCreateWithoutStatusLogInput, DeviceUncheckedCreateWithoutStatusLogInput> | $Types.Skip
    connectOrCreate?: DeviceCreateOrConnectWithoutStatusLogInput | $Types.Skip
    connect?: DeviceWhereUniqueInput | $Types.Skip
  }

  export type DeviceUpdateOneRequiredWithoutStatusLogNestedInput = {
    create?: XOR<DeviceCreateWithoutStatusLogInput, DeviceUncheckedCreateWithoutStatusLogInput> | $Types.Skip
    connectOrCreate?: DeviceCreateOrConnectWithoutStatusLogInput | $Types.Skip
    upsert?: DeviceUpsertWithoutStatusLogInput | $Types.Skip
    connect?: DeviceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutStatusLogInput, DeviceUpdateWithoutStatusLogInput>, DeviceUncheckedUpdateWithoutStatusLogInput> | $Types.Skip
  }

  export type DeviceCreateNestedOneWithoutTelemetryInput = {
    create?: XOR<DeviceCreateWithoutTelemetryInput, DeviceUncheckedCreateWithoutTelemetryInput> | $Types.Skip
    connectOrCreate?: DeviceCreateOrConnectWithoutTelemetryInput | $Types.Skip
    connect?: DeviceWhereUniqueInput | $Types.Skip
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null | $Types.Skip
    increment?: number | $Types.Skip
    decrement?: number | $Types.Skip
    multiply?: number | $Types.Skip
    divide?: number | $Types.Skip
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null | $Types.Skip
    increment?: bigint | number | $Types.Skip
    decrement?: bigint | number | $Types.Skip
    multiply?: bigint | number | $Types.Skip
    divide?: bigint | number | $Types.Skip
  }

  export type DeviceUpdateOneRequiredWithoutTelemetryNestedInput = {
    create?: XOR<DeviceCreateWithoutTelemetryInput, DeviceUncheckedCreateWithoutTelemetryInput> | $Types.Skip
    connectOrCreate?: DeviceCreateOrConnectWithoutTelemetryInput | $Types.Skip
    upsert?: DeviceUpsertWithoutTelemetryInput | $Types.Skip
    connect?: DeviceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutTelemetryInput, DeviceUpdateWithoutTelemetryInput>, DeviceUncheckedUpdateWithoutTelemetryInput> | $Types.Skip
  }

  export type UserCreateNestedOneWithoutEmailVerificationTokensInput = {
    create?: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
  }

  export type UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput = {
    create?: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput | $Types.Skip
    upsert?: UserUpsertWithoutEmailVerificationTokensInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput, UserUpdateWithoutEmailVerificationTokensInput>, UserUncheckedUpdateWithoutEmailVerificationTokensInput> | $Types.Skip
  }

  export type FolderCreateNestedOneWithoutFilesInput = {
    create?: XOR<FolderCreateWithoutFilesInput, FolderUncheckedCreateWithoutFilesInput> | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutFilesInput | $Types.Skip
    connect?: FolderWhereUniqueInput | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutFilesInput = {
    create?: XOR<WorkspaceCreateWithoutFilesInput, WorkspaceUncheckedCreateWithoutFilesInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFilesInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type UserCreateNestedOneWithoutUploadedFilesInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
  }

  export type PlaylistItemCreateNestedManyWithoutFileInput = {
    create?: XOR<PlaylistItemCreateWithoutFileInput, PlaylistItemUncheckedCreateWithoutFileInput> | PlaylistItemCreateWithoutFileInput[] | PlaylistItemUncheckedCreateWithoutFileInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutFileInput | PlaylistItemCreateOrConnectWithoutFileInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyFileInputEnvelope | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistItemUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<PlaylistItemCreateWithoutFileInput, PlaylistItemUncheckedCreateWithoutFileInput> | PlaylistItemCreateWithoutFileInput[] | PlaylistItemUncheckedCreateWithoutFileInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutFileInput | PlaylistItemCreateOrConnectWithoutFileInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyFileInputEnvelope | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number | $Types.Skip
    increment?: bigint | number | $Types.Skip
    decrement?: bigint | number | $Types.Skip
    multiply?: bigint | number | $Types.Skip
    divide?: bigint | number | $Types.Skip
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null | $Types.Skip
  }

  export type FolderUpdateOneWithoutFilesNestedInput = {
    create?: XOR<FolderCreateWithoutFilesInput, FolderUncheckedCreateWithoutFilesInput> | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutFilesInput | $Types.Skip
    upsert?: FolderUpsertWithoutFilesInput | $Types.Skip
    disconnect?: FolderWhereInput | boolean | $Types.Skip
    delete?: FolderWhereInput | boolean | $Types.Skip
    connect?: FolderWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutFilesInput, FolderUpdateWithoutFilesInput>, FolderUncheckedUpdateWithoutFilesInput> | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutFilesInput, WorkspaceUncheckedCreateWithoutFilesInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFilesInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutFilesInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutFilesInput, WorkspaceUpdateWithoutFilesInput>, WorkspaceUncheckedUpdateWithoutFilesInput> | $Types.Skip
  }

  export type UserUpdateOneWithoutUploadedFilesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput | $Types.Skip
    upsert?: UserUpsertWithoutUploadedFilesInput | $Types.Skip
    disconnect?: UserWhereInput | boolean | $Types.Skip
    delete?: UserWhereInput | boolean | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedFilesInput, UserUpdateWithoutUploadedFilesInput>, UserUncheckedUpdateWithoutUploadedFilesInput> | $Types.Skip
  }

  export type PlaylistItemUpdateManyWithoutFileNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutFileInput, PlaylistItemUncheckedCreateWithoutFileInput> | PlaylistItemCreateWithoutFileInput[] | PlaylistItemUncheckedCreateWithoutFileInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutFileInput | PlaylistItemCreateOrConnectWithoutFileInput[] | $Types.Skip
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutFileInput | PlaylistItemUpsertWithWhereUniqueWithoutFileInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyFileInputEnvelope | $Types.Skip
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    update?: PlaylistItemUpdateWithWhereUniqueWithoutFileInput | PlaylistItemUpdateWithWhereUniqueWithoutFileInput[] | $Types.Skip
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutFileInput | PlaylistItemUpdateManyWithWhereWithoutFileInput[] | $Types.Skip
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutFileInput, PlaylistItemUncheckedCreateWithoutFileInput> | PlaylistItemCreateWithoutFileInput[] | PlaylistItemUncheckedCreateWithoutFileInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutFileInput | PlaylistItemCreateOrConnectWithoutFileInput[] | $Types.Skip
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutFileInput | PlaylistItemUpsertWithWhereUniqueWithoutFileInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyFileInputEnvelope | $Types.Skip
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    update?: PlaylistItemUpdateWithWhereUniqueWithoutFileInput | PlaylistItemUpdateWithWhereUniqueWithoutFileInput[] | $Types.Skip
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutFileInput | PlaylistItemUpdateManyWithWhereWithoutFileInput[] | $Types.Skip
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
  }

  export type FolderCreateNestedOneWithoutFileUploadSessionsInput = {
    create?: XOR<FolderCreateWithoutFileUploadSessionsInput, FolderUncheckedCreateWithoutFileUploadSessionsInput> | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutFileUploadSessionsInput | $Types.Skip
    connect?: FolderWhereUniqueInput | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutFileUploadSessionsInput = {
    create?: XOR<WorkspaceCreateWithoutFileUploadSessionsInput, WorkspaceUncheckedCreateWithoutFileUploadSessionsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFileUploadSessionsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type UserCreateNestedOneWithoutFileUploadSessionsInput = {
    create?: XOR<UserCreateWithoutFileUploadSessionsInput, UserUncheckedCreateWithoutFileUploadSessionsInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutFileUploadSessionsInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number | $Types.Skip
    increment?: number | $Types.Skip
    decrement?: number | $Types.Skip
    multiply?: number | $Types.Skip
    divide?: number | $Types.Skip
  }

  export type FolderUpdateOneWithoutFileUploadSessionsNestedInput = {
    create?: XOR<FolderCreateWithoutFileUploadSessionsInput, FolderUncheckedCreateWithoutFileUploadSessionsInput> | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutFileUploadSessionsInput | $Types.Skip
    upsert?: FolderUpsertWithoutFileUploadSessionsInput | $Types.Skip
    disconnect?: FolderWhereInput | boolean | $Types.Skip
    delete?: FolderWhereInput | boolean | $Types.Skip
    connect?: FolderWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutFileUploadSessionsInput, FolderUpdateWithoutFileUploadSessionsInput>, FolderUncheckedUpdateWithoutFileUploadSessionsInput> | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutFileUploadSessionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutFileUploadSessionsInput, WorkspaceUncheckedCreateWithoutFileUploadSessionsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFileUploadSessionsInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutFileUploadSessionsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutFileUploadSessionsInput, WorkspaceUpdateWithoutFileUploadSessionsInput>, WorkspaceUncheckedUpdateWithoutFileUploadSessionsInput> | $Types.Skip
  }

  export type UserUpdateOneRequiredWithoutFileUploadSessionsNestedInput = {
    create?: XOR<UserCreateWithoutFileUploadSessionsInput, UserUncheckedCreateWithoutFileUploadSessionsInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutFileUploadSessionsInput | $Types.Skip
    upsert?: UserUpsertWithoutFileUploadSessionsInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFileUploadSessionsInput, UserUpdateWithoutFileUploadSessionsInput>, UserUncheckedUpdateWithoutFileUploadSessionsInput> | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutFoldersInput = {
    create?: XOR<WorkspaceCreateWithoutFoldersInput, WorkspaceUncheckedCreateWithoutFoldersInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFoldersInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type FolderCreateNestedOneWithoutSubfoldersInput = {
    create?: XOR<FolderCreateWithoutSubfoldersInput, FolderUncheckedCreateWithoutSubfoldersInput> | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutSubfoldersInput | $Types.Skip
    connect?: FolderWhereUniqueInput | $Types.Skip
  }

  export type FolderCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[] | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[] | $Types.Skip
    createMany?: FolderCreateManyParentInputEnvelope | $Types.Skip
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
  }

  export type FileCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[] | $Types.Skip
    createMany?: FileCreateManyFolderInputEnvelope | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
  }

  export type FileUploadSessionCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileUploadSessionCreateWithoutFolderInput, FileUploadSessionUncheckedCreateWithoutFolderInput> | FileUploadSessionCreateWithoutFolderInput[] | FileUploadSessionUncheckedCreateWithoutFolderInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutFolderInput | FileUploadSessionCreateOrConnectWithoutFolderInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyFolderInputEnvelope | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
  }

  export type FolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[] | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[] | $Types.Skip
    createMany?: FolderCreateManyParentInputEnvelope | $Types.Skip
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
  }

  export type FileUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[] | $Types.Skip
    createMany?: FileCreateManyFolderInputEnvelope | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
  }

  export type FileUploadSessionUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileUploadSessionCreateWithoutFolderInput, FileUploadSessionUncheckedCreateWithoutFolderInput> | FileUploadSessionCreateWithoutFolderInput[] | FileUploadSessionUncheckedCreateWithoutFolderInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutFolderInput | FileUploadSessionCreateOrConnectWithoutFolderInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyFolderInputEnvelope | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutFoldersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutFoldersInput, WorkspaceUncheckedCreateWithoutFoldersInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFoldersInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutFoldersInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutFoldersInput, WorkspaceUpdateWithoutFoldersInput>, WorkspaceUncheckedUpdateWithoutFoldersInput> | $Types.Skip
  }

  export type FolderUpdateOneWithoutSubfoldersNestedInput = {
    create?: XOR<FolderCreateWithoutSubfoldersInput, FolderUncheckedCreateWithoutSubfoldersInput> | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutSubfoldersInput | $Types.Skip
    upsert?: FolderUpsertWithoutSubfoldersInput | $Types.Skip
    disconnect?: FolderWhereInput | boolean | $Types.Skip
    delete?: FolderWhereInput | boolean | $Types.Skip
    connect?: FolderWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutSubfoldersInput, FolderUpdateWithoutSubfoldersInput>, FolderUncheckedUpdateWithoutSubfoldersInput> | $Types.Skip
  }

  export type FolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[] | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[] | $Types.Skip
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[] | $Types.Skip
    createMany?: FolderCreateManyParentInputEnvelope | $Types.Skip
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[] | $Types.Skip
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[] | $Types.Skip
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[] | $Types.Skip
  }

  export type FileUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[] | $Types.Skip
    upsert?: FileUpsertWithWhereUniqueWithoutFolderInput | FileUpsertWithWhereUniqueWithoutFolderInput[] | $Types.Skip
    createMany?: FileCreateManyFolderInputEnvelope | $Types.Skip
    set?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    update?: FileUpdateWithWhereUniqueWithoutFolderInput | FileUpdateWithWhereUniqueWithoutFolderInput[] | $Types.Skip
    updateMany?: FileUpdateManyWithWhereWithoutFolderInput | FileUpdateManyWithWhereWithoutFolderInput[] | $Types.Skip
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[] | $Types.Skip
  }

  export type FileUploadSessionUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileUploadSessionCreateWithoutFolderInput, FileUploadSessionUncheckedCreateWithoutFolderInput> | FileUploadSessionCreateWithoutFolderInput[] | FileUploadSessionUncheckedCreateWithoutFolderInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutFolderInput | FileUploadSessionCreateOrConnectWithoutFolderInput[] | $Types.Skip
    upsert?: FileUploadSessionUpsertWithWhereUniqueWithoutFolderInput | FileUploadSessionUpsertWithWhereUniqueWithoutFolderInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyFolderInputEnvelope | $Types.Skip
    set?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    disconnect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    delete?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    update?: FileUploadSessionUpdateWithWhereUniqueWithoutFolderInput | FileUploadSessionUpdateWithWhereUniqueWithoutFolderInput[] | $Types.Skip
    updateMany?: FileUploadSessionUpdateManyWithWhereWithoutFolderInput | FileUploadSessionUpdateManyWithWhereWithoutFolderInput[] | $Types.Skip
    deleteMany?: FileUploadSessionScalarWhereInput | FileUploadSessionScalarWhereInput[] | $Types.Skip
  }

  export type FolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[] | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[] | $Types.Skip
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[] | $Types.Skip
    createMany?: FolderCreateManyParentInputEnvelope | $Types.Skip
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[] | $Types.Skip
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[] | $Types.Skip
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[] | $Types.Skip
  }

  export type FileUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[] | $Types.Skip
    upsert?: FileUpsertWithWhereUniqueWithoutFolderInput | FileUpsertWithWhereUniqueWithoutFolderInput[] | $Types.Skip
    createMany?: FileCreateManyFolderInputEnvelope | $Types.Skip
    set?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    update?: FileUpdateWithWhereUniqueWithoutFolderInput | FileUpdateWithWhereUniqueWithoutFolderInput[] | $Types.Skip
    updateMany?: FileUpdateManyWithWhereWithoutFolderInput | FileUpdateManyWithWhereWithoutFolderInput[] | $Types.Skip
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[] | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileUploadSessionCreateWithoutFolderInput, FileUploadSessionUncheckedCreateWithoutFolderInput> | FileUploadSessionCreateWithoutFolderInput[] | FileUploadSessionUncheckedCreateWithoutFolderInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutFolderInput | FileUploadSessionCreateOrConnectWithoutFolderInput[] | $Types.Skip
    upsert?: FileUploadSessionUpsertWithWhereUniqueWithoutFolderInput | FileUploadSessionUpsertWithWhereUniqueWithoutFolderInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyFolderInputEnvelope | $Types.Skip
    set?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    disconnect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    delete?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    update?: FileUploadSessionUpdateWithWhereUniqueWithoutFolderInput | FileUploadSessionUpdateWithWhereUniqueWithoutFolderInput[] | $Types.Skip
    updateMany?: FileUploadSessionUpdateManyWithWhereWithoutFolderInput | FileUploadSessionUpdateManyWithWhereWithoutFolderInput[] | $Types.Skip
    deleteMany?: FileUploadSessionScalarWhereInput | FileUploadSessionScalarWhereInput[] | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<WorkspaceCreateWithoutPlaylistsInput, WorkspaceUncheckedCreateWithoutPlaylistsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutPlaylistsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type PlaylistLayoutCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<PlaylistLayoutCreateWithoutPlaylistsInput, PlaylistLayoutUncheckedCreateWithoutPlaylistsInput> | $Types.Skip
    connectOrCreate?: PlaylistLayoutCreateOrConnectWithoutPlaylistsInput | $Types.Skip
    connect?: PlaylistLayoutWhereUniqueInput | $Types.Skip
  }

  export type PlaylistItemCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput> | PlaylistItemCreateWithoutPlaylistInput[] | PlaylistItemUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistInput | PlaylistItemCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyPlaylistInputEnvelope | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistItemCreateNestedManyWithoutNestedPlaylistInput = {
    create?: XOR<PlaylistItemCreateWithoutNestedPlaylistInput, PlaylistItemUncheckedCreateWithoutNestedPlaylistInput> | PlaylistItemCreateWithoutNestedPlaylistInput[] | PlaylistItemUncheckedCreateWithoutNestedPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutNestedPlaylistInput | PlaylistItemCreateOrConnectWithoutNestedPlaylistInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyNestedPlaylistInputEnvelope | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistScreenCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistScreenCreateWithoutPlaylistInput, PlaylistScreenUncheckedCreateWithoutPlaylistInput> | PlaylistScreenCreateWithoutPlaylistInput[] | PlaylistScreenUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistScreenCreateOrConnectWithoutPlaylistInput | PlaylistScreenCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistScreenCreateManyPlaylistInputEnvelope | $Types.Skip
    connect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistScheduleCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistScheduleCreateWithoutPlaylistInput, PlaylistScheduleUncheckedCreateWithoutPlaylistInput> | PlaylistScheduleCreateWithoutPlaylistInput[] | PlaylistScheduleUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistScheduleCreateOrConnectWithoutPlaylistInput | PlaylistScheduleCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistScheduleCreateManyPlaylistInputEnvelope | $Types.Skip
    connect?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput> | PlaylistItemCreateWithoutPlaylistInput[] | PlaylistItemUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistInput | PlaylistItemCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyPlaylistInputEnvelope | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistItemUncheckedCreateNestedManyWithoutNestedPlaylistInput = {
    create?: XOR<PlaylistItemCreateWithoutNestedPlaylistInput, PlaylistItemUncheckedCreateWithoutNestedPlaylistInput> | PlaylistItemCreateWithoutNestedPlaylistInput[] | PlaylistItemUncheckedCreateWithoutNestedPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutNestedPlaylistInput | PlaylistItemCreateOrConnectWithoutNestedPlaylistInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyNestedPlaylistInputEnvelope | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistScreenUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistScreenCreateWithoutPlaylistInput, PlaylistScreenUncheckedCreateWithoutPlaylistInput> | PlaylistScreenCreateWithoutPlaylistInput[] | PlaylistScreenUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistScreenCreateOrConnectWithoutPlaylistInput | PlaylistScreenCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistScreenCreateManyPlaylistInputEnvelope | $Types.Skip
    connect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistScheduleUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistScheduleCreateWithoutPlaylistInput, PlaylistScheduleUncheckedCreateWithoutPlaylistInput> | PlaylistScheduleCreateWithoutPlaylistInput[] | PlaylistScheduleUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistScheduleCreateOrConnectWithoutPlaylistInput | PlaylistScheduleCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistScheduleCreateManyPlaylistInputEnvelope | $Types.Skip
    connect?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutPlaylistsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutPlaylistsInput, WorkspaceUncheckedCreateWithoutPlaylistsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutPlaylistsInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutPlaylistsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutPlaylistsInput, WorkspaceUpdateWithoutPlaylistsInput>, WorkspaceUncheckedUpdateWithoutPlaylistsInput> | $Types.Skip
  }

  export type PlaylistLayoutUpdateOneWithoutPlaylistsNestedInput = {
    create?: XOR<PlaylistLayoutCreateWithoutPlaylistsInput, PlaylistLayoutUncheckedCreateWithoutPlaylistsInput> | $Types.Skip
    connectOrCreate?: PlaylistLayoutCreateOrConnectWithoutPlaylistsInput | $Types.Skip
    upsert?: PlaylistLayoutUpsertWithoutPlaylistsInput | $Types.Skip
    disconnect?: PlaylistLayoutWhereInput | boolean | $Types.Skip
    delete?: PlaylistLayoutWhereInput | boolean | $Types.Skip
    connect?: PlaylistLayoutWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<PlaylistLayoutUpdateToOneWithWhereWithoutPlaylistsInput, PlaylistLayoutUpdateWithoutPlaylistsInput>, PlaylistLayoutUncheckedUpdateWithoutPlaylistsInput> | $Types.Skip
  }

  export type PlaylistItemUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput> | PlaylistItemCreateWithoutPlaylistInput[] | PlaylistItemUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistInput | PlaylistItemCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyPlaylistInputEnvelope | $Types.Skip
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    update?: PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutPlaylistInput | PlaylistItemUpdateManyWithWhereWithoutPlaylistInput[] | $Types.Skip
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistItemUpdateManyWithoutNestedPlaylistNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutNestedPlaylistInput, PlaylistItemUncheckedCreateWithoutNestedPlaylistInput> | PlaylistItemCreateWithoutNestedPlaylistInput[] | PlaylistItemUncheckedCreateWithoutNestedPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutNestedPlaylistInput | PlaylistItemCreateOrConnectWithoutNestedPlaylistInput[] | $Types.Skip
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutNestedPlaylistInput | PlaylistItemUpsertWithWhereUniqueWithoutNestedPlaylistInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyNestedPlaylistInputEnvelope | $Types.Skip
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    update?: PlaylistItemUpdateWithWhereUniqueWithoutNestedPlaylistInput | PlaylistItemUpdateWithWhereUniqueWithoutNestedPlaylistInput[] | $Types.Skip
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutNestedPlaylistInput | PlaylistItemUpdateManyWithWhereWithoutNestedPlaylistInput[] | $Types.Skip
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistScreenUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistScreenCreateWithoutPlaylistInput, PlaylistScreenUncheckedCreateWithoutPlaylistInput> | PlaylistScreenCreateWithoutPlaylistInput[] | PlaylistScreenUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistScreenCreateOrConnectWithoutPlaylistInput | PlaylistScreenCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    upsert?: PlaylistScreenUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistScreenUpsertWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistScreenCreateManyPlaylistInputEnvelope | $Types.Skip
    set?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    update?: PlaylistScreenUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistScreenUpdateWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    updateMany?: PlaylistScreenUpdateManyWithWhereWithoutPlaylistInput | PlaylistScreenUpdateManyWithWhereWithoutPlaylistInput[] | $Types.Skip
    deleteMany?: PlaylistScreenScalarWhereInput | PlaylistScreenScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistScheduleUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistScheduleCreateWithoutPlaylistInput, PlaylistScheduleUncheckedCreateWithoutPlaylistInput> | PlaylistScheduleCreateWithoutPlaylistInput[] | PlaylistScheduleUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistScheduleCreateOrConnectWithoutPlaylistInput | PlaylistScheduleCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    upsert?: PlaylistScheduleUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistScheduleUpsertWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistScheduleCreateManyPlaylistInputEnvelope | $Types.Skip
    set?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
    update?: PlaylistScheduleUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistScheduleUpdateWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    updateMany?: PlaylistScheduleUpdateManyWithWhereWithoutPlaylistInput | PlaylistScheduleUpdateManyWithWhereWithoutPlaylistInput[] | $Types.Skip
    deleteMany?: PlaylistScheduleScalarWhereInput | PlaylistScheduleScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput> | PlaylistItemCreateWithoutPlaylistInput[] | PlaylistItemUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistInput | PlaylistItemCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyPlaylistInputEnvelope | $Types.Skip
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    update?: PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutPlaylistInput | PlaylistItemUpdateManyWithWhereWithoutPlaylistInput[] | $Types.Skip
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutNestedPlaylistInput, PlaylistItemUncheckedCreateWithoutNestedPlaylistInput> | PlaylistItemCreateWithoutNestedPlaylistInput[] | PlaylistItemUncheckedCreateWithoutNestedPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutNestedPlaylistInput | PlaylistItemCreateOrConnectWithoutNestedPlaylistInput[] | $Types.Skip
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutNestedPlaylistInput | PlaylistItemUpsertWithWhereUniqueWithoutNestedPlaylistInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyNestedPlaylistInputEnvelope | $Types.Skip
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    update?: PlaylistItemUpdateWithWhereUniqueWithoutNestedPlaylistInput | PlaylistItemUpdateWithWhereUniqueWithoutNestedPlaylistInput[] | $Types.Skip
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutNestedPlaylistInput | PlaylistItemUpdateManyWithWhereWithoutNestedPlaylistInput[] | $Types.Skip
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistScreenUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistScreenCreateWithoutPlaylistInput, PlaylistScreenUncheckedCreateWithoutPlaylistInput> | PlaylistScreenCreateWithoutPlaylistInput[] | PlaylistScreenUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistScreenCreateOrConnectWithoutPlaylistInput | PlaylistScreenCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    upsert?: PlaylistScreenUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistScreenUpsertWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistScreenCreateManyPlaylistInputEnvelope | $Types.Skip
    set?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    update?: PlaylistScreenUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistScreenUpdateWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    updateMany?: PlaylistScreenUpdateManyWithWhereWithoutPlaylistInput | PlaylistScreenUpdateManyWithWhereWithoutPlaylistInput[] | $Types.Skip
    deleteMany?: PlaylistScreenScalarWhereInput | PlaylistScreenScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistScheduleUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistScheduleCreateWithoutPlaylistInput, PlaylistScheduleUncheckedCreateWithoutPlaylistInput> | PlaylistScheduleCreateWithoutPlaylistInput[] | PlaylistScheduleUncheckedCreateWithoutPlaylistInput[] | $Types.Skip
    connectOrCreate?: PlaylistScheduleCreateOrConnectWithoutPlaylistInput | PlaylistScheduleCreateOrConnectWithoutPlaylistInput[] | $Types.Skip
    upsert?: PlaylistScheduleUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistScheduleUpsertWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    createMany?: PlaylistScheduleCreateManyPlaylistInputEnvelope | $Types.Skip
    set?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistScheduleWhereUniqueInput | PlaylistScheduleWhereUniqueInput[] | $Types.Skip
    update?: PlaylistScheduleUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistScheduleUpdateWithWhereUniqueWithoutPlaylistInput[] | $Types.Skip
    updateMany?: PlaylistScheduleUpdateManyWithWhereWithoutPlaylistInput | PlaylistScheduleUpdateManyWithWhereWithoutPlaylistInput[] | $Types.Skip
    deleteMany?: PlaylistScheduleScalarWhereInput | PlaylistScheduleScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistCreateNestedOneWithoutItemsInput = {
    create?: XOR<PlaylistCreateWithoutItemsInput, PlaylistUncheckedCreateWithoutItemsInput> | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutItemsInput | $Types.Skip
    connect?: PlaylistWhereUniqueInput | $Types.Skip
  }

  export type FileCreateNestedOneWithoutPlaylistItemsInput = {
    create?: XOR<FileCreateWithoutPlaylistItemsInput, FileUncheckedCreateWithoutPlaylistItemsInput> | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutPlaylistItemsInput | $Types.Skip
    connect?: FileWhereUniqueInput | $Types.Skip
  }

  export type PlaylistCreateNestedOneWithoutParentItemsInput = {
    create?: XOR<PlaylistCreateWithoutParentItemsInput, PlaylistUncheckedCreateWithoutParentItemsInput> | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutParentItemsInput | $Types.Skip
    connect?: PlaylistWhereUniqueInput | $Types.Skip
  }

  export type PlaylistLayoutSectionCreateNestedOneWithoutPlaylistItemsInput = {
    create?: XOR<PlaylistLayoutSectionCreateWithoutPlaylistItemsInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistItemsInput> | $Types.Skip
    connectOrCreate?: PlaylistLayoutSectionCreateOrConnectWithoutPlaylistItemsInput | $Types.Skip
    connect?: PlaylistLayoutSectionWhereUniqueInput | $Types.Skip
  }

  export type EnumPlaylistItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlaylistItemType | $Types.Skip
  }

  export type PlaylistUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PlaylistCreateWithoutItemsInput, PlaylistUncheckedCreateWithoutItemsInput> | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutItemsInput | $Types.Skip
    upsert?: PlaylistUpsertWithoutItemsInput | $Types.Skip
    connect?: PlaylistWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutItemsInput, PlaylistUpdateWithoutItemsInput>, PlaylistUncheckedUpdateWithoutItemsInput> | $Types.Skip
  }

  export type FileUpdateOneWithoutPlaylistItemsNestedInput = {
    create?: XOR<FileCreateWithoutPlaylistItemsInput, FileUncheckedCreateWithoutPlaylistItemsInput> | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutPlaylistItemsInput | $Types.Skip
    upsert?: FileUpsertWithoutPlaylistItemsInput | $Types.Skip
    disconnect?: FileWhereInput | boolean | $Types.Skip
    delete?: FileWhereInput | boolean | $Types.Skip
    connect?: FileWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutPlaylistItemsInput, FileUpdateWithoutPlaylistItemsInput>, FileUncheckedUpdateWithoutPlaylistItemsInput> | $Types.Skip
  }

  export type PlaylistUpdateOneWithoutParentItemsNestedInput = {
    create?: XOR<PlaylistCreateWithoutParentItemsInput, PlaylistUncheckedCreateWithoutParentItemsInput> | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutParentItemsInput | $Types.Skip
    upsert?: PlaylistUpsertWithoutParentItemsInput | $Types.Skip
    disconnect?: PlaylistWhereInput | boolean | $Types.Skip
    delete?: PlaylistWhereInput | boolean | $Types.Skip
    connect?: PlaylistWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutParentItemsInput, PlaylistUpdateWithoutParentItemsInput>, PlaylistUncheckedUpdateWithoutParentItemsInput> | $Types.Skip
  }

  export type PlaylistLayoutSectionUpdateOneRequiredWithoutPlaylistItemsNestedInput = {
    create?: XOR<PlaylistLayoutSectionCreateWithoutPlaylistItemsInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistItemsInput> | $Types.Skip
    connectOrCreate?: PlaylistLayoutSectionCreateOrConnectWithoutPlaylistItemsInput | $Types.Skip
    upsert?: PlaylistLayoutSectionUpsertWithoutPlaylistItemsInput | $Types.Skip
    connect?: PlaylistLayoutSectionWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<PlaylistLayoutSectionUpdateToOneWithWhereWithoutPlaylistItemsInput, PlaylistLayoutSectionUpdateWithoutPlaylistItemsInput>, PlaylistLayoutSectionUncheckedUpdateWithoutPlaylistItemsInput> | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutLayoutsInput = {
    create?: XOR<WorkspaceCreateWithoutLayoutsInput, WorkspaceUncheckedCreateWithoutLayoutsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLayoutsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type PlaylistCreateNestedManyWithoutLayoutInput = {
    create?: XOR<PlaylistCreateWithoutLayoutInput, PlaylistUncheckedCreateWithoutLayoutInput> | PlaylistCreateWithoutLayoutInput[] | PlaylistUncheckedCreateWithoutLayoutInput[] | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutLayoutInput | PlaylistCreateOrConnectWithoutLayoutInput[] | $Types.Skip
    createMany?: PlaylistCreateManyLayoutInputEnvelope | $Types.Skip
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistLayoutSectionCreateNestedManyWithoutPlaylistLayoutInput = {
    create?: XOR<PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput> | PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput[] | PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput[] | $Types.Skip
    connectOrCreate?: PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput | PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput[] | $Types.Skip
    createMany?: PlaylistLayoutSectionCreateManyPlaylistLayoutInputEnvelope | $Types.Skip
    connect?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistUncheckedCreateNestedManyWithoutLayoutInput = {
    create?: XOR<PlaylistCreateWithoutLayoutInput, PlaylistUncheckedCreateWithoutLayoutInput> | PlaylistCreateWithoutLayoutInput[] | PlaylistUncheckedCreateWithoutLayoutInput[] | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutLayoutInput | PlaylistCreateOrConnectWithoutLayoutInput[] | $Types.Skip
    createMany?: PlaylistCreateManyLayoutInputEnvelope | $Types.Skip
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedCreateNestedManyWithoutPlaylistLayoutInput = {
    create?: XOR<PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput> | PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput[] | PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput[] | $Types.Skip
    connectOrCreate?: PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput | PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput[] | $Types.Skip
    createMany?: PlaylistLayoutSectionCreateManyPlaylistLayoutInputEnvelope | $Types.Skip
    connect?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutLayoutsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutLayoutsInput, WorkspaceUncheckedCreateWithoutLayoutsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLayoutsInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutLayoutsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutLayoutsInput, WorkspaceUpdateWithoutLayoutsInput>, WorkspaceUncheckedUpdateWithoutLayoutsInput> | $Types.Skip
  }

  export type PlaylistUpdateManyWithoutLayoutNestedInput = {
    create?: XOR<PlaylistCreateWithoutLayoutInput, PlaylistUncheckedCreateWithoutLayoutInput> | PlaylistCreateWithoutLayoutInput[] | PlaylistUncheckedCreateWithoutLayoutInput[] | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutLayoutInput | PlaylistCreateOrConnectWithoutLayoutInput[] | $Types.Skip
    upsert?: PlaylistUpsertWithWhereUniqueWithoutLayoutInput | PlaylistUpsertWithWhereUniqueWithoutLayoutInput[] | $Types.Skip
    createMany?: PlaylistCreateManyLayoutInputEnvelope | $Types.Skip
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    update?: PlaylistUpdateWithWhereUniqueWithoutLayoutInput | PlaylistUpdateWithWhereUniqueWithoutLayoutInput[] | $Types.Skip
    updateMany?: PlaylistUpdateManyWithWhereWithoutLayoutInput | PlaylistUpdateManyWithWhereWithoutLayoutInput[] | $Types.Skip
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistLayoutSectionUpdateManyWithoutPlaylistLayoutNestedInput = {
    create?: XOR<PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput> | PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput[] | PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput[] | $Types.Skip
    connectOrCreate?: PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput | PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput[] | $Types.Skip
    upsert?: PlaylistLayoutSectionUpsertWithWhereUniqueWithoutPlaylistLayoutInput | PlaylistLayoutSectionUpsertWithWhereUniqueWithoutPlaylistLayoutInput[] | $Types.Skip
    createMany?: PlaylistLayoutSectionCreateManyPlaylistLayoutInputEnvelope | $Types.Skip
    set?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
    update?: PlaylistLayoutSectionUpdateWithWhereUniqueWithoutPlaylistLayoutInput | PlaylistLayoutSectionUpdateWithWhereUniqueWithoutPlaylistLayoutInput[] | $Types.Skip
    updateMany?: PlaylistLayoutSectionUpdateManyWithWhereWithoutPlaylistLayoutInput | PlaylistLayoutSectionUpdateManyWithWhereWithoutPlaylistLayoutInput[] | $Types.Skip
    deleteMany?: PlaylistLayoutSectionScalarWhereInput | PlaylistLayoutSectionScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistUncheckedUpdateManyWithoutLayoutNestedInput = {
    create?: XOR<PlaylistCreateWithoutLayoutInput, PlaylistUncheckedCreateWithoutLayoutInput> | PlaylistCreateWithoutLayoutInput[] | PlaylistUncheckedCreateWithoutLayoutInput[] | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutLayoutInput | PlaylistCreateOrConnectWithoutLayoutInput[] | $Types.Skip
    upsert?: PlaylistUpsertWithWhereUniqueWithoutLayoutInput | PlaylistUpsertWithWhereUniqueWithoutLayoutInput[] | $Types.Skip
    createMany?: PlaylistCreateManyLayoutInputEnvelope | $Types.Skip
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    update?: PlaylistUpdateWithWhereUniqueWithoutLayoutInput | PlaylistUpdateWithWhereUniqueWithoutLayoutInput[] | $Types.Skip
    updateMany?: PlaylistUpdateManyWithWhereWithoutLayoutInput | PlaylistUpdateManyWithWhereWithoutLayoutInput[] | $Types.Skip
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedUpdateManyWithoutPlaylistLayoutNestedInput = {
    create?: XOR<PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput> | PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput[] | PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput[] | $Types.Skip
    connectOrCreate?: PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput | PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput[] | $Types.Skip
    upsert?: PlaylistLayoutSectionUpsertWithWhereUniqueWithoutPlaylistLayoutInput | PlaylistLayoutSectionUpsertWithWhereUniqueWithoutPlaylistLayoutInput[] | $Types.Skip
    createMany?: PlaylistLayoutSectionCreateManyPlaylistLayoutInputEnvelope | $Types.Skip
    set?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistLayoutSectionWhereUniqueInput | PlaylistLayoutSectionWhereUniqueInput[] | $Types.Skip
    update?: PlaylistLayoutSectionUpdateWithWhereUniqueWithoutPlaylistLayoutInput | PlaylistLayoutSectionUpdateWithWhereUniqueWithoutPlaylistLayoutInput[] | $Types.Skip
    updateMany?: PlaylistLayoutSectionUpdateManyWithWhereWithoutPlaylistLayoutInput | PlaylistLayoutSectionUpdateManyWithWhereWithoutPlaylistLayoutInput[] | $Types.Skip
    deleteMany?: PlaylistLayoutSectionScalarWhereInput | PlaylistLayoutSectionScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistLayoutCreateNestedOneWithoutSectionsInput = {
    create?: XOR<PlaylistLayoutCreateWithoutSectionsInput, PlaylistLayoutUncheckedCreateWithoutSectionsInput> | $Types.Skip
    connectOrCreate?: PlaylistLayoutCreateOrConnectWithoutSectionsInput | $Types.Skip
    connect?: PlaylistLayoutWhereUniqueInput | $Types.Skip
  }

  export type PlaylistItemCreateNestedManyWithoutPlaylistLayoutSectionInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistLayoutSectionInput, PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput> | PlaylistItemCreateWithoutPlaylistLayoutSectionInput[] | PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput | PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyPlaylistLayoutSectionInputEnvelope | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistItemUncheckedCreateNestedManyWithoutPlaylistLayoutSectionInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistLayoutSectionInput, PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput> | PlaylistItemCreateWithoutPlaylistLayoutSectionInput[] | PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput | PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyPlaylistLayoutSectionInputEnvelope | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistLayoutUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<PlaylistLayoutCreateWithoutSectionsInput, PlaylistLayoutUncheckedCreateWithoutSectionsInput> | $Types.Skip
    connectOrCreate?: PlaylistLayoutCreateOrConnectWithoutSectionsInput | $Types.Skip
    upsert?: PlaylistLayoutUpsertWithoutSectionsInput | $Types.Skip
    connect?: PlaylistLayoutWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<PlaylistLayoutUpdateToOneWithWhereWithoutSectionsInput, PlaylistLayoutUpdateWithoutSectionsInput>, PlaylistLayoutUncheckedUpdateWithoutSectionsInput> | $Types.Skip
  }

  export type PlaylistItemUpdateManyWithoutPlaylistLayoutSectionNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistLayoutSectionInput, PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput> | PlaylistItemCreateWithoutPlaylistLayoutSectionInput[] | PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput | PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutPlaylistLayoutSectionInput | PlaylistItemUpsertWithWhereUniqueWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyPlaylistLayoutSectionInputEnvelope | $Types.Skip
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    update?: PlaylistItemUpdateWithWhereUniqueWithoutPlaylistLayoutSectionInput | PlaylistItemUpdateWithWhereUniqueWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutPlaylistLayoutSectionInput | PlaylistItemUpdateManyWithWhereWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyWithoutPlaylistLayoutSectionNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistLayoutSectionInput, PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput> | PlaylistItemCreateWithoutPlaylistLayoutSectionInput[] | PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput | PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutPlaylistLayoutSectionInput | PlaylistItemUpsertWithWhereUniqueWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    createMany?: PlaylistItemCreateManyPlaylistLayoutSectionInputEnvelope | $Types.Skip
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[] | $Types.Skip
    update?: PlaylistItemUpdateWithWhereUniqueWithoutPlaylistLayoutSectionInput | PlaylistItemUpdateWithWhereUniqueWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutPlaylistLayoutSectionInput | PlaylistItemUpdateManyWithWhereWithoutPlaylistLayoutSectionInput[] | $Types.Skip
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistScheduleCreateweekdaysInput = {
    set: $Enums.Weekday[]
  }

  export type PlaylistCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<PlaylistCreateWithoutSchedulesInput, PlaylistUncheckedCreateWithoutSchedulesInput> | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutSchedulesInput | $Types.Skip
    connect?: PlaylistWhereUniqueInput | $Types.Skip
  }

  export type PlaylistScheduleUpdateweekdaysInput = {
    set?: $Enums.Weekday[] | $Types.Skip
    push?: $Enums.Weekday | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<PlaylistCreateWithoutSchedulesInput, PlaylistUncheckedCreateWithoutSchedulesInput> | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutSchedulesInput | $Types.Skip
    upsert?: PlaylistUpsertWithoutSchedulesInput | $Types.Skip
    connect?: PlaylistWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutSchedulesInput, PlaylistUpdateWithoutSchedulesInput>, PlaylistUncheckedUpdateWithoutSchedulesInput> | $Types.Skip
  }

  export type PlaylistCreateNestedOneWithoutScreensInput = {
    create?: XOR<PlaylistCreateWithoutScreensInput, PlaylistUncheckedCreateWithoutScreensInput> | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutScreensInput | $Types.Skip
    connect?: PlaylistWhereUniqueInput | $Types.Skip
  }

  export type ScreenCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<ScreenCreateWithoutPlaylistsInput, ScreenUncheckedCreateWithoutPlaylistsInput> | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutPlaylistsInput | $Types.Skip
    connect?: ScreenWhereUniqueInput | $Types.Skip
  }

  export type PlaylistUpdateOneRequiredWithoutScreensNestedInput = {
    create?: XOR<PlaylistCreateWithoutScreensInput, PlaylistUncheckedCreateWithoutScreensInput> | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutScreensInput | $Types.Skip
    upsert?: PlaylistUpsertWithoutScreensInput | $Types.Skip
    connect?: PlaylistWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutScreensInput, PlaylistUpdateWithoutScreensInput>, PlaylistUncheckedUpdateWithoutScreensInput> | $Types.Skip
  }

  export type ScreenUpdateOneRequiredWithoutPlaylistsNestedInput = {
    create?: XOR<ScreenCreateWithoutPlaylistsInput, ScreenUncheckedCreateWithoutPlaylistsInput> | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutPlaylistsInput | $Types.Skip
    upsert?: ScreenUpsertWithoutPlaylistsInput | $Types.Skip
    connect?: ScreenWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<ScreenUpdateToOneWithWhereWithoutPlaylistsInput, ScreenUpdateWithoutPlaylistsInput>, ScreenUncheckedUpdateWithoutPlaylistsInput> | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutScreensInput = {
    create?: XOR<WorkspaceCreateWithoutScreensInput, WorkspaceUncheckedCreateWithoutScreensInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutScreensInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type DeviceCreateNestedOneWithoutScreenInput = {
    create?: XOR<DeviceCreateWithoutScreenInput, DeviceUncheckedCreateWithoutScreenInput> | $Types.Skip
    connectOrCreate?: DeviceCreateOrConnectWithoutScreenInput | $Types.Skip
    connect?: DeviceWhereUniqueInput | $Types.Skip
  }

  export type PlaylistScreenCreateNestedManyWithoutScreenInput = {
    create?: XOR<PlaylistScreenCreateWithoutScreenInput, PlaylistScreenUncheckedCreateWithoutScreenInput> | PlaylistScreenCreateWithoutScreenInput[] | PlaylistScreenUncheckedCreateWithoutScreenInput[] | $Types.Skip
    connectOrCreate?: PlaylistScreenCreateOrConnectWithoutScreenInput | PlaylistScreenCreateOrConnectWithoutScreenInput[] | $Types.Skip
    createMany?: PlaylistScreenCreateManyScreenInputEnvelope | $Types.Skip
    connect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
  }

  export type ScreenGroupCreateNestedOneWithoutScreensInput = {
    create?: XOR<ScreenGroupCreateWithoutScreensInput, ScreenGroupUncheckedCreateWithoutScreensInput> | $Types.Skip
    connectOrCreate?: ScreenGroupCreateOrConnectWithoutScreensInput | $Types.Skip
    connect?: ScreenGroupWhereUniqueInput | $Types.Skip
  }

  export type DeviceUncheckedCreateNestedOneWithoutScreenInput = {
    create?: XOR<DeviceCreateWithoutScreenInput, DeviceUncheckedCreateWithoutScreenInput> | $Types.Skip
    connectOrCreate?: DeviceCreateOrConnectWithoutScreenInput | $Types.Skip
    connect?: DeviceWhereUniqueInput | $Types.Skip
  }

  export type PlaylistScreenUncheckedCreateNestedManyWithoutScreenInput = {
    create?: XOR<PlaylistScreenCreateWithoutScreenInput, PlaylistScreenUncheckedCreateWithoutScreenInput> | PlaylistScreenCreateWithoutScreenInput[] | PlaylistScreenUncheckedCreateWithoutScreenInput[] | $Types.Skip
    connectOrCreate?: PlaylistScreenCreateOrConnectWithoutScreenInput | PlaylistScreenCreateOrConnectWithoutScreenInput[] | $Types.Skip
    createMany?: PlaylistScreenCreateManyScreenInputEnvelope | $Types.Skip
    connect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
  }

  export type EnumLayoutRotationFieldUpdateOperationsInput = {
    set?: $Enums.LayoutRotation | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutScreensNestedInput = {
    create?: XOR<WorkspaceCreateWithoutScreensInput, WorkspaceUncheckedCreateWithoutScreensInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutScreensInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutScreensInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutScreensInput, WorkspaceUpdateWithoutScreensInput>, WorkspaceUncheckedUpdateWithoutScreensInput> | $Types.Skip
  }

  export type DeviceUpdateOneWithoutScreenNestedInput = {
    create?: XOR<DeviceCreateWithoutScreenInput, DeviceUncheckedCreateWithoutScreenInput> | $Types.Skip
    connectOrCreate?: DeviceCreateOrConnectWithoutScreenInput | $Types.Skip
    upsert?: DeviceUpsertWithoutScreenInput | $Types.Skip
    disconnect?: DeviceWhereInput | boolean | $Types.Skip
    delete?: DeviceWhereInput | boolean | $Types.Skip
    connect?: DeviceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutScreenInput, DeviceUpdateWithoutScreenInput>, DeviceUncheckedUpdateWithoutScreenInput> | $Types.Skip
  }

  export type PlaylistScreenUpdateManyWithoutScreenNestedInput = {
    create?: XOR<PlaylistScreenCreateWithoutScreenInput, PlaylistScreenUncheckedCreateWithoutScreenInput> | PlaylistScreenCreateWithoutScreenInput[] | PlaylistScreenUncheckedCreateWithoutScreenInput[] | $Types.Skip
    connectOrCreate?: PlaylistScreenCreateOrConnectWithoutScreenInput | PlaylistScreenCreateOrConnectWithoutScreenInput[] | $Types.Skip
    upsert?: PlaylistScreenUpsertWithWhereUniqueWithoutScreenInput | PlaylistScreenUpsertWithWhereUniqueWithoutScreenInput[] | $Types.Skip
    createMany?: PlaylistScreenCreateManyScreenInputEnvelope | $Types.Skip
    set?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    update?: PlaylistScreenUpdateWithWhereUniqueWithoutScreenInput | PlaylistScreenUpdateWithWhereUniqueWithoutScreenInput[] | $Types.Skip
    updateMany?: PlaylistScreenUpdateManyWithWhereWithoutScreenInput | PlaylistScreenUpdateManyWithWhereWithoutScreenInput[] | $Types.Skip
    deleteMany?: PlaylistScreenScalarWhereInput | PlaylistScreenScalarWhereInput[] | $Types.Skip
  }

  export type ScreenGroupUpdateOneWithoutScreensNestedInput = {
    create?: XOR<ScreenGroupCreateWithoutScreensInput, ScreenGroupUncheckedCreateWithoutScreensInput> | $Types.Skip
    connectOrCreate?: ScreenGroupCreateOrConnectWithoutScreensInput | $Types.Skip
    upsert?: ScreenGroupUpsertWithoutScreensInput | $Types.Skip
    disconnect?: ScreenGroupWhereInput | boolean | $Types.Skip
    delete?: ScreenGroupWhereInput | boolean | $Types.Skip
    connect?: ScreenGroupWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<ScreenGroupUpdateToOneWithWhereWithoutScreensInput, ScreenGroupUpdateWithoutScreensInput>, ScreenGroupUncheckedUpdateWithoutScreensInput> | $Types.Skip
  }

  export type DeviceUncheckedUpdateOneWithoutScreenNestedInput = {
    create?: XOR<DeviceCreateWithoutScreenInput, DeviceUncheckedCreateWithoutScreenInput> | $Types.Skip
    connectOrCreate?: DeviceCreateOrConnectWithoutScreenInput | $Types.Skip
    upsert?: DeviceUpsertWithoutScreenInput | $Types.Skip
    disconnect?: DeviceWhereInput | boolean | $Types.Skip
    delete?: DeviceWhereInput | boolean | $Types.Skip
    connect?: DeviceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutScreenInput, DeviceUpdateWithoutScreenInput>, DeviceUncheckedUpdateWithoutScreenInput> | $Types.Skip
  }

  export type PlaylistScreenUncheckedUpdateManyWithoutScreenNestedInput = {
    create?: XOR<PlaylistScreenCreateWithoutScreenInput, PlaylistScreenUncheckedCreateWithoutScreenInput> | PlaylistScreenCreateWithoutScreenInput[] | PlaylistScreenUncheckedCreateWithoutScreenInput[] | $Types.Skip
    connectOrCreate?: PlaylistScreenCreateOrConnectWithoutScreenInput | PlaylistScreenCreateOrConnectWithoutScreenInput[] | $Types.Skip
    upsert?: PlaylistScreenUpsertWithWhereUniqueWithoutScreenInput | PlaylistScreenUpsertWithWhereUniqueWithoutScreenInput[] | $Types.Skip
    createMany?: PlaylistScreenCreateManyScreenInputEnvelope | $Types.Skip
    set?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistScreenWhereUniqueInput | PlaylistScreenWhereUniqueInput[] | $Types.Skip
    update?: PlaylistScreenUpdateWithWhereUniqueWithoutScreenInput | PlaylistScreenUpdateWithWhereUniqueWithoutScreenInput[] | $Types.Skip
    updateMany?: PlaylistScreenUpdateManyWithWhereWithoutScreenInput | PlaylistScreenUpdateManyWithWhereWithoutScreenInput[] | $Types.Skip
    deleteMany?: PlaylistScreenScalarWhereInput | PlaylistScreenScalarWhereInput[] | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutScreenGroupsInput = {
    create?: XOR<WorkspaceCreateWithoutScreenGroupsInput, WorkspaceUncheckedCreateWithoutScreenGroupsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutScreenGroupsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type ScreenCreateNestedManyWithoutGroupInput = {
    create?: XOR<ScreenCreateWithoutGroupInput, ScreenUncheckedCreateWithoutGroupInput> | ScreenCreateWithoutGroupInput[] | ScreenUncheckedCreateWithoutGroupInput[] | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutGroupInput | ScreenCreateOrConnectWithoutGroupInput[] | $Types.Skip
    createMany?: ScreenCreateManyGroupInputEnvelope | $Types.Skip
    connect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
  }

  export type ScreenUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ScreenCreateWithoutGroupInput, ScreenUncheckedCreateWithoutGroupInput> | ScreenCreateWithoutGroupInput[] | ScreenUncheckedCreateWithoutGroupInput[] | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutGroupInput | ScreenCreateOrConnectWithoutGroupInput[] | $Types.Skip
    createMany?: ScreenCreateManyGroupInputEnvelope | $Types.Skip
    connect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutScreenGroupsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutScreenGroupsInput, WorkspaceUncheckedCreateWithoutScreenGroupsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutScreenGroupsInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutScreenGroupsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutScreenGroupsInput, WorkspaceUpdateWithoutScreenGroupsInput>, WorkspaceUncheckedUpdateWithoutScreenGroupsInput> | $Types.Skip
  }

  export type ScreenUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ScreenCreateWithoutGroupInput, ScreenUncheckedCreateWithoutGroupInput> | ScreenCreateWithoutGroupInput[] | ScreenUncheckedCreateWithoutGroupInput[] | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutGroupInput | ScreenCreateOrConnectWithoutGroupInput[] | $Types.Skip
    upsert?: ScreenUpsertWithWhereUniqueWithoutGroupInput | ScreenUpsertWithWhereUniqueWithoutGroupInput[] | $Types.Skip
    createMany?: ScreenCreateManyGroupInputEnvelope | $Types.Skip
    set?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    disconnect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    delete?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    connect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    update?: ScreenUpdateWithWhereUniqueWithoutGroupInput | ScreenUpdateWithWhereUniqueWithoutGroupInput[] | $Types.Skip
    updateMany?: ScreenUpdateManyWithWhereWithoutGroupInput | ScreenUpdateManyWithWhereWithoutGroupInput[] | $Types.Skip
    deleteMany?: ScreenScalarWhereInput | ScreenScalarWhereInput[] | $Types.Skip
  }

  export type ScreenUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ScreenCreateWithoutGroupInput, ScreenUncheckedCreateWithoutGroupInput> | ScreenCreateWithoutGroupInput[] | ScreenUncheckedCreateWithoutGroupInput[] | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutGroupInput | ScreenCreateOrConnectWithoutGroupInput[] | $Types.Skip
    upsert?: ScreenUpsertWithWhereUniqueWithoutGroupInput | ScreenUpsertWithWhereUniqueWithoutGroupInput[] | $Types.Skip
    createMany?: ScreenCreateManyGroupInputEnvelope | $Types.Skip
    set?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    disconnect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    delete?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    connect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    update?: ScreenUpdateWithWhereUniqueWithoutGroupInput | ScreenUpdateWithWhereUniqueWithoutGroupInput[] | $Types.Skip
    updateMany?: ScreenUpdateManyWithWhereWithoutGroupInput | ScreenUpdateManyWithWhereWithoutGroupInput[] | $Types.Skip
    deleteMany?: ScreenScalarWhereInput | ScreenScalarWhereInput[] | $Types.Skip
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput | $Types.Skip
    upsert?: UserUpsertWithoutSessionsInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput> | $Types.Skip
  }

  export type EmailVerificationTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope | $Types.Skip
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: SessionCreateManyUserInputEnvelope | $Types.Skip
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
  }

  export type UserWorkspaceCreateNestedManyWithoutUserInput = {
    create?: XOR<UserWorkspaceCreateWithoutUserInput, UserWorkspaceUncheckedCreateWithoutUserInput> | UserWorkspaceCreateWithoutUserInput[] | UserWorkspaceUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutUserInput | UserWorkspaceCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyUserInputEnvelope | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
  }

  export type UserPreferencesCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput> | UserPreferencesCreateWithoutUserInput[] | UserPreferencesUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput | UserPreferencesCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: UserPreferencesCreateManyUserInputEnvelope | $Types.Skip
    connect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
  }

  export type FileCreateNestedManyWithoutUploaderInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[] | $Types.Skip
    createMany?: FileCreateManyUploaderInputEnvelope | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
  }

  export type FileUploadSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<FileUploadSessionCreateWithoutUserInput, FileUploadSessionUncheckedCreateWithoutUserInput> | FileUploadSessionCreateWithoutUserInput[] | FileUploadSessionUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutUserInput | FileUploadSessionCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyUserInputEnvelope | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateNestedManyWithoutInvitorInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutInvitorInput, WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput> | WorkspaceUserInvitationCreateWithoutInvitorInput[] | WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput[] | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput | WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput[] | $Types.Skip
    createMany?: WorkspaceUserInvitationCreateManyInvitorInputEnvelope | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
  }

  export type EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope | $Types.Skip
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: SessionCreateManyUserInputEnvelope | $Types.Skip
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
  }

  export type UserWorkspaceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserWorkspaceCreateWithoutUserInput, UserWorkspaceUncheckedCreateWithoutUserInput> | UserWorkspaceCreateWithoutUserInput[] | UserWorkspaceUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutUserInput | UserWorkspaceCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyUserInputEnvelope | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
  }

  export type UserPreferencesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput> | UserPreferencesCreateWithoutUserInput[] | UserPreferencesUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput | UserPreferencesCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: UserPreferencesCreateManyUserInputEnvelope | $Types.Skip
    connect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
  }

  export type FileUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[] | $Types.Skip
    createMany?: FileCreateManyUploaderInputEnvelope | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
  }

  export type FileUploadSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FileUploadSessionCreateWithoutUserInput, FileUploadSessionUncheckedCreateWithoutUserInput> | FileUploadSessionCreateWithoutUserInput[] | FileUploadSessionUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutUserInput | FileUploadSessionCreateOrConnectWithoutUserInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyUserInputEnvelope | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedCreateNestedManyWithoutInvitorInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutInvitorInput, WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput> | WorkspaceUserInvitationCreateWithoutInvitorInput[] | WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput[] | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput | WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput[] | $Types.Skip
    createMany?: WorkspaceUserInvitationCreateManyInvitorInputEnvelope | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
  }

  export type EmailVerificationTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope | $Types.Skip
    set?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
    disconnect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
    delete?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
    update?: EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: EmailVerificationTokenUpdateManyWithWhereWithoutUserInput | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[] | $Types.Skip
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: SessionCreateManyUserInputEnvelope | $Types.Skip
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[] | $Types.Skip
  }

  export type UserWorkspaceUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserWorkspaceCreateWithoutUserInput, UserWorkspaceUncheckedCreateWithoutUserInput> | UserWorkspaceCreateWithoutUserInput[] | UserWorkspaceUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutUserInput | UserWorkspaceCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: UserWorkspaceUpsertWithWhereUniqueWithoutUserInput | UserWorkspaceUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyUserInputEnvelope | $Types.Skip
    set?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    disconnect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    delete?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    update?: UserWorkspaceUpdateWithWhereUniqueWithoutUserInput | UserWorkspaceUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: UserWorkspaceUpdateManyWithWhereWithoutUserInput | UserWorkspaceUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: UserWorkspaceScalarWhereInput | UserWorkspaceScalarWhereInput[] | $Types.Skip
  }

  export type UserPreferencesUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput> | UserPreferencesCreateWithoutUserInput[] | UserPreferencesUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput | UserPreferencesCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: UserPreferencesUpsertWithWhereUniqueWithoutUserInput | UserPreferencesUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: UserPreferencesCreateManyUserInputEnvelope | $Types.Skip
    set?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
    disconnect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
    delete?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
    connect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
    update?: UserPreferencesUpdateWithWhereUniqueWithoutUserInput | UserPreferencesUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: UserPreferencesUpdateManyWithWhereWithoutUserInput | UserPreferencesUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: UserPreferencesScalarWhereInput | UserPreferencesScalarWhereInput[] | $Types.Skip
  }

  export type FileUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[] | $Types.Skip
    upsert?: FileUpsertWithWhereUniqueWithoutUploaderInput | FileUpsertWithWhereUniqueWithoutUploaderInput[] | $Types.Skip
    createMany?: FileCreateManyUploaderInputEnvelope | $Types.Skip
    set?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    update?: FileUpdateWithWhereUniqueWithoutUploaderInput | FileUpdateWithWhereUniqueWithoutUploaderInput[] | $Types.Skip
    updateMany?: FileUpdateManyWithWhereWithoutUploaderInput | FileUpdateManyWithWhereWithoutUploaderInput[] | $Types.Skip
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[] | $Types.Skip
  }

  export type FileUploadSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileUploadSessionCreateWithoutUserInput, FileUploadSessionUncheckedCreateWithoutUserInput> | FileUploadSessionCreateWithoutUserInput[] | FileUploadSessionUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutUserInput | FileUploadSessionCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: FileUploadSessionUpsertWithWhereUniqueWithoutUserInput | FileUploadSessionUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyUserInputEnvelope | $Types.Skip
    set?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    disconnect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    delete?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    update?: FileUploadSessionUpdateWithWhereUniqueWithoutUserInput | FileUploadSessionUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: FileUploadSessionUpdateManyWithWhereWithoutUserInput | FileUploadSessionUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: FileUploadSessionScalarWhereInput | FileUploadSessionScalarWhereInput[] | $Types.Skip
  }

  export type WorkspaceUserInvitationUpdateManyWithoutInvitorNestedInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutInvitorInput, WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput> | WorkspaceUserInvitationCreateWithoutInvitorInput[] | WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput[] | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput | WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput[] | $Types.Skip
    upsert?: WorkspaceUserInvitationUpsertWithWhereUniqueWithoutInvitorInput | WorkspaceUserInvitationUpsertWithWhereUniqueWithoutInvitorInput[] | $Types.Skip
    createMany?: WorkspaceUserInvitationCreateManyInvitorInputEnvelope | $Types.Skip
    set?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    disconnect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    delete?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    update?: WorkspaceUserInvitationUpdateWithWhereUniqueWithoutInvitorInput | WorkspaceUserInvitationUpdateWithWhereUniqueWithoutInvitorInput[] | $Types.Skip
    updateMany?: WorkspaceUserInvitationUpdateManyWithWhereWithoutInvitorInput | WorkspaceUserInvitationUpdateManyWithWhereWithoutInvitorInput[] | $Types.Skip
    deleteMany?: WorkspaceUserInvitationScalarWhereInput | WorkspaceUserInvitationScalarWhereInput[] | $Types.Skip
  }

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope | $Types.Skip
    set?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
    disconnect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
    delete?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[] | $Types.Skip
    update?: EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: EmailVerificationTokenUpdateManyWithWhereWithoutUserInput | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[] | $Types.Skip
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: SessionCreateManyUserInputEnvelope | $Types.Skip
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[] | $Types.Skip
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[] | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserWorkspaceCreateWithoutUserInput, UserWorkspaceUncheckedCreateWithoutUserInput> | UserWorkspaceCreateWithoutUserInput[] | UserWorkspaceUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutUserInput | UserWorkspaceCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: UserWorkspaceUpsertWithWhereUniqueWithoutUserInput | UserWorkspaceUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyUserInputEnvelope | $Types.Skip
    set?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    disconnect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    delete?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    update?: UserWorkspaceUpdateWithWhereUniqueWithoutUserInput | UserWorkspaceUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: UserWorkspaceUpdateManyWithWhereWithoutUserInput | UserWorkspaceUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: UserWorkspaceScalarWhereInput | UserWorkspaceScalarWhereInput[] | $Types.Skip
  }

  export type UserPreferencesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput> | UserPreferencesCreateWithoutUserInput[] | UserPreferencesUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput | UserPreferencesCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: UserPreferencesUpsertWithWhereUniqueWithoutUserInput | UserPreferencesUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: UserPreferencesCreateManyUserInputEnvelope | $Types.Skip
    set?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
    disconnect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
    delete?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
    connect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[] | $Types.Skip
    update?: UserPreferencesUpdateWithWhereUniqueWithoutUserInput | UserPreferencesUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: UserPreferencesUpdateManyWithWhereWithoutUserInput | UserPreferencesUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: UserPreferencesScalarWhereInput | UserPreferencesScalarWhereInput[] | $Types.Skip
  }

  export type FileUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[] | $Types.Skip
    upsert?: FileUpsertWithWhereUniqueWithoutUploaderInput | FileUpsertWithWhereUniqueWithoutUploaderInput[] | $Types.Skip
    createMany?: FileCreateManyUploaderInputEnvelope | $Types.Skip
    set?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    update?: FileUpdateWithWhereUniqueWithoutUploaderInput | FileUpdateWithWhereUniqueWithoutUploaderInput[] | $Types.Skip
    updateMany?: FileUpdateManyWithWhereWithoutUploaderInput | FileUpdateManyWithWhereWithoutUploaderInput[] | $Types.Skip
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[] | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileUploadSessionCreateWithoutUserInput, FileUploadSessionUncheckedCreateWithoutUserInput> | FileUploadSessionCreateWithoutUserInput[] | FileUploadSessionUncheckedCreateWithoutUserInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutUserInput | FileUploadSessionCreateOrConnectWithoutUserInput[] | $Types.Skip
    upsert?: FileUploadSessionUpsertWithWhereUniqueWithoutUserInput | FileUploadSessionUpsertWithWhereUniqueWithoutUserInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyUserInputEnvelope | $Types.Skip
    set?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    disconnect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    delete?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    update?: FileUploadSessionUpdateWithWhereUniqueWithoutUserInput | FileUploadSessionUpdateWithWhereUniqueWithoutUserInput[] | $Types.Skip
    updateMany?: FileUploadSessionUpdateManyWithWhereWithoutUserInput | FileUploadSessionUpdateManyWithWhereWithoutUserInput[] | $Types.Skip
    deleteMany?: FileUploadSessionScalarWhereInput | FileUploadSessionScalarWhereInput[] | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorNestedInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutInvitorInput, WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput> | WorkspaceUserInvitationCreateWithoutInvitorInput[] | WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput[] | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput | WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput[] | $Types.Skip
    upsert?: WorkspaceUserInvitationUpsertWithWhereUniqueWithoutInvitorInput | WorkspaceUserInvitationUpsertWithWhereUniqueWithoutInvitorInput[] | $Types.Skip
    createMany?: WorkspaceUserInvitationCreateManyInvitorInputEnvelope | $Types.Skip
    set?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    disconnect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    delete?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    update?: WorkspaceUserInvitationUpdateWithWhereUniqueWithoutInvitorInput | WorkspaceUserInvitationUpdateWithWhereUniqueWithoutInvitorInput[] | $Types.Skip
    updateMany?: WorkspaceUserInvitationUpdateManyWithWhereWithoutInvitorInput | WorkspaceUserInvitationUpdateManyWithWhereWithoutInvitorInput[] | $Types.Skip
    deleteMany?: WorkspaceUserInvitationScalarWhereInput | WorkspaceUserInvitationScalarWhereInput[] | $Types.Skip
  }

  export type UserCreateNestedOneWithoutUserPreferencesInput = {
    create?: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutUserPreferencesInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
  }

  export type UserUpdateOneRequiredWithoutUserPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutUserPreferencesInput | $Types.Skip
    upsert?: UserUpsertWithoutUserPreferencesInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPreferencesInput, UserUpdateWithoutUserPreferencesInput>, UserUncheckedUpdateWithoutUserPreferencesInput> | $Types.Skip
  }

  export type UserWorkspaceCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutMembersInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateNestedOneWithoutMembersInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutMembersInput, WorkspaceUserInvitationUncheckedCreateWithoutMembersInput> | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutMembersInput | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | $Types.Skip
  }

  export type UserWorkspaceUpdatepermissionsInput = {
    set?: string[] | $Types.Skip
    push?: string | string[] | $Types.Skip
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput | $Types.Skip
    upsert?: UserUpsertWithoutWorkspacesInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput> | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutMembersInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutMembersInput, WorkspaceUpdateWithoutMembersInput>, WorkspaceUncheckedUpdateWithoutMembersInput> | $Types.Skip
  }

  export type WorkspaceUserInvitationUpdateOneWithoutMembersNestedInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutMembersInput, WorkspaceUserInvitationUncheckedCreateWithoutMembersInput> | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutMembersInput | $Types.Skip
    upsert?: WorkspaceUserInvitationUpsertWithoutMembersInput | $Types.Skip
    disconnect?: WorkspaceUserInvitationWhereInput | boolean | $Types.Skip
    delete?: WorkspaceUserInvitationWhereInput | boolean | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUserInvitationUpdateToOneWithWhereWithoutMembersInput, WorkspaceUserInvitationUpdateWithoutMembersInput>, WorkspaceUserInvitationUncheckedUpdateWithoutMembersInput> | $Types.Skip
  }

  export type UserWorkspaceCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<UserWorkspaceCreateWithoutWorkspaceInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInput> | UserWorkspaceCreateWithoutWorkspaceInput[] | UserWorkspaceUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutWorkspaceInput | UserWorkspaceCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
  }

  export type ScreenCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ScreenCreateWithoutWorkspaceInput, ScreenUncheckedCreateWithoutWorkspaceInput> | ScreenCreateWithoutWorkspaceInput[] | ScreenUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutWorkspaceInput | ScreenCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: ScreenCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<PlaylistCreateWithoutWorkspaceInput, PlaylistUncheckedCreateWithoutWorkspaceInput> | PlaylistCreateWithoutWorkspaceInput[] | PlaylistUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutWorkspaceInput | PlaylistCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: PlaylistCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistLayoutCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<PlaylistLayoutCreateWithoutWorkspaceInput, PlaylistLayoutUncheckedCreateWithoutWorkspaceInput> | PlaylistLayoutCreateWithoutWorkspaceInput[] | PlaylistLayoutUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: PlaylistLayoutCreateOrConnectWithoutWorkspaceInput | PlaylistLayoutCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: PlaylistLayoutCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
  }

  export type FileCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput> | FileCreateWithoutWorkspaceInput[] | FileUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutWorkspaceInput | FileCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FileCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
  }

  export type FolderCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FolderCreateWithoutWorkspaceInput, FolderUncheckedCreateWithoutWorkspaceInput> | FolderCreateWithoutWorkspaceInput[] | FolderUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutWorkspaceInput | FolderCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FolderCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
  }

  export type FileUploadSessionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FileUploadSessionCreateWithoutWorkspaceInput, FileUploadSessionUncheckedCreateWithoutWorkspaceInput> | FileUploadSessionCreateWithoutWorkspaceInput[] | FileUploadSessionUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutWorkspaceInput | FileUploadSessionCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutWorkspaceInput, WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserInvitationCreateWithoutWorkspaceInput[] | WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: WorkspaceUserInvitationCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
  }

  export type ScreenGroupCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ScreenGroupCreateWithoutWorkspaceInput, ScreenGroupUncheckedCreateWithoutWorkspaceInput> | ScreenGroupCreateWithoutWorkspaceInput[] | ScreenGroupUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: ScreenGroupCreateOrConnectWithoutWorkspaceInput | ScreenGroupCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: ScreenGroupCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
  }

  export type UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<UserWorkspaceCreateWithoutWorkspaceInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInput> | UserWorkspaceCreateWithoutWorkspaceInput[] | UserWorkspaceUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutWorkspaceInput | UserWorkspaceCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
  }

  export type ScreenUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ScreenCreateWithoutWorkspaceInput, ScreenUncheckedCreateWithoutWorkspaceInput> | ScreenCreateWithoutWorkspaceInput[] | ScreenUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutWorkspaceInput | ScreenCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: ScreenCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<PlaylistCreateWithoutWorkspaceInput, PlaylistUncheckedCreateWithoutWorkspaceInput> | PlaylistCreateWithoutWorkspaceInput[] | PlaylistUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutWorkspaceInput | PlaylistCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: PlaylistCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
  }

  export type PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<PlaylistLayoutCreateWithoutWorkspaceInput, PlaylistLayoutUncheckedCreateWithoutWorkspaceInput> | PlaylistLayoutCreateWithoutWorkspaceInput[] | PlaylistLayoutUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: PlaylistLayoutCreateOrConnectWithoutWorkspaceInput | PlaylistLayoutCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: PlaylistLayoutCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
  }

  export type FileUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput> | FileCreateWithoutWorkspaceInput[] | FileUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutWorkspaceInput | FileCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FileCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
  }

  export type FolderUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FolderCreateWithoutWorkspaceInput, FolderUncheckedCreateWithoutWorkspaceInput> | FolderCreateWithoutWorkspaceInput[] | FolderUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutWorkspaceInput | FolderCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FolderCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
  }

  export type FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FileUploadSessionCreateWithoutWorkspaceInput, FileUploadSessionUncheckedCreateWithoutWorkspaceInput> | FileUploadSessionCreateWithoutWorkspaceInput[] | FileUploadSessionUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutWorkspaceInput | FileUploadSessionCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutWorkspaceInput, WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserInvitationCreateWithoutWorkspaceInput[] | WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: WorkspaceUserInvitationCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
  }

  export type ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ScreenGroupCreateWithoutWorkspaceInput, ScreenGroupUncheckedCreateWithoutWorkspaceInput> | ScreenGroupCreateWithoutWorkspaceInput[] | ScreenGroupUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: ScreenGroupCreateOrConnectWithoutWorkspaceInput | ScreenGroupCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    createMany?: ScreenGroupCreateManyWorkspaceInputEnvelope | $Types.Skip
    connect?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
  }

  export type UserWorkspaceUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<UserWorkspaceCreateWithoutWorkspaceInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInput> | UserWorkspaceCreateWithoutWorkspaceInput[] | UserWorkspaceUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutWorkspaceInput | UserWorkspaceCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInput | UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    disconnect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    delete?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    update?: UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInput | UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInput | UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: UserWorkspaceScalarWhereInput | UserWorkspaceScalarWhereInput[] | $Types.Skip
  }

  export type ScreenUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ScreenCreateWithoutWorkspaceInput, ScreenUncheckedCreateWithoutWorkspaceInput> | ScreenCreateWithoutWorkspaceInput[] | ScreenUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutWorkspaceInput | ScreenCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: ScreenUpsertWithWhereUniqueWithoutWorkspaceInput | ScreenUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: ScreenCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    disconnect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    delete?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    connect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    update?: ScreenUpdateWithWhereUniqueWithoutWorkspaceInput | ScreenUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: ScreenUpdateManyWithWhereWithoutWorkspaceInput | ScreenUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: ScreenScalarWhereInput | ScreenScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<PlaylistCreateWithoutWorkspaceInput, PlaylistUncheckedCreateWithoutWorkspaceInput> | PlaylistCreateWithoutWorkspaceInput[] | PlaylistUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutWorkspaceInput | PlaylistCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: PlaylistUpsertWithWhereUniqueWithoutWorkspaceInput | PlaylistUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: PlaylistCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    update?: PlaylistUpdateWithWhereUniqueWithoutWorkspaceInput | PlaylistUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: PlaylistUpdateManyWithWhereWithoutWorkspaceInput | PlaylistUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<PlaylistLayoutCreateWithoutWorkspaceInput, PlaylistLayoutUncheckedCreateWithoutWorkspaceInput> | PlaylistLayoutCreateWithoutWorkspaceInput[] | PlaylistLayoutUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: PlaylistLayoutCreateOrConnectWithoutWorkspaceInput | PlaylistLayoutCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: PlaylistLayoutUpsertWithWhereUniqueWithoutWorkspaceInput | PlaylistLayoutUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: PlaylistLayoutCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
    update?: PlaylistLayoutUpdateWithWhereUniqueWithoutWorkspaceInput | PlaylistLayoutUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: PlaylistLayoutUpdateManyWithWhereWithoutWorkspaceInput | PlaylistLayoutUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: PlaylistLayoutScalarWhereInput | PlaylistLayoutScalarWhereInput[] | $Types.Skip
  }

  export type FileUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput> | FileCreateWithoutWorkspaceInput[] | FileUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutWorkspaceInput | FileCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: FileUpsertWithWhereUniqueWithoutWorkspaceInput | FileUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FileCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    update?: FileUpdateWithWhereUniqueWithoutWorkspaceInput | FileUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: FileUpdateManyWithWhereWithoutWorkspaceInput | FileUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[] | $Types.Skip
  }

  export type FolderUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FolderCreateWithoutWorkspaceInput, FolderUncheckedCreateWithoutWorkspaceInput> | FolderCreateWithoutWorkspaceInput[] | FolderUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutWorkspaceInput | FolderCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: FolderUpsertWithWhereUniqueWithoutWorkspaceInput | FolderUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FolderCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    update?: FolderUpdateWithWhereUniqueWithoutWorkspaceInput | FolderUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: FolderUpdateManyWithWhereWithoutWorkspaceInput | FolderUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[] | $Types.Skip
  }

  export type FileUploadSessionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FileUploadSessionCreateWithoutWorkspaceInput, FileUploadSessionUncheckedCreateWithoutWorkspaceInput> | FileUploadSessionCreateWithoutWorkspaceInput[] | FileUploadSessionUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutWorkspaceInput | FileUploadSessionCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: FileUploadSessionUpsertWithWhereUniqueWithoutWorkspaceInput | FileUploadSessionUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    disconnect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    delete?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    update?: FileUploadSessionUpdateWithWhereUniqueWithoutWorkspaceInput | FileUploadSessionUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: FileUploadSessionUpdateManyWithWhereWithoutWorkspaceInput | FileUploadSessionUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: FileUploadSessionScalarWhereInput | FileUploadSessionScalarWhereInput[] | $Types.Skip
  }

  export type WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutWorkspaceInput, WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserInvitationCreateWithoutWorkspaceInput[] | WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: WorkspaceUserInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: WorkspaceUserInvitationCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    disconnect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    delete?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    update?: WorkspaceUserInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: WorkspaceUserInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserInvitationUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: WorkspaceUserInvitationScalarWhereInput | WorkspaceUserInvitationScalarWhereInput[] | $Types.Skip
  }

  export type ScreenGroupUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ScreenGroupCreateWithoutWorkspaceInput, ScreenGroupUncheckedCreateWithoutWorkspaceInput> | ScreenGroupCreateWithoutWorkspaceInput[] | ScreenGroupUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: ScreenGroupCreateOrConnectWithoutWorkspaceInput | ScreenGroupCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: ScreenGroupUpsertWithWhereUniqueWithoutWorkspaceInput | ScreenGroupUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: ScreenGroupCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
    disconnect?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
    delete?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
    connect?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
    update?: ScreenGroupUpdateWithWhereUniqueWithoutWorkspaceInput | ScreenGroupUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: ScreenGroupUpdateManyWithWhereWithoutWorkspaceInput | ScreenGroupUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: ScreenGroupScalarWhereInput | ScreenGroupScalarWhereInput[] | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<UserWorkspaceCreateWithoutWorkspaceInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInput> | UserWorkspaceCreateWithoutWorkspaceInput[] | UserWorkspaceUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutWorkspaceInput | UserWorkspaceCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInput | UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    disconnect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    delete?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    update?: UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInput | UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInput | UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: UserWorkspaceScalarWhereInput | UserWorkspaceScalarWhereInput[] | $Types.Skip
  }

  export type ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ScreenCreateWithoutWorkspaceInput, ScreenUncheckedCreateWithoutWorkspaceInput> | ScreenCreateWithoutWorkspaceInput[] | ScreenUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: ScreenCreateOrConnectWithoutWorkspaceInput | ScreenCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: ScreenUpsertWithWhereUniqueWithoutWorkspaceInput | ScreenUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: ScreenCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    disconnect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    delete?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    connect?: ScreenWhereUniqueInput | ScreenWhereUniqueInput[] | $Types.Skip
    update?: ScreenUpdateWithWhereUniqueWithoutWorkspaceInput | ScreenUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: ScreenUpdateManyWithWhereWithoutWorkspaceInput | ScreenUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: ScreenScalarWhereInput | ScreenScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<PlaylistCreateWithoutWorkspaceInput, PlaylistUncheckedCreateWithoutWorkspaceInput> | PlaylistCreateWithoutWorkspaceInput[] | PlaylistUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: PlaylistCreateOrConnectWithoutWorkspaceInput | PlaylistCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: PlaylistUpsertWithWhereUniqueWithoutWorkspaceInput | PlaylistUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: PlaylistCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[] | $Types.Skip
    update?: PlaylistUpdateWithWhereUniqueWithoutWorkspaceInput | PlaylistUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: PlaylistUpdateManyWithWhereWithoutWorkspaceInput | PlaylistUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[] | $Types.Skip
  }

  export type PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<PlaylistLayoutCreateWithoutWorkspaceInput, PlaylistLayoutUncheckedCreateWithoutWorkspaceInput> | PlaylistLayoutCreateWithoutWorkspaceInput[] | PlaylistLayoutUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: PlaylistLayoutCreateOrConnectWithoutWorkspaceInput | PlaylistLayoutCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: PlaylistLayoutUpsertWithWhereUniqueWithoutWorkspaceInput | PlaylistLayoutUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: PlaylistLayoutCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
    disconnect?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
    delete?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
    connect?: PlaylistLayoutWhereUniqueInput | PlaylistLayoutWhereUniqueInput[] | $Types.Skip
    update?: PlaylistLayoutUpdateWithWhereUniqueWithoutWorkspaceInput | PlaylistLayoutUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: PlaylistLayoutUpdateManyWithWhereWithoutWorkspaceInput | PlaylistLayoutUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: PlaylistLayoutScalarWhereInput | PlaylistLayoutScalarWhereInput[] | $Types.Skip
  }

  export type FileUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput> | FileCreateWithoutWorkspaceInput[] | FileUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FileCreateOrConnectWithoutWorkspaceInput | FileCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: FileUpsertWithWhereUniqueWithoutWorkspaceInput | FileUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FileCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[] | $Types.Skip
    update?: FileUpdateWithWhereUniqueWithoutWorkspaceInput | FileUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: FileUpdateManyWithWhereWithoutWorkspaceInput | FileUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[] | $Types.Skip
  }

  export type FolderUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FolderCreateWithoutWorkspaceInput, FolderUncheckedCreateWithoutWorkspaceInput> | FolderCreateWithoutWorkspaceInput[] | FolderUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FolderCreateOrConnectWithoutWorkspaceInput | FolderCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: FolderUpsertWithWhereUniqueWithoutWorkspaceInput | FolderUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FolderCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[] | $Types.Skip
    update?: FolderUpdateWithWhereUniqueWithoutWorkspaceInput | FolderUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: FolderUpdateManyWithWhereWithoutWorkspaceInput | FolderUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[] | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FileUploadSessionCreateWithoutWorkspaceInput, FileUploadSessionUncheckedCreateWithoutWorkspaceInput> | FileUploadSessionCreateWithoutWorkspaceInput[] | FileUploadSessionUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: FileUploadSessionCreateOrConnectWithoutWorkspaceInput | FileUploadSessionCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: FileUploadSessionUpsertWithWhereUniqueWithoutWorkspaceInput | FileUploadSessionUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: FileUploadSessionCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    disconnect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    delete?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    connect?: FileUploadSessionWhereUniqueInput | FileUploadSessionWhereUniqueInput[] | $Types.Skip
    update?: FileUploadSessionUpdateWithWhereUniqueWithoutWorkspaceInput | FileUploadSessionUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: FileUploadSessionUpdateManyWithWhereWithoutWorkspaceInput | FileUploadSessionUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: FileUploadSessionScalarWhereInput | FileUploadSessionScalarWhereInput[] | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserInvitationCreateWithoutWorkspaceInput, WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserInvitationCreateWithoutWorkspaceInput[] | WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: WorkspaceUserInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: WorkspaceUserInvitationCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    disconnect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    delete?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    connect?: WorkspaceUserInvitationWhereUniqueInput | WorkspaceUserInvitationWhereUniqueInput[] | $Types.Skip
    update?: WorkspaceUserInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: WorkspaceUserInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserInvitationUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: WorkspaceUserInvitationScalarWhereInput | WorkspaceUserInvitationScalarWhereInput[] | $Types.Skip
  }

  export type ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ScreenGroupCreateWithoutWorkspaceInput, ScreenGroupUncheckedCreateWithoutWorkspaceInput> | ScreenGroupCreateWithoutWorkspaceInput[] | ScreenGroupUncheckedCreateWithoutWorkspaceInput[] | $Types.Skip
    connectOrCreate?: ScreenGroupCreateOrConnectWithoutWorkspaceInput | ScreenGroupCreateOrConnectWithoutWorkspaceInput[] | $Types.Skip
    upsert?: ScreenGroupUpsertWithWhereUniqueWithoutWorkspaceInput | ScreenGroupUpsertWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    createMany?: ScreenGroupCreateManyWorkspaceInputEnvelope | $Types.Skip
    set?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
    disconnect?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
    delete?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
    connect?: ScreenGroupWhereUniqueInput | ScreenGroupWhereUniqueInput[] | $Types.Skip
    update?: ScreenGroupUpdateWithWhereUniqueWithoutWorkspaceInput | ScreenGroupUpdateWithWhereUniqueWithoutWorkspaceInput[] | $Types.Skip
    updateMany?: ScreenGroupUpdateManyWithWhereWithoutWorkspaceInput | ScreenGroupUpdateManyWithWhereWithoutWorkspaceInput[] | $Types.Skip
    deleteMany?: ScreenGroupScalarWhereInput | ScreenGroupScalarWhereInput[] | $Types.Skip
  }

  export type WorkspaceCreateNestedOneWithoutUserInvitationsInput = {
    create?: XOR<WorkspaceCreateWithoutUserInvitationsInput, WorkspaceUncheckedCreateWithoutUserInvitationsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUserInvitationsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
  }

  export type UserCreateNestedOneWithoutSentInvitationsInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
  }

  export type UserWorkspaceCreateNestedManyWithoutWorkspaceInvitationInput = {
    create?: XOR<UserWorkspaceCreateWithoutWorkspaceInvitationInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput> | UserWorkspaceCreateWithoutWorkspaceInvitationInput[] | UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput | UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyWorkspaceInvitationInputEnvelope | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
  }

  export type UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInvitationInput = {
    create?: XOR<UserWorkspaceCreateWithoutWorkspaceInvitationInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput> | UserWorkspaceCreateWithoutWorkspaceInvitationInput[] | UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput | UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyWorkspaceInvitationInputEnvelope | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
  }

  export type WorkspaceUpdateOneRequiredWithoutUserInvitationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutUserInvitationsInput, WorkspaceUncheckedCreateWithoutUserInvitationsInput> | $Types.Skip
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUserInvitationsInput | $Types.Skip
    upsert?: WorkspaceUpsertWithoutUserInvitationsInput | $Types.Skip
    connect?: WorkspaceWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutUserInvitationsInput, WorkspaceUpdateWithoutUserInvitationsInput>, WorkspaceUncheckedUpdateWithoutUserInvitationsInput> | $Types.Skip
  }

  export type UserUpdateOneWithoutSentInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput> | $Types.Skip
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput | $Types.Skip
    upsert?: UserUpsertWithoutSentInvitationsInput | $Types.Skip
    disconnect?: UserWhereInput | boolean | $Types.Skip
    delete?: UserWhereInput | boolean | $Types.Skip
    connect?: UserWhereUniqueInput | $Types.Skip
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitationsInput, UserUpdateWithoutSentInvitationsInput>, UserUncheckedUpdateWithoutSentInvitationsInput> | $Types.Skip
  }

  export type UserWorkspaceUpdateManyWithoutWorkspaceInvitationNestedInput = {
    create?: XOR<UserWorkspaceCreateWithoutWorkspaceInvitationInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput> | UserWorkspaceCreateWithoutWorkspaceInvitationInput[] | UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput | UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput[] | $Types.Skip
    upsert?: UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInvitationInput | UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInvitationInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyWorkspaceInvitationInputEnvelope | $Types.Skip
    set?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    disconnect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    delete?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    update?: UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInvitationInput | UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInvitationInput[] | $Types.Skip
    updateMany?: UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInvitationInput | UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInvitationInput[] | $Types.Skip
    deleteMany?: UserWorkspaceScalarWhereInput | UserWorkspaceScalarWhereInput[] | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateManyWithoutWorkspaceInvitationNestedInput = {
    create?: XOR<UserWorkspaceCreateWithoutWorkspaceInvitationInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput> | UserWorkspaceCreateWithoutWorkspaceInvitationInput[] | UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput[] | $Types.Skip
    connectOrCreate?: UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput | UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput[] | $Types.Skip
    upsert?: UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInvitationInput | UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInvitationInput[] | $Types.Skip
    createMany?: UserWorkspaceCreateManyWorkspaceInvitationInputEnvelope | $Types.Skip
    set?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    disconnect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    delete?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    connect?: UserWorkspaceWhereUniqueInput | UserWorkspaceWhereUniqueInput[] | $Types.Skip
    update?: UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInvitationInput | UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInvitationInput[] | $Types.Skip
    updateMany?: UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInvitationInput | UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInvitationInput[] | $Types.Skip
    deleteMany?: UserWorkspaceScalarWhereInput | UserWorkspaceScalarWhereInput[] | $Types.Skip
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    contains?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    startsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    endsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedStringFilter<$PrismaModel> | string | $Types.Skip
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    contains?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    startsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    endsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedStringNullableFilter<$PrismaModel> | string | null | $Types.Skip
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string | $Types.Skip
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBoolFilter<$PrismaModel> | boolean | $Types.Skip
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    contains?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    startsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    endsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedStringFilter<$PrismaModel> | $Types.Skip
    _max?: NestedStringFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedIntFilter<$PrismaModel> | number | $Types.Skip
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    contains?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    startsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    endsWith?: string | StringFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null | $Types.Skip
    _count?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _min?: NestedStringNullableFilter<$PrismaModel> | $Types.Skip
    _max?: NestedStringNullableFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedIntNullableFilter<$PrismaModel> | number | null | $Types.Skip
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedDateTimeFilter<$PrismaModel> | $Types.Skip
    _max?: NestedDateTimeFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedBoolFilter<$PrismaModel> | $Types.Skip
    _max?: NestedBoolFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null | $Types.Skip
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null | $Types.Skip
    _count?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _avg?: NestedFloatNullableFilter<$PrismaModel> | $Types.Skip
    _sum?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _min?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _max?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null | $Types.Skip
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null | $Types.Skip
    _count?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _avg?: NestedFloatNullableFilter<$PrismaModel> | $Types.Skip
    _sum?: NestedBigIntNullableFilter<$PrismaModel> | $Types.Skip
    _min?: NestedBigIntNullableFilter<$PrismaModel> | $Types.Skip
    _max?: NestedBigIntNullableFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number | $Types.Skip
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null | $Types.Skip
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _avg?: NestedFloatFilter<$PrismaModel> | $Types.Skip
    _sum?: NestedBigIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedBigIntFilter<$PrismaModel> | $Types.Skip
    _max?: NestedBigIntFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | FloatFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedFloatFilter<$PrismaModel> | number | $Types.Skip
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null | $Types.Skip
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null | $Types.Skip
    _count?: NestedIntNullableFilter<$PrismaModel> | $Types.Skip
    _min?: NestedDateTimeNullableFilter<$PrismaModel> | $Types.Skip
    _max?: NestedDateTimeNullableFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | $Types.Skip
    lt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    lte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gt?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    gte?: number | IntFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _avg?: NestedFloatFilter<$PrismaModel> | $Types.Skip
    _sum?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _max?: NestedIntFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedEnumPlaylistItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlaylistItemType | EnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    in?: $Enums.PlaylistItemType[] | ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: $Enums.PlaylistItemType[] | ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedEnumPlaylistItemTypeFilter<$PrismaModel> | $Enums.PlaylistItemType | $Types.Skip
  }

  export type NestedEnumPlaylistItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlaylistItemType | EnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    in?: $Enums.PlaylistItemType[] | ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: $Enums.PlaylistItemType[] | ListEnumPlaylistItemTypeFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedEnumPlaylistItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlaylistItemType | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedEnumPlaylistItemTypeFilter<$PrismaModel> | $Types.Skip
    _max?: NestedEnumPlaylistItemTypeFilter<$PrismaModel> | $Types.Skip
  }

  export type NestedEnumLayoutRotationFilter<$PrismaModel = never> = {
    equals?: $Enums.LayoutRotation | EnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    in?: $Enums.LayoutRotation[] | ListEnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: $Enums.LayoutRotation[] | ListEnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedEnumLayoutRotationFilter<$PrismaModel> | $Enums.LayoutRotation | $Types.Skip
  }

  export type NestedEnumLayoutRotationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LayoutRotation | EnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    in?: $Enums.LayoutRotation[] | ListEnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    notIn?: $Enums.LayoutRotation[] | ListEnumLayoutRotationFieldRefInput<$PrismaModel> | $Types.Skip
    not?: NestedEnumLayoutRotationWithAggregatesFilter<$PrismaModel> | $Enums.LayoutRotation | $Types.Skip
    _count?: NestedIntFilter<$PrismaModel> | $Types.Skip
    _min?: NestedEnumLayoutRotationFilter<$PrismaModel> | $Types.Skip
    _max?: NestedEnumLayoutRotationFilter<$PrismaModel> | $Types.Skip
  }

  export type ScreenCreateWithoutDeviceInput = {
    id?: string | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutScreensInput
    playlists?: PlaylistScreenCreateNestedManyWithoutScreenInput | $Types.Skip
    group?: ScreenGroupCreateNestedOneWithoutScreensInput | $Types.Skip
  }

  export type ScreenUncheckedCreateWithoutDeviceInput = {
    id?: string | $Types.Skip
    workspaceId: string
    groupId?: string | null | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlists?: PlaylistScreenUncheckedCreateNestedManyWithoutScreenInput | $Types.Skip
  }

  export type ScreenCreateOrConnectWithoutDeviceInput = {
    where: ScreenWhereUniqueInput
    create: XOR<ScreenCreateWithoutDeviceInput, ScreenUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceTelemetryCreateWithoutDeviceInput = {
    id?: string | $Types.Skip
    localIpAddress?: string | null | $Types.Skip
    publicIpAddress?: string | null | $Types.Skip
    macAddress?: string | null | $Types.Skip
    softwareVersion?: string | null | $Types.Skip
    platform?: string | null | $Types.Skip
    osRelease?: string | null | $Types.Skip
    screenResolutionWidth?: number | null | $Types.Skip
    screenResolutionHeight?: number | null | $Types.Skip
    hostname?: string | null | $Types.Skip
    timezone?: string | null | $Types.Skip
    totalMemory?: bigint | number | null | $Types.Skip
    freeMemory?: bigint | number | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceTelemetryUncheckedCreateWithoutDeviceInput = {
    id?: string | $Types.Skip
    localIpAddress?: string | null | $Types.Skip
    publicIpAddress?: string | null | $Types.Skip
    macAddress?: string | null | $Types.Skip
    softwareVersion?: string | null | $Types.Skip
    platform?: string | null | $Types.Skip
    osRelease?: string | null | $Types.Skip
    screenResolutionWidth?: number | null | $Types.Skip
    screenResolutionHeight?: number | null | $Types.Skip
    hostname?: string | null | $Types.Skip
    timezone?: string | null | $Types.Skip
    totalMemory?: bigint | number | null | $Types.Skip
    freeMemory?: bigint | number | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceTelemetryCreateOrConnectWithoutDeviceInput = {
    where: DeviceTelemetryWhereUniqueInput
    create: XOR<DeviceTelemetryCreateWithoutDeviceInput, DeviceTelemetryUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceTelemetryCreateManyDeviceInputEnvelope = {
    data: DeviceTelemetryCreateManyDeviceInput | DeviceTelemetryCreateManyDeviceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type DeviceStatusCreateWithoutDeviceInput = {
    id?: string | $Types.Skip
    isOnline: boolean
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceStatusUncheckedCreateWithoutDeviceInput = {
    id?: string | $Types.Skip
    isOnline: boolean
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceStatusCreateOrConnectWithoutDeviceInput = {
    where: DeviceStatusWhereUniqueInput
    create: XOR<DeviceStatusCreateWithoutDeviceInput, DeviceStatusUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceStatusCreateManyDeviceInputEnvelope = {
    data: DeviceStatusCreateManyDeviceInput | DeviceStatusCreateManyDeviceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type ScreenUpsertWithoutDeviceInput = {
    update: XOR<ScreenUpdateWithoutDeviceInput, ScreenUncheckedUpdateWithoutDeviceInput>
    create: XOR<ScreenCreateWithoutDeviceInput, ScreenUncheckedCreateWithoutDeviceInput>
    where?: ScreenWhereInput | $Types.Skip
  }

  export type ScreenUpdateToOneWithWhereWithoutDeviceInput = {
    where?: ScreenWhereInput | $Types.Skip
    data: XOR<ScreenUpdateWithoutDeviceInput, ScreenUncheckedUpdateWithoutDeviceInput>
  }

  export type ScreenUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutScreensNestedInput | $Types.Skip
    playlists?: PlaylistScreenUpdateManyWithoutScreenNestedInput | $Types.Skip
    group?: ScreenGroupUpdateOneWithoutScreensNestedInput | $Types.Skip
  }

  export type ScreenUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    groupId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlists?: PlaylistScreenUncheckedUpdateManyWithoutScreenNestedInput | $Types.Skip
  }

  export type DeviceTelemetryUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceTelemetryWhereUniqueInput
    update: XOR<DeviceTelemetryUpdateWithoutDeviceInput, DeviceTelemetryUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceTelemetryCreateWithoutDeviceInput, DeviceTelemetryUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceTelemetryUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceTelemetryWhereUniqueInput
    data: XOR<DeviceTelemetryUpdateWithoutDeviceInput, DeviceTelemetryUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceTelemetryUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceTelemetryScalarWhereInput
    data: XOR<DeviceTelemetryUpdateManyMutationInput, DeviceTelemetryUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceTelemetryScalarWhereInput = {
    AND?: DeviceTelemetryScalarWhereInput | DeviceTelemetryScalarWhereInput[] | $Types.Skip
    OR?: DeviceTelemetryScalarWhereInput[] | $Types.Skip
    NOT?: DeviceTelemetryScalarWhereInput | DeviceTelemetryScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"DeviceTelemetry"> | string | $Types.Skip
    deviceId?: StringFilter<"DeviceTelemetry"> | string | $Types.Skip
    localIpAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    publicIpAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    macAddress?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    softwareVersion?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    platform?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    osRelease?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    screenResolutionWidth?: IntNullableFilter<"DeviceTelemetry"> | number | null | $Types.Skip
    screenResolutionHeight?: IntNullableFilter<"DeviceTelemetry"> | number | null | $Types.Skip
    hostname?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    timezone?: StringNullableFilter<"DeviceTelemetry"> | string | null | $Types.Skip
    totalMemory?: BigIntNullableFilter<"DeviceTelemetry"> | bigint | number | null | $Types.Skip
    freeMemory?: BigIntNullableFilter<"DeviceTelemetry"> | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFilter<"DeviceTelemetry"> | Date | string | $Types.Skip
  }

  export type DeviceStatusUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceStatusWhereUniqueInput
    update: XOR<DeviceStatusUpdateWithoutDeviceInput, DeviceStatusUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceStatusCreateWithoutDeviceInput, DeviceStatusUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceStatusUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceStatusWhereUniqueInput
    data: XOR<DeviceStatusUpdateWithoutDeviceInput, DeviceStatusUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceStatusUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceStatusScalarWhereInput
    data: XOR<DeviceStatusUpdateManyMutationInput, DeviceStatusUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceStatusScalarWhereInput = {
    AND?: DeviceStatusScalarWhereInput | DeviceStatusScalarWhereInput[] | $Types.Skip
    OR?: DeviceStatusScalarWhereInput[] | $Types.Skip
    NOT?: DeviceStatusScalarWhereInput | DeviceStatusScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"DeviceStatus"> | string | $Types.Skip
    deviceId?: StringFilter<"DeviceStatus"> | string | $Types.Skip
    isOnline?: BoolFilter<"DeviceStatus"> | boolean | $Types.Skip
    createdAt?: DateTimeFilter<"DeviceStatus"> | Date | string | $Types.Skip
  }

  export type DeviceCreateWithoutStatusLogInput = {
    id?: string | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
    screen?: ScreenCreateNestedOneWithoutDeviceInput | $Types.Skip
    telemetry?: DeviceTelemetryCreateNestedManyWithoutDeviceInput | $Types.Skip
  }

  export type DeviceUncheckedCreateWithoutStatusLogInput = {
    id?: string | $Types.Skip
    screenId?: string | null | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
    telemetry?: DeviceTelemetryUncheckedCreateNestedManyWithoutDeviceInput | $Types.Skip
  }

  export type DeviceCreateOrConnectWithoutStatusLogInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutStatusLogInput, DeviceUncheckedCreateWithoutStatusLogInput>
  }

  export type DeviceUpsertWithoutStatusLogInput = {
    update: XOR<DeviceUpdateWithoutStatusLogInput, DeviceUncheckedUpdateWithoutStatusLogInput>
    create: XOR<DeviceCreateWithoutStatusLogInput, DeviceUncheckedCreateWithoutStatusLogInput>
    where?: DeviceWhereInput | $Types.Skip
  }

  export type DeviceUpdateToOneWithWhereWithoutStatusLogInput = {
    where?: DeviceWhereInput | $Types.Skip
    data: XOR<DeviceUpdateWithoutStatusLogInput, DeviceUncheckedUpdateWithoutStatusLogInput>
  }

  export type DeviceUpdateWithoutStatusLogInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    screen?: ScreenUpdateOneWithoutDeviceNestedInput | $Types.Skip
    telemetry?: DeviceTelemetryUpdateManyWithoutDeviceNestedInput | $Types.Skip
  }

  export type DeviceUncheckedUpdateWithoutStatusLogInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    screenId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    telemetry?: DeviceTelemetryUncheckedUpdateManyWithoutDeviceNestedInput | $Types.Skip
  }

  export type DeviceCreateWithoutTelemetryInput = {
    id?: string | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
    screen?: ScreenCreateNestedOneWithoutDeviceInput | $Types.Skip
    statusLog?: DeviceStatusCreateNestedManyWithoutDeviceInput | $Types.Skip
  }

  export type DeviceUncheckedCreateWithoutTelemetryInput = {
    id?: string | $Types.Skip
    screenId?: string | null | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
    statusLog?: DeviceStatusUncheckedCreateNestedManyWithoutDeviceInput | $Types.Skip
  }

  export type DeviceCreateOrConnectWithoutTelemetryInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutTelemetryInput, DeviceUncheckedCreateWithoutTelemetryInput>
  }

  export type DeviceUpsertWithoutTelemetryInput = {
    update: XOR<DeviceUpdateWithoutTelemetryInput, DeviceUncheckedUpdateWithoutTelemetryInput>
    create: XOR<DeviceCreateWithoutTelemetryInput, DeviceUncheckedCreateWithoutTelemetryInput>
    where?: DeviceWhereInput | $Types.Skip
  }

  export type DeviceUpdateToOneWithWhereWithoutTelemetryInput = {
    where?: DeviceWhereInput | $Types.Skip
    data: XOR<DeviceUpdateWithoutTelemetryInput, DeviceUncheckedUpdateWithoutTelemetryInput>
  }

  export type DeviceUpdateWithoutTelemetryInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    screen?: ScreenUpdateOneWithoutDeviceNestedInput | $Types.Skip
    statusLog?: DeviceStatusUpdateManyWithoutDeviceNestedInput | $Types.Skip
  }

  export type DeviceUncheckedUpdateWithoutTelemetryInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    screenId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    statusLog?: DeviceStatusUncheckedUpdateManyWithoutDeviceNestedInput | $Types.Skip
  }

  export type UserCreateWithoutEmailVerificationTokensInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    sessions?: SessionCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserUncheckedCreateWithoutEmailVerificationTokensInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserCreateOrConnectWithoutEmailVerificationTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
  }

  export type UserUpsertWithoutEmailVerificationTokensInput = {
    update: XOR<UserUpdateWithoutEmailVerificationTokensInput, UserUncheckedUpdateWithoutEmailVerificationTokensInput>
    create: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
    where?: UserWhereInput | $Types.Skip
  }

  export type UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput = {
    where?: UserWhereInput | $Types.Skip
    data: XOR<UserUpdateWithoutEmailVerificationTokensInput, UserUncheckedUpdateWithoutEmailVerificationTokensInput>
  }

  export type UserUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    sessions?: SessionUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserUncheckedUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type FolderCreateWithoutFilesInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFoldersInput
    parent?: FolderCreateNestedOneWithoutSubfoldersInput | $Types.Skip
    subfolders?: FolderCreateNestedManyWithoutParentInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderUncheckedCreateWithoutFilesInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    parentId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedCreateNestedManyWithoutParentInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderCreateOrConnectWithoutFilesInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutFilesInput, FolderUncheckedCreateWithoutFilesInput>
  }

  export type WorkspaceCreateWithoutFilesInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutFilesInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutFilesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutFilesInput, WorkspaceUncheckedCreateWithoutFilesInput>
  }

  export type UserCreateWithoutUploadedFilesInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesCreateNestedManyWithoutUserInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserUncheckedCreateWithoutUploadedFilesInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserCreateOrConnectWithoutUploadedFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
  }

  export type PlaylistItemCreateWithoutFileInput = {
    id?: string | $Types.Skip
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlist: PlaylistCreateNestedOneWithoutItemsInput
    nestedPlaylist?: PlaylistCreateNestedOneWithoutParentItemsInput | $Types.Skip
    playlistLayoutSection: PlaylistLayoutSectionCreateNestedOneWithoutPlaylistItemsInput
  }

  export type PlaylistItemUncheckedCreateWithoutFileInput = {
    id?: string | $Types.Skip
    playlistId: string
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    playlistLayoutSectionId: string
    nestedPlaylistId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemCreateOrConnectWithoutFileInput = {
    where: PlaylistItemWhereUniqueInput
    create: XOR<PlaylistItemCreateWithoutFileInput, PlaylistItemUncheckedCreateWithoutFileInput>
  }

  export type PlaylistItemCreateManyFileInputEnvelope = {
    data: PlaylistItemCreateManyFileInput | PlaylistItemCreateManyFileInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type FolderUpsertWithoutFilesInput = {
    update: XOR<FolderUpdateWithoutFilesInput, FolderUncheckedUpdateWithoutFilesInput>
    create: XOR<FolderCreateWithoutFilesInput, FolderUncheckedCreateWithoutFilesInput>
    where?: FolderWhereInput | $Types.Skip
  }

  export type FolderUpdateToOneWithWhereWithoutFilesInput = {
    where?: FolderWhereInput | $Types.Skip
    data: XOR<FolderUpdateWithoutFilesInput, FolderUncheckedUpdateWithoutFilesInput>
  }

  export type FolderUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFoldersNestedInput | $Types.Skip
    parent?: FolderUpdateOneWithoutSubfoldersNestedInput | $Types.Skip
    subfolders?: FolderUpdateManyWithoutParentNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    parentId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedUpdateManyWithoutParentNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type WorkspaceUpsertWithoutFilesInput = {
    update: XOR<WorkspaceUpdateWithoutFilesInput, WorkspaceUncheckedUpdateWithoutFilesInput>
    create: XOR<WorkspaceCreateWithoutFilesInput, WorkspaceUncheckedCreateWithoutFilesInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutFilesInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutFilesInput, WorkspaceUncheckedUpdateWithoutFilesInput>
  }

  export type WorkspaceUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type UserUpsertWithoutUploadedFilesInput = {
    update: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    where?: UserWhereInput | $Types.Skip
  }

  export type UserUpdateToOneWithWhereWithoutUploadedFilesInput = {
    where?: UserWhereInput | $Types.Skip
    data: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type UserUpdateWithoutUploadedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUpdateManyWithoutUserNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserUncheckedUpdateWithoutUploadedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type PlaylistItemUpsertWithWhereUniqueWithoutFileInput = {
    where: PlaylistItemWhereUniqueInput
    update: XOR<PlaylistItemUpdateWithoutFileInput, PlaylistItemUncheckedUpdateWithoutFileInput>
    create: XOR<PlaylistItemCreateWithoutFileInput, PlaylistItemUncheckedCreateWithoutFileInput>
  }

  export type PlaylistItemUpdateWithWhereUniqueWithoutFileInput = {
    where: PlaylistItemWhereUniqueInput
    data: XOR<PlaylistItemUpdateWithoutFileInput, PlaylistItemUncheckedUpdateWithoutFileInput>
  }

  export type PlaylistItemUpdateManyWithWhereWithoutFileInput = {
    where: PlaylistItemScalarWhereInput
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyWithoutFileInput>
  }

  export type PlaylistItemScalarWhereInput = {
    AND?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
    OR?: PlaylistItemScalarWhereInput[] | $Types.Skip
    NOT?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"PlaylistItem"> | string | $Types.Skip
    playlistId?: StringFilter<"PlaylistItem"> | string | $Types.Skip
    type?: EnumPlaylistItemTypeFilter<"PlaylistItem"> | $Enums.PlaylistItemType | $Types.Skip
    duration?: IntNullableFilter<"PlaylistItem"> | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFilter<"PlaylistItem"> | string | $Types.Skip
    fileId?: StringNullableFilter<"PlaylistItem"> | string | null | $Types.Skip
    nestedPlaylistId?: StringNullableFilter<"PlaylistItem"> | string | null | $Types.Skip
    order?: IntFilter<"PlaylistItem"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistItem"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistItem"> | Date | string | $Types.Skip
  }

  export type FolderCreateWithoutFileUploadSessionsInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFoldersInput
    parent?: FolderCreateNestedOneWithoutSubfoldersInput | $Types.Skip
    subfolders?: FolderCreateNestedManyWithoutParentInput | $Types.Skip
    files?: FileCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderUncheckedCreateWithoutFileUploadSessionsInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    parentId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedCreateNestedManyWithoutParentInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderCreateOrConnectWithoutFileUploadSessionsInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutFileUploadSessionsInput, FolderUncheckedCreateWithoutFileUploadSessionsInput>
  }

  export type WorkspaceCreateWithoutFileUploadSessionsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutFileUploadSessionsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutFileUploadSessionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutFileUploadSessionsInput, WorkspaceUncheckedCreateWithoutFileUploadSessionsInput>
  }

  export type UserCreateWithoutFileUploadSessionsInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserUncheckedCreateWithoutFileUploadSessionsInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserCreateOrConnectWithoutFileUploadSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFileUploadSessionsInput, UserUncheckedCreateWithoutFileUploadSessionsInput>
  }

  export type FolderUpsertWithoutFileUploadSessionsInput = {
    update: XOR<FolderUpdateWithoutFileUploadSessionsInput, FolderUncheckedUpdateWithoutFileUploadSessionsInput>
    create: XOR<FolderCreateWithoutFileUploadSessionsInput, FolderUncheckedCreateWithoutFileUploadSessionsInput>
    where?: FolderWhereInput | $Types.Skip
  }

  export type FolderUpdateToOneWithWhereWithoutFileUploadSessionsInput = {
    where?: FolderWhereInput | $Types.Skip
    data: XOR<FolderUpdateWithoutFileUploadSessionsInput, FolderUncheckedUpdateWithoutFileUploadSessionsInput>
  }

  export type FolderUpdateWithoutFileUploadSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFoldersNestedInput | $Types.Skip
    parent?: FolderUpdateOneWithoutSubfoldersNestedInput | $Types.Skip
    subfolders?: FolderUpdateManyWithoutParentNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUncheckedUpdateWithoutFileUploadSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    parentId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedUpdateManyWithoutParentNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type WorkspaceUpsertWithoutFileUploadSessionsInput = {
    update: XOR<WorkspaceUpdateWithoutFileUploadSessionsInput, WorkspaceUncheckedUpdateWithoutFileUploadSessionsInput>
    create: XOR<WorkspaceCreateWithoutFileUploadSessionsInput, WorkspaceUncheckedCreateWithoutFileUploadSessionsInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutFileUploadSessionsInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutFileUploadSessionsInput, WorkspaceUncheckedUpdateWithoutFileUploadSessionsInput>
  }

  export type WorkspaceUpdateWithoutFileUploadSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutFileUploadSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type UserUpsertWithoutFileUploadSessionsInput = {
    update: XOR<UserUpdateWithoutFileUploadSessionsInput, UserUncheckedUpdateWithoutFileUploadSessionsInput>
    create: XOR<UserCreateWithoutFileUploadSessionsInput, UserUncheckedCreateWithoutFileUploadSessionsInput>
    where?: UserWhereInput | $Types.Skip
  }

  export type UserUpdateToOneWithWhereWithoutFileUploadSessionsInput = {
    where?: UserWhereInput | $Types.Skip
    data: XOR<UserUpdateWithoutFileUploadSessionsInput, UserUncheckedUpdateWithoutFileUploadSessionsInput>
  }

  export type UserUpdateWithoutFileUploadSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserUncheckedUpdateWithoutFileUploadSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type WorkspaceCreateWithoutFoldersInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutFoldersInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutFoldersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutFoldersInput, WorkspaceUncheckedCreateWithoutFoldersInput>
  }

  export type FolderCreateWithoutSubfoldersInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFoldersInput
    parent?: FolderCreateNestedOneWithoutSubfoldersInput | $Types.Skip
    files?: FileCreateNestedManyWithoutFolderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderUncheckedCreateWithoutSubfoldersInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    parentId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderCreateOrConnectWithoutSubfoldersInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutSubfoldersInput, FolderUncheckedCreateWithoutSubfoldersInput>
  }

  export type FolderCreateWithoutParentInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFoldersInput
    subfolders?: FolderCreateNestedManyWithoutParentInput | $Types.Skip
    files?: FileCreateNestedManyWithoutFolderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderUncheckedCreateWithoutParentInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedCreateNestedManyWithoutParentInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderCreateOrConnectWithoutParentInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderCreateManyParentInputEnvelope = {
    data: FolderCreateManyParentInput | FolderCreateManyParentInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type FileCreateWithoutFolderInput = {
    id?: string | $Types.Skip
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFilesInput
    uploader?: UserCreateNestedOneWithoutUploadedFilesInput | $Types.Skip
    playlistItems?: PlaylistItemCreateNestedManyWithoutFileInput | $Types.Skip
  }

  export type FileUncheckedCreateWithoutFolderInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    uploaderId?: string | null | $Types.Skip
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutFileInput | $Types.Skip
  }

  export type FileCreateOrConnectWithoutFolderInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput>
  }

  export type FileCreateManyFolderInputEnvelope = {
    data: FileCreateManyFolderInput | FileCreateManyFolderInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type FileUploadSessionCreateWithoutFolderInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    uploadId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFileUploadSessionsInput
    user: UserCreateNestedOneWithoutFileUploadSessionsInput
  }

  export type FileUploadSessionUncheckedCreateWithoutFolderInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    workspaceId: string
    uploadId: string
    userId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
  }

  export type FileUploadSessionCreateOrConnectWithoutFolderInput = {
    where: FileUploadSessionWhereUniqueInput
    create: XOR<FileUploadSessionCreateWithoutFolderInput, FileUploadSessionUncheckedCreateWithoutFolderInput>
  }

  export type FileUploadSessionCreateManyFolderInputEnvelope = {
    data: FileUploadSessionCreateManyFolderInput | FileUploadSessionCreateManyFolderInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type WorkspaceUpsertWithoutFoldersInput = {
    update: XOR<WorkspaceUpdateWithoutFoldersInput, WorkspaceUncheckedUpdateWithoutFoldersInput>
    create: XOR<WorkspaceCreateWithoutFoldersInput, WorkspaceUncheckedCreateWithoutFoldersInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutFoldersInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutFoldersInput, WorkspaceUncheckedUpdateWithoutFoldersInput>
  }

  export type WorkspaceUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type FolderUpsertWithoutSubfoldersInput = {
    update: XOR<FolderUpdateWithoutSubfoldersInput, FolderUncheckedUpdateWithoutSubfoldersInput>
    create: XOR<FolderCreateWithoutSubfoldersInput, FolderUncheckedCreateWithoutSubfoldersInput>
    where?: FolderWhereInput | $Types.Skip
  }

  export type FolderUpdateToOneWithWhereWithoutSubfoldersInput = {
    where?: FolderWhereInput | $Types.Skip
    data: XOR<FolderUpdateWithoutSubfoldersInput, FolderUncheckedUpdateWithoutSubfoldersInput>
  }

  export type FolderUpdateWithoutSubfoldersInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFoldersNestedInput | $Types.Skip
    parent?: FolderUpdateOneWithoutSubfoldersNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutFolderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUncheckedUpdateWithoutSubfoldersInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    parentId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUpsertWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
  }

  export type FolderUpdateManyWithWhereWithoutParentInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutParentInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[] | $Types.Skip
    OR?: FolderScalarWhereInput[] | $Types.Skip
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"Folder"> | string | $Types.Skip
    name?: StringFilter<"Folder"> | string | $Types.Skip
    workspaceId?: StringFilter<"Folder"> | string | $Types.Skip
    parentId?: StringNullableFilter<"Folder"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"Folder"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Folder"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"Folder"> | Date | string | null | $Types.Skip
  }

  export type FileUpsertWithWhereUniqueWithoutFolderInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutFolderInput, FileUncheckedUpdateWithoutFolderInput>
    create: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput>
  }

  export type FileUpdateWithWhereUniqueWithoutFolderInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutFolderInput, FileUncheckedUpdateWithoutFolderInput>
  }

  export type FileUpdateManyWithWhereWithoutFolderInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutFolderInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[] | $Types.Skip
    OR?: FileScalarWhereInput[] | $Types.Skip
    NOT?: FileScalarWhereInput | FileScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"File"> | string | $Types.Skip
    workspaceId?: StringFilter<"File"> | string | $Types.Skip
    name?: StringFilter<"File"> | string | $Types.Skip
    extension?: StringFilter<"File"> | string | $Types.Skip
    mimeType?: StringFilter<"File"> | string | $Types.Skip
    previewPath?: StringNullableFilter<"File"> | string | null | $Types.Skip
    size?: BigIntFilter<"File"> | bigint | number | $Types.Skip
    type?: StringFilter<"File"> | string | $Types.Skip
    path?: StringFilter<"File"> | string | $Types.Skip
    width?: IntNullableFilter<"File"> | number | null | $Types.Skip
    height?: IntNullableFilter<"File"> | number | null | $Types.Skip
    duration?: IntNullableFilter<"File"> | number | null | $Types.Skip
    defaultDuration?: IntNullableFilter<"File"> | number | null | $Types.Skip
    md5?: StringNullableFilter<"File"> | string | null | $Types.Skip
    folderId?: StringNullableFilter<"File"> | string | null | $Types.Skip
    availabilityStartAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    availabilityEndAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"File"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"File"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"File"> | Date | string | null | $Types.Skip
    uploaderId?: StringNullableFilter<"File"> | string | null | $Types.Skip
  }

  export type FileUploadSessionUpsertWithWhereUniqueWithoutFolderInput = {
    where: FileUploadSessionWhereUniqueInput
    update: XOR<FileUploadSessionUpdateWithoutFolderInput, FileUploadSessionUncheckedUpdateWithoutFolderInput>
    create: XOR<FileUploadSessionCreateWithoutFolderInput, FileUploadSessionUncheckedCreateWithoutFolderInput>
  }

  export type FileUploadSessionUpdateWithWhereUniqueWithoutFolderInput = {
    where: FileUploadSessionWhereUniqueInput
    data: XOR<FileUploadSessionUpdateWithoutFolderInput, FileUploadSessionUncheckedUpdateWithoutFolderInput>
  }

  export type FileUploadSessionUpdateManyWithWhereWithoutFolderInput = {
    where: FileUploadSessionScalarWhereInput
    data: XOR<FileUploadSessionUpdateManyMutationInput, FileUploadSessionUncheckedUpdateManyWithoutFolderInput>
  }

  export type FileUploadSessionScalarWhereInput = {
    AND?: FileUploadSessionScalarWhereInput | FileUploadSessionScalarWhereInput[] | $Types.Skip
    OR?: FileUploadSessionScalarWhereInput[] | $Types.Skip
    NOT?: FileUploadSessionScalarWhereInput | FileUploadSessionScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    name?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    path?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    size?: BigIntFilter<"FileUploadSession"> | bigint | number | $Types.Skip
    uploaded?: BigIntFilter<"FileUploadSession"> | bigint | number | $Types.Skip
    parts?: IntFilter<"FileUploadSession"> | number | $Types.Skip
    mimeType?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    workspaceId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    uploadId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    folderId?: StringNullableFilter<"FileUploadSession"> | string | null | $Types.Skip
    userId?: StringFilter<"FileUploadSession"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"FileUploadSession"> | Date | string | $Types.Skip
    completedAt?: DateTimeNullableFilter<"FileUploadSession"> | Date | string | null | $Types.Skip
  }

  export type WorkspaceCreateWithoutPlaylistsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutPlaylistsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutPlaylistsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutPlaylistsInput, WorkspaceUncheckedCreateWithoutPlaylistsInput>
  }

  export type PlaylistLayoutCreateWithoutPlaylistsInput = {
    id?: string | $Types.Skip
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutLayoutsInput
    sections?: PlaylistLayoutSectionCreateNestedManyWithoutPlaylistLayoutInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedCreateWithoutPlaylistsInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    sections?: PlaylistLayoutSectionUncheckedCreateNestedManyWithoutPlaylistLayoutInput | $Types.Skip
  }

  export type PlaylistLayoutCreateOrConnectWithoutPlaylistsInput = {
    where: PlaylistLayoutWhereUniqueInput
    create: XOR<PlaylistLayoutCreateWithoutPlaylistsInput, PlaylistLayoutUncheckedCreateWithoutPlaylistsInput>
  }

  export type PlaylistItemCreateWithoutPlaylistInput = {
    id?: string | $Types.Skip
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    file?: FileCreateNestedOneWithoutPlaylistItemsInput | $Types.Skip
    nestedPlaylist?: PlaylistCreateNestedOneWithoutParentItemsInput | $Types.Skip
    playlistLayoutSection: PlaylistLayoutSectionCreateNestedOneWithoutPlaylistItemsInput
  }

  export type PlaylistItemUncheckedCreateWithoutPlaylistInput = {
    id?: string | $Types.Skip
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    playlistLayoutSectionId: string
    fileId?: string | null | $Types.Skip
    nestedPlaylistId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemCreateOrConnectWithoutPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    create: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistItemCreateManyPlaylistInputEnvelope = {
    data: PlaylistItemCreateManyPlaylistInput | PlaylistItemCreateManyPlaylistInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type PlaylistItemCreateWithoutNestedPlaylistInput = {
    id?: string | $Types.Skip
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlist: PlaylistCreateNestedOneWithoutItemsInput
    file?: FileCreateNestedOneWithoutPlaylistItemsInput | $Types.Skip
    playlistLayoutSection: PlaylistLayoutSectionCreateNestedOneWithoutPlaylistItemsInput
  }

  export type PlaylistItemUncheckedCreateWithoutNestedPlaylistInput = {
    id?: string | $Types.Skip
    playlistId: string
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    playlistLayoutSectionId: string
    fileId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemCreateOrConnectWithoutNestedPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    create: XOR<PlaylistItemCreateWithoutNestedPlaylistInput, PlaylistItemUncheckedCreateWithoutNestedPlaylistInput>
  }

  export type PlaylistItemCreateManyNestedPlaylistInputEnvelope = {
    data: PlaylistItemCreateManyNestedPlaylistInput | PlaylistItemCreateManyNestedPlaylistInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type PlaylistScreenCreateWithoutPlaylistInput = {
    screen: ScreenCreateNestedOneWithoutPlaylistsInput
  }

  export type PlaylistScreenUncheckedCreateWithoutPlaylistInput = {
    screenId: string
  }

  export type PlaylistScreenCreateOrConnectWithoutPlaylistInput = {
    where: PlaylistScreenWhereUniqueInput
    create: XOR<PlaylistScreenCreateWithoutPlaylistInput, PlaylistScreenUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistScreenCreateManyPlaylistInputEnvelope = {
    data: PlaylistScreenCreateManyPlaylistInput | PlaylistScreenCreateManyPlaylistInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type PlaylistScheduleCreateWithoutPlaylistInput = {
    id?: string | $Types.Skip
    startAt: Date | string
    endAt?: Date | string | null | $Types.Skip
    startTime?: string | null | $Types.Skip
    endTime?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    weekdays?: PlaylistScheduleCreateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScheduleUncheckedCreateWithoutPlaylistInput = {
    id?: string | $Types.Skip
    startAt: Date | string
    endAt?: Date | string | null | $Types.Skip
    startTime?: string | null | $Types.Skip
    endTime?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    weekdays?: PlaylistScheduleCreateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScheduleCreateOrConnectWithoutPlaylistInput = {
    where: PlaylistScheduleWhereUniqueInput
    create: XOR<PlaylistScheduleCreateWithoutPlaylistInput, PlaylistScheduleUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistScheduleCreateManyPlaylistInputEnvelope = {
    data: PlaylistScheduleCreateManyPlaylistInput | PlaylistScheduleCreateManyPlaylistInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type WorkspaceUpsertWithoutPlaylistsInput = {
    update: XOR<WorkspaceUpdateWithoutPlaylistsInput, WorkspaceUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<WorkspaceCreateWithoutPlaylistsInput, WorkspaceUncheckedCreateWithoutPlaylistsInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutPlaylistsInput, WorkspaceUncheckedUpdateWithoutPlaylistsInput>
  }

  export type WorkspaceUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type PlaylistLayoutUpsertWithoutPlaylistsInput = {
    update: XOR<PlaylistLayoutUpdateWithoutPlaylistsInput, PlaylistLayoutUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<PlaylistLayoutCreateWithoutPlaylistsInput, PlaylistLayoutUncheckedCreateWithoutPlaylistsInput>
    where?: PlaylistLayoutWhereInput | $Types.Skip
  }

  export type PlaylistLayoutUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: PlaylistLayoutWhereInput | $Types.Skip
    data: XOR<PlaylistLayoutUpdateWithoutPlaylistsInput, PlaylistLayoutUncheckedUpdateWithoutPlaylistsInput>
  }

  export type PlaylistLayoutUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutLayoutsNestedInput | $Types.Skip
    sections?: PlaylistLayoutSectionUpdateManyWithoutPlaylistLayoutNestedInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    sections?: PlaylistLayoutSectionUncheckedUpdateManyWithoutPlaylistLayoutNestedInput | $Types.Skip
  }

  export type PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    update: XOR<PlaylistItemUpdateWithoutPlaylistInput, PlaylistItemUncheckedUpdateWithoutPlaylistInput>
    create: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    data: XOR<PlaylistItemUpdateWithoutPlaylistInput, PlaylistItemUncheckedUpdateWithoutPlaylistInput>
  }

  export type PlaylistItemUpdateManyWithWhereWithoutPlaylistInput = {
    where: PlaylistItemScalarWhereInput
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type PlaylistItemUpsertWithWhereUniqueWithoutNestedPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    update: XOR<PlaylistItemUpdateWithoutNestedPlaylistInput, PlaylistItemUncheckedUpdateWithoutNestedPlaylistInput>
    create: XOR<PlaylistItemCreateWithoutNestedPlaylistInput, PlaylistItemUncheckedCreateWithoutNestedPlaylistInput>
  }

  export type PlaylistItemUpdateWithWhereUniqueWithoutNestedPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    data: XOR<PlaylistItemUpdateWithoutNestedPlaylistInput, PlaylistItemUncheckedUpdateWithoutNestedPlaylistInput>
  }

  export type PlaylistItemUpdateManyWithWhereWithoutNestedPlaylistInput = {
    where: PlaylistItemScalarWhereInput
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistInput>
  }

  export type PlaylistScreenUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistScreenWhereUniqueInput
    update: XOR<PlaylistScreenUpdateWithoutPlaylistInput, PlaylistScreenUncheckedUpdateWithoutPlaylistInput>
    create: XOR<PlaylistScreenCreateWithoutPlaylistInput, PlaylistScreenUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistScreenUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistScreenWhereUniqueInput
    data: XOR<PlaylistScreenUpdateWithoutPlaylistInput, PlaylistScreenUncheckedUpdateWithoutPlaylistInput>
  }

  export type PlaylistScreenUpdateManyWithWhereWithoutPlaylistInput = {
    where: PlaylistScreenScalarWhereInput
    data: XOR<PlaylistScreenUpdateManyMutationInput, PlaylistScreenUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type PlaylistScreenScalarWhereInput = {
    AND?: PlaylistScreenScalarWhereInput | PlaylistScreenScalarWhereInput[] | $Types.Skip
    OR?: PlaylistScreenScalarWhereInput[] | $Types.Skip
    NOT?: PlaylistScreenScalarWhereInput | PlaylistScreenScalarWhereInput[] | $Types.Skip
    playlistId?: StringFilter<"PlaylistScreen"> | string | $Types.Skip
    screenId?: StringFilter<"PlaylistScreen"> | string | $Types.Skip
  }

  export type PlaylistScheduleUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistScheduleWhereUniqueInput
    update: XOR<PlaylistScheduleUpdateWithoutPlaylistInput, PlaylistScheduleUncheckedUpdateWithoutPlaylistInput>
    create: XOR<PlaylistScheduleCreateWithoutPlaylistInput, PlaylistScheduleUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistScheduleUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistScheduleWhereUniqueInput
    data: XOR<PlaylistScheduleUpdateWithoutPlaylistInput, PlaylistScheduleUncheckedUpdateWithoutPlaylistInput>
  }

  export type PlaylistScheduleUpdateManyWithWhereWithoutPlaylistInput = {
    where: PlaylistScheduleScalarWhereInput
    data: XOR<PlaylistScheduleUpdateManyMutationInput, PlaylistScheduleUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type PlaylistScheduleScalarWhereInput = {
    AND?: PlaylistScheduleScalarWhereInput | PlaylistScheduleScalarWhereInput[] | $Types.Skip
    OR?: PlaylistScheduleScalarWhereInput[] | $Types.Skip
    NOT?: PlaylistScheduleScalarWhereInput | PlaylistScheduleScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"PlaylistSchedule"> | string | $Types.Skip
    playlistId?: StringFilter<"PlaylistSchedule"> | string | $Types.Skip
    startAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    endAt?: DateTimeNullableFilter<"PlaylistSchedule"> | Date | string | null | $Types.Skip
    startTime?: StringNullableFilter<"PlaylistSchedule"> | string | null | $Types.Skip
    endTime?: StringNullableFilter<"PlaylistSchedule"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistSchedule"> | Date | string | $Types.Skip
    weekdays?: EnumWeekdayNullableListFilter<"PlaylistSchedule"> | $Types.Skip
  }

  export type PlaylistCreateWithoutItemsInput = {
    id?: string | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutPlaylistsInput
    layout?: PlaylistLayoutCreateNestedOneWithoutPlaylistsInput | $Types.Skip
    parentItems?: PlaylistItemCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistUncheckedCreateWithoutItemsInput = {
    id?: string | $Types.Skip
    workspaceId: string
    playlistLayoutId?: string | null | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    parentItems?: PlaylistItemUncheckedCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistCreateOrConnectWithoutItemsInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutItemsInput, PlaylistUncheckedCreateWithoutItemsInput>
  }

  export type FileCreateWithoutPlaylistItemsInput = {
    id?: string | $Types.Skip
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    folder?: FolderCreateNestedOneWithoutFilesInput | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFilesInput
    uploader?: UserCreateNestedOneWithoutUploadedFilesInput | $Types.Skip
  }

  export type FileUncheckedCreateWithoutPlaylistItemsInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    folderId?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    uploaderId?: string | null | $Types.Skip
  }

  export type FileCreateOrConnectWithoutPlaylistItemsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutPlaylistItemsInput, FileUncheckedCreateWithoutPlaylistItemsInput>
  }

  export type PlaylistCreateWithoutParentItemsInput = {
    id?: string | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutPlaylistsInput
    layout?: PlaylistLayoutCreateNestedOneWithoutPlaylistsInput | $Types.Skip
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput | $Types.Skip
    screens?: PlaylistScreenCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistUncheckedCreateWithoutParentItemsInput = {
    id?: string | $Types.Skip
    workspaceId: string
    playlistLayoutId?: string | null | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    screens?: PlaylistScreenUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistCreateOrConnectWithoutParentItemsInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutParentItemsInput, PlaylistUncheckedCreateWithoutParentItemsInput>
  }

  export type PlaylistLayoutSectionCreateWithoutPlaylistItemsInput = {
    id?: string | $Types.Skip
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
    playlistLayout: PlaylistLayoutCreateNestedOneWithoutSectionsInput
  }

  export type PlaylistLayoutSectionUncheckedCreateWithoutPlaylistItemsInput = {
    id?: string | $Types.Skip
    playlistLayoutId: string
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
  }

  export type PlaylistLayoutSectionCreateOrConnectWithoutPlaylistItemsInput = {
    where: PlaylistLayoutSectionWhereUniqueInput
    create: XOR<PlaylistLayoutSectionCreateWithoutPlaylistItemsInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistItemsInput>
  }

  export type PlaylistUpsertWithoutItemsInput = {
    update: XOR<PlaylistUpdateWithoutItemsInput, PlaylistUncheckedUpdateWithoutItemsInput>
    create: XOR<PlaylistCreateWithoutItemsInput, PlaylistUncheckedCreateWithoutItemsInput>
    where?: PlaylistWhereInput | $Types.Skip
  }

  export type PlaylistUpdateToOneWithWhereWithoutItemsInput = {
    where?: PlaylistWhereInput | $Types.Skip
    data: XOR<PlaylistUpdateWithoutItemsInput, PlaylistUncheckedUpdateWithoutItemsInput>
  }

  export type PlaylistUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutPlaylistsNestedInput | $Types.Skip
    layout?: PlaylistLayoutUpdateOneWithoutPlaylistsNestedInput | $Types.Skip
    parentItems?: PlaylistItemUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    parentItems?: PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type FileUpsertWithoutPlaylistItemsInput = {
    update: XOR<FileUpdateWithoutPlaylistItemsInput, FileUncheckedUpdateWithoutPlaylistItemsInput>
    create: XOR<FileCreateWithoutPlaylistItemsInput, FileUncheckedCreateWithoutPlaylistItemsInput>
    where?: FileWhereInput | $Types.Skip
  }

  export type FileUpdateToOneWithWhereWithoutPlaylistItemsInput = {
    where?: FileWhereInput | $Types.Skip
    data: XOR<FileUpdateWithoutPlaylistItemsInput, FileUncheckedUpdateWithoutPlaylistItemsInput>
  }

  export type FileUpdateWithoutPlaylistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    folder?: FolderUpdateOneWithoutFilesNestedInput | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFilesNestedInput | $Types.Skip
    uploader?: UserUpdateOneWithoutUploadedFilesNestedInput | $Types.Skip
  }

  export type FileUncheckedUpdateWithoutPlaylistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
  }

  export type PlaylistUpsertWithoutParentItemsInput = {
    update: XOR<PlaylistUpdateWithoutParentItemsInput, PlaylistUncheckedUpdateWithoutParentItemsInput>
    create: XOR<PlaylistCreateWithoutParentItemsInput, PlaylistUncheckedCreateWithoutParentItemsInput>
    where?: PlaylistWhereInput | $Types.Skip
  }

  export type PlaylistUpdateToOneWithWhereWithoutParentItemsInput = {
    where?: PlaylistWhereInput | $Types.Skip
    data: XOR<PlaylistUpdateWithoutParentItemsInput, PlaylistUncheckedUpdateWithoutParentItemsInput>
  }

  export type PlaylistUpdateWithoutParentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutPlaylistsNestedInput | $Types.Skip
    layout?: PlaylistLayoutUpdateOneWithoutPlaylistsNestedInput | $Types.Skip
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateWithoutParentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUpsertWithoutPlaylistItemsInput = {
    update: XOR<PlaylistLayoutSectionUpdateWithoutPlaylistItemsInput, PlaylistLayoutSectionUncheckedUpdateWithoutPlaylistItemsInput>
    create: XOR<PlaylistLayoutSectionCreateWithoutPlaylistItemsInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistItemsInput>
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUpdateToOneWithWhereWithoutPlaylistItemsInput = {
    where?: PlaylistLayoutSectionWhereInput | $Types.Skip
    data: XOR<PlaylistLayoutSectionUpdateWithoutPlaylistItemsInput, PlaylistLayoutSectionUncheckedUpdateWithoutPlaylistItemsInput>
  }

  export type PlaylistLayoutSectionUpdateWithoutPlaylistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
    playlistLayout?: PlaylistLayoutUpdateOneRequiredWithoutSectionsNestedInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedUpdateWithoutPlaylistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
  }

  export type WorkspaceCreateWithoutLayoutsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutLayoutsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutLayoutsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutLayoutsInput, WorkspaceUncheckedCreateWithoutLayoutsInput>
  }

  export type PlaylistCreateWithoutLayoutInput = {
    id?: string | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutPlaylistsInput
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistUncheckedCreateWithoutLayoutInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistCreateOrConnectWithoutLayoutInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutLayoutInput, PlaylistUncheckedCreateWithoutLayoutInput>
  }

  export type PlaylistCreateManyLayoutInputEnvelope = {
    data: PlaylistCreateManyLayoutInput | PlaylistCreateManyLayoutInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput = {
    id?: string | $Types.Skip
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
    playlistItems?: PlaylistItemCreateNestedManyWithoutPlaylistLayoutSectionInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput = {
    id?: string | $Types.Skip
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistLayoutSectionInput | $Types.Skip
  }

  export type PlaylistLayoutSectionCreateOrConnectWithoutPlaylistLayoutInput = {
    where: PlaylistLayoutSectionWhereUniqueInput
    create: XOR<PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput>
  }

  export type PlaylistLayoutSectionCreateManyPlaylistLayoutInputEnvelope = {
    data: PlaylistLayoutSectionCreateManyPlaylistLayoutInput | PlaylistLayoutSectionCreateManyPlaylistLayoutInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type WorkspaceUpsertWithoutLayoutsInput = {
    update: XOR<WorkspaceUpdateWithoutLayoutsInput, WorkspaceUncheckedUpdateWithoutLayoutsInput>
    create: XOR<WorkspaceCreateWithoutLayoutsInput, WorkspaceUncheckedCreateWithoutLayoutsInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutLayoutsInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutLayoutsInput, WorkspaceUncheckedUpdateWithoutLayoutsInput>
  }

  export type WorkspaceUpdateWithoutLayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutLayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type PlaylistUpsertWithWhereUniqueWithoutLayoutInput = {
    where: PlaylistWhereUniqueInput
    update: XOR<PlaylistUpdateWithoutLayoutInput, PlaylistUncheckedUpdateWithoutLayoutInput>
    create: XOR<PlaylistCreateWithoutLayoutInput, PlaylistUncheckedCreateWithoutLayoutInput>
  }

  export type PlaylistUpdateWithWhereUniqueWithoutLayoutInput = {
    where: PlaylistWhereUniqueInput
    data: XOR<PlaylistUpdateWithoutLayoutInput, PlaylistUncheckedUpdateWithoutLayoutInput>
  }

  export type PlaylistUpdateManyWithWhereWithoutLayoutInput = {
    where: PlaylistScalarWhereInput
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyWithoutLayoutInput>
  }

  export type PlaylistScalarWhereInput = {
    AND?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[] | $Types.Skip
    OR?: PlaylistScalarWhereInput[] | $Types.Skip
    NOT?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"Playlist"> | string | $Types.Skip
    workspaceId?: StringFilter<"Playlist"> | string | $Types.Skip
    playlistLayoutId?: StringNullableFilter<"Playlist"> | string | null | $Types.Skip
    name?: StringFilter<"Playlist"> | string | $Types.Skip
    description?: StringFilter<"Playlist"> | string | $Types.Skip
    size?: BigIntFilter<"Playlist"> | bigint | number | $Types.Skip
    type?: StringFilter<"Playlist"> | string | $Types.Skip
    isPublished?: BoolFilter<"Playlist"> | boolean | $Types.Skip
    priority?: IntFilter<"Playlist"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"Playlist"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"Playlist"> | Date | string | null | $Types.Skip
  }

  export type PlaylistLayoutSectionUpsertWithWhereUniqueWithoutPlaylistLayoutInput = {
    where: PlaylistLayoutSectionWhereUniqueInput
    update: XOR<PlaylistLayoutSectionUpdateWithoutPlaylistLayoutInput, PlaylistLayoutSectionUncheckedUpdateWithoutPlaylistLayoutInput>
    create: XOR<PlaylistLayoutSectionCreateWithoutPlaylistLayoutInput, PlaylistLayoutSectionUncheckedCreateWithoutPlaylistLayoutInput>
  }

  export type PlaylistLayoutSectionUpdateWithWhereUniqueWithoutPlaylistLayoutInput = {
    where: PlaylistLayoutSectionWhereUniqueInput
    data: XOR<PlaylistLayoutSectionUpdateWithoutPlaylistLayoutInput, PlaylistLayoutSectionUncheckedUpdateWithoutPlaylistLayoutInput>
  }

  export type PlaylistLayoutSectionUpdateManyWithWhereWithoutPlaylistLayoutInput = {
    where: PlaylistLayoutSectionScalarWhereInput
    data: XOR<PlaylistLayoutSectionUpdateManyMutationInput, PlaylistLayoutSectionUncheckedUpdateManyWithoutPlaylistLayoutInput>
  }

  export type PlaylistLayoutSectionScalarWhereInput = {
    AND?: PlaylistLayoutSectionScalarWhereInput | PlaylistLayoutSectionScalarWhereInput[] | $Types.Skip
    OR?: PlaylistLayoutSectionScalarWhereInput[] | $Types.Skip
    NOT?: PlaylistLayoutSectionScalarWhereInput | PlaylistLayoutSectionScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    playlistLayoutId?: StringFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    name?: StringFilter<"PlaylistLayoutSection"> | string | $Types.Skip
    top?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    left?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    width?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    height?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
    zIndex?: IntFilter<"PlaylistLayoutSection"> | number | $Types.Skip
  }

  export type PlaylistLayoutCreateWithoutSectionsInput = {
    id?: string | $Types.Skip
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutLayoutsInput
    playlists?: PlaylistCreateNestedManyWithoutLayoutInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedCreateWithoutSectionsInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutLayoutInput | $Types.Skip
  }

  export type PlaylistLayoutCreateOrConnectWithoutSectionsInput = {
    where: PlaylistLayoutWhereUniqueInput
    create: XOR<PlaylistLayoutCreateWithoutSectionsInput, PlaylistLayoutUncheckedCreateWithoutSectionsInput>
  }

  export type PlaylistItemCreateWithoutPlaylistLayoutSectionInput = {
    id?: string | $Types.Skip
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlist: PlaylistCreateNestedOneWithoutItemsInput
    file?: FileCreateNestedOneWithoutPlaylistItemsInput | $Types.Skip
    nestedPlaylist?: PlaylistCreateNestedOneWithoutParentItemsInput | $Types.Skip
  }

  export type PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput = {
    id?: string | $Types.Skip
    playlistId: string
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    fileId?: string | null | $Types.Skip
    nestedPlaylistId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemCreateOrConnectWithoutPlaylistLayoutSectionInput = {
    where: PlaylistItemWhereUniqueInput
    create: XOR<PlaylistItemCreateWithoutPlaylistLayoutSectionInput, PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput>
  }

  export type PlaylistItemCreateManyPlaylistLayoutSectionInputEnvelope = {
    data: PlaylistItemCreateManyPlaylistLayoutSectionInput | PlaylistItemCreateManyPlaylistLayoutSectionInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type PlaylistLayoutUpsertWithoutSectionsInput = {
    update: XOR<PlaylistLayoutUpdateWithoutSectionsInput, PlaylistLayoutUncheckedUpdateWithoutSectionsInput>
    create: XOR<PlaylistLayoutCreateWithoutSectionsInput, PlaylistLayoutUncheckedCreateWithoutSectionsInput>
    where?: PlaylistLayoutWhereInput | $Types.Skip
  }

  export type PlaylistLayoutUpdateToOneWithWhereWithoutSectionsInput = {
    where?: PlaylistLayoutWhereInput | $Types.Skip
    data: XOR<PlaylistLayoutUpdateWithoutSectionsInput, PlaylistLayoutUncheckedUpdateWithoutSectionsInput>
  }

  export type PlaylistLayoutUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutLayoutsNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutLayoutNestedInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutLayoutNestedInput | $Types.Skip
  }

  export type PlaylistItemUpsertWithWhereUniqueWithoutPlaylistLayoutSectionInput = {
    where: PlaylistItemWhereUniqueInput
    update: XOR<PlaylistItemUpdateWithoutPlaylistLayoutSectionInput, PlaylistItemUncheckedUpdateWithoutPlaylistLayoutSectionInput>
    create: XOR<PlaylistItemCreateWithoutPlaylistLayoutSectionInput, PlaylistItemUncheckedCreateWithoutPlaylistLayoutSectionInput>
  }

  export type PlaylistItemUpdateWithWhereUniqueWithoutPlaylistLayoutSectionInput = {
    where: PlaylistItemWhereUniqueInput
    data: XOR<PlaylistItemUpdateWithoutPlaylistLayoutSectionInput, PlaylistItemUncheckedUpdateWithoutPlaylistLayoutSectionInput>
  }

  export type PlaylistItemUpdateManyWithWhereWithoutPlaylistLayoutSectionInput = {
    where: PlaylistItemScalarWhereInput
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyWithoutPlaylistLayoutSectionInput>
  }

  export type PlaylistCreateWithoutSchedulesInput = {
    id?: string | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutPlaylistsInput
    layout?: PlaylistLayoutCreateNestedOneWithoutPlaylistsInput | $Types.Skip
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistUncheckedCreateWithoutSchedulesInput = {
    id?: string | $Types.Skip
    workspaceId: string
    playlistLayoutId?: string | null | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistCreateOrConnectWithoutSchedulesInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutSchedulesInput, PlaylistUncheckedCreateWithoutSchedulesInput>
  }

  export type PlaylistUpsertWithoutSchedulesInput = {
    update: XOR<PlaylistUpdateWithoutSchedulesInput, PlaylistUncheckedUpdateWithoutSchedulesInput>
    create: XOR<PlaylistCreateWithoutSchedulesInput, PlaylistUncheckedCreateWithoutSchedulesInput>
    where?: PlaylistWhereInput | $Types.Skip
  }

  export type PlaylistUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: PlaylistWhereInput | $Types.Skip
    data: XOR<PlaylistUpdateWithoutSchedulesInput, PlaylistUncheckedUpdateWithoutSchedulesInput>
  }

  export type PlaylistUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutPlaylistsNestedInput | $Types.Skip
    layout?: PlaylistLayoutUpdateOneWithoutPlaylistsNestedInput | $Types.Skip
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistCreateWithoutScreensInput = {
    id?: string | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutPlaylistsInput
    layout?: PlaylistLayoutCreateNestedOneWithoutPlaylistsInput | $Types.Skip
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistUncheckedCreateWithoutScreensInput = {
    id?: string | $Types.Skip
    workspaceId: string
    playlistLayoutId?: string | null | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistCreateOrConnectWithoutScreensInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutScreensInput, PlaylistUncheckedCreateWithoutScreensInput>
  }

  export type ScreenCreateWithoutPlaylistsInput = {
    id?: string | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutScreensInput
    device?: DeviceCreateNestedOneWithoutScreenInput | $Types.Skip
    group?: ScreenGroupCreateNestedOneWithoutScreensInput | $Types.Skip
  }

  export type ScreenUncheckedCreateWithoutPlaylistsInput = {
    id?: string | $Types.Skip
    workspaceId: string
    groupId?: string | null | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    device?: DeviceUncheckedCreateNestedOneWithoutScreenInput | $Types.Skip
  }

  export type ScreenCreateOrConnectWithoutPlaylistsInput = {
    where: ScreenWhereUniqueInput
    create: XOR<ScreenCreateWithoutPlaylistsInput, ScreenUncheckedCreateWithoutPlaylistsInput>
  }

  export type PlaylistUpsertWithoutScreensInput = {
    update: XOR<PlaylistUpdateWithoutScreensInput, PlaylistUncheckedUpdateWithoutScreensInput>
    create: XOR<PlaylistCreateWithoutScreensInput, PlaylistUncheckedCreateWithoutScreensInput>
    where?: PlaylistWhereInput | $Types.Skip
  }

  export type PlaylistUpdateToOneWithWhereWithoutScreensInput = {
    where?: PlaylistWhereInput | $Types.Skip
    data: XOR<PlaylistUpdateWithoutScreensInput, PlaylistUncheckedUpdateWithoutScreensInput>
  }

  export type PlaylistUpdateWithoutScreensInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutPlaylistsNestedInput | $Types.Skip
    layout?: PlaylistLayoutUpdateOneWithoutPlaylistsNestedInput | $Types.Skip
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateWithoutScreensInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type ScreenUpsertWithoutPlaylistsInput = {
    update: XOR<ScreenUpdateWithoutPlaylistsInput, ScreenUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<ScreenCreateWithoutPlaylistsInput, ScreenUncheckedCreateWithoutPlaylistsInput>
    where?: ScreenWhereInput | $Types.Skip
  }

  export type ScreenUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: ScreenWhereInput | $Types.Skip
    data: XOR<ScreenUpdateWithoutPlaylistsInput, ScreenUncheckedUpdateWithoutPlaylistsInput>
  }

  export type ScreenUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutScreensNestedInput | $Types.Skip
    device?: DeviceUpdateOneWithoutScreenNestedInput | $Types.Skip
    group?: ScreenGroupUpdateOneWithoutScreensNestedInput | $Types.Skip
  }

  export type ScreenUncheckedUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    groupId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    device?: DeviceUncheckedUpdateOneWithoutScreenNestedInput | $Types.Skip
  }

  export type WorkspaceCreateWithoutScreensInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutScreensInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutScreensInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutScreensInput, WorkspaceUncheckedCreateWithoutScreensInput>
  }

  export type DeviceCreateWithoutScreenInput = {
    id?: string | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
    telemetry?: DeviceTelemetryCreateNestedManyWithoutDeviceInput | $Types.Skip
    statusLog?: DeviceStatusCreateNestedManyWithoutDeviceInput | $Types.Skip
  }

  export type DeviceUncheckedCreateWithoutScreenInput = {
    id?: string | $Types.Skip
    token: string
    connectionCode: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    isOnline?: boolean | $Types.Skip
    telemetry?: DeviceTelemetryUncheckedCreateNestedManyWithoutDeviceInput | $Types.Skip
    statusLog?: DeviceStatusUncheckedCreateNestedManyWithoutDeviceInput | $Types.Skip
  }

  export type DeviceCreateOrConnectWithoutScreenInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutScreenInput, DeviceUncheckedCreateWithoutScreenInput>
  }

  export type PlaylistScreenCreateWithoutScreenInput = {
    playlist: PlaylistCreateNestedOneWithoutScreensInput
  }

  export type PlaylistScreenUncheckedCreateWithoutScreenInput = {
    playlistId: string
  }

  export type PlaylistScreenCreateOrConnectWithoutScreenInput = {
    where: PlaylistScreenWhereUniqueInput
    create: XOR<PlaylistScreenCreateWithoutScreenInput, PlaylistScreenUncheckedCreateWithoutScreenInput>
  }

  export type PlaylistScreenCreateManyScreenInputEnvelope = {
    data: PlaylistScreenCreateManyScreenInput | PlaylistScreenCreateManyScreenInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type ScreenGroupCreateWithoutScreensInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutScreenGroupsInput
  }

  export type ScreenGroupUncheckedCreateWithoutScreensInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type ScreenGroupCreateOrConnectWithoutScreensInput = {
    where: ScreenGroupWhereUniqueInput
    create: XOR<ScreenGroupCreateWithoutScreensInput, ScreenGroupUncheckedCreateWithoutScreensInput>
  }

  export type WorkspaceUpsertWithoutScreensInput = {
    update: XOR<WorkspaceUpdateWithoutScreensInput, WorkspaceUncheckedUpdateWithoutScreensInput>
    create: XOR<WorkspaceCreateWithoutScreensInput, WorkspaceUncheckedCreateWithoutScreensInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutScreensInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutScreensInput, WorkspaceUncheckedUpdateWithoutScreensInput>
  }

  export type WorkspaceUpdateWithoutScreensInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutScreensInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type DeviceUpsertWithoutScreenInput = {
    update: XOR<DeviceUpdateWithoutScreenInput, DeviceUncheckedUpdateWithoutScreenInput>
    create: XOR<DeviceCreateWithoutScreenInput, DeviceUncheckedCreateWithoutScreenInput>
    where?: DeviceWhereInput | $Types.Skip
  }

  export type DeviceUpdateToOneWithWhereWithoutScreenInput = {
    where?: DeviceWhereInput | $Types.Skip
    data: XOR<DeviceUpdateWithoutScreenInput, DeviceUncheckedUpdateWithoutScreenInput>
  }

  export type DeviceUpdateWithoutScreenInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    telemetry?: DeviceTelemetryUpdateManyWithoutDeviceNestedInput | $Types.Skip
    statusLog?: DeviceStatusUpdateManyWithoutDeviceNestedInput | $Types.Skip
  }

  export type DeviceUncheckedUpdateWithoutScreenInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    connectionCode?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    telemetry?: DeviceTelemetryUncheckedUpdateManyWithoutDeviceNestedInput | $Types.Skip
    statusLog?: DeviceStatusUncheckedUpdateManyWithoutDeviceNestedInput | $Types.Skip
  }

  export type PlaylistScreenUpsertWithWhereUniqueWithoutScreenInput = {
    where: PlaylistScreenWhereUniqueInput
    update: XOR<PlaylistScreenUpdateWithoutScreenInput, PlaylistScreenUncheckedUpdateWithoutScreenInput>
    create: XOR<PlaylistScreenCreateWithoutScreenInput, PlaylistScreenUncheckedCreateWithoutScreenInput>
  }

  export type PlaylistScreenUpdateWithWhereUniqueWithoutScreenInput = {
    where: PlaylistScreenWhereUniqueInput
    data: XOR<PlaylistScreenUpdateWithoutScreenInput, PlaylistScreenUncheckedUpdateWithoutScreenInput>
  }

  export type PlaylistScreenUpdateManyWithWhereWithoutScreenInput = {
    where: PlaylistScreenScalarWhereInput
    data: XOR<PlaylistScreenUpdateManyMutationInput, PlaylistScreenUncheckedUpdateManyWithoutScreenInput>
  }

  export type ScreenGroupUpsertWithoutScreensInput = {
    update: XOR<ScreenGroupUpdateWithoutScreensInput, ScreenGroupUncheckedUpdateWithoutScreensInput>
    create: XOR<ScreenGroupCreateWithoutScreensInput, ScreenGroupUncheckedCreateWithoutScreensInput>
    where?: ScreenGroupWhereInput | $Types.Skip
  }

  export type ScreenGroupUpdateToOneWithWhereWithoutScreensInput = {
    where?: ScreenGroupWhereInput | $Types.Skip
    data: XOR<ScreenGroupUpdateWithoutScreensInput, ScreenGroupUncheckedUpdateWithoutScreensInput>
  }

  export type ScreenGroupUpdateWithoutScreensInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutScreenGroupsNestedInput | $Types.Skip
  }

  export type ScreenGroupUncheckedUpdateWithoutScreensInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type WorkspaceCreateWithoutScreenGroupsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutScreenGroupsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutScreenGroupsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutScreenGroupsInput, WorkspaceUncheckedCreateWithoutScreenGroupsInput>
  }

  export type ScreenCreateWithoutGroupInput = {
    id?: string | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutScreensInput
    device?: DeviceCreateNestedOneWithoutScreenInput | $Types.Skip
    playlists?: PlaylistScreenCreateNestedManyWithoutScreenInput | $Types.Skip
  }

  export type ScreenUncheckedCreateWithoutGroupInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    device?: DeviceUncheckedCreateNestedOneWithoutScreenInput | $Types.Skip
    playlists?: PlaylistScreenUncheckedCreateNestedManyWithoutScreenInput | $Types.Skip
  }

  export type ScreenCreateOrConnectWithoutGroupInput = {
    where: ScreenWhereUniqueInput
    create: XOR<ScreenCreateWithoutGroupInput, ScreenUncheckedCreateWithoutGroupInput>
  }

  export type ScreenCreateManyGroupInputEnvelope = {
    data: ScreenCreateManyGroupInput | ScreenCreateManyGroupInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type WorkspaceUpsertWithoutScreenGroupsInput = {
    update: XOR<WorkspaceUpdateWithoutScreenGroupsInput, WorkspaceUncheckedUpdateWithoutScreenGroupsInput>
    create: XOR<WorkspaceCreateWithoutScreenGroupsInput, WorkspaceUncheckedCreateWithoutScreenGroupsInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutScreenGroupsInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutScreenGroupsInput, WorkspaceUncheckedUpdateWithoutScreenGroupsInput>
  }

  export type WorkspaceUpdateWithoutScreenGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutScreenGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type ScreenUpsertWithWhereUniqueWithoutGroupInput = {
    where: ScreenWhereUniqueInput
    update: XOR<ScreenUpdateWithoutGroupInput, ScreenUncheckedUpdateWithoutGroupInput>
    create: XOR<ScreenCreateWithoutGroupInput, ScreenUncheckedCreateWithoutGroupInput>
  }

  export type ScreenUpdateWithWhereUniqueWithoutGroupInput = {
    where: ScreenWhereUniqueInput
    data: XOR<ScreenUpdateWithoutGroupInput, ScreenUncheckedUpdateWithoutGroupInput>
  }

  export type ScreenUpdateManyWithWhereWithoutGroupInput = {
    where: ScreenScalarWhereInput
    data: XOR<ScreenUpdateManyMutationInput, ScreenUncheckedUpdateManyWithoutGroupInput>
  }

  export type ScreenScalarWhereInput = {
    AND?: ScreenScalarWhereInput | ScreenScalarWhereInput[] | $Types.Skip
    OR?: ScreenScalarWhereInput[] | $Types.Skip
    NOT?: ScreenScalarWhereInput | ScreenScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"Screen"> | string | $Types.Skip
    workspaceId?: StringFilter<"Screen"> | string | $Types.Skip
    groupId?: StringNullableFilter<"Screen"> | string | null | $Types.Skip
    name?: StringFilter<"Screen"> | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFilter<"Screen"> | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFilter<"Screen"> | number | $Types.Skip
    resolutionHeight?: IntFilter<"Screen"> | number | $Types.Skip
    type?: StringFilter<"Screen"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"Screen"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"Screen"> | Date | string | $Types.Skip
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput | $Types.Skip
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput | $Types.Skip
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type EmailVerificationTokenCreateWithoutUserInput = {
    id?: string | $Types.Skip
    token: string
    newEmail?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type EmailVerificationTokenUncheckedCreateWithoutUserInput = {
    id?: string | $Types.Skip
    token: string
    newEmail?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type EmailVerificationTokenCreateOrConnectWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    create: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationTokenCreateManyUserInputEnvelope = {
    data: EmailVerificationTokenCreateManyUserInput | EmailVerificationTokenCreateManyUserInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type SessionCreateWithoutUserInput = {
    id?: string | $Types.Skip
    token: string
    userAgent: string
    ipAddress: string
    createdAt?: Date | string | $Types.Skip
    revokedAt?: Date | string | null | $Types.Skip
    lastActivityAt?: Date | string | $Types.Skip
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string | $Types.Skip
    token: string
    userAgent: string
    ipAddress: string
    createdAt?: Date | string | $Types.Skip
    revokedAt?: Date | string | null | $Types.Skip
    lastActivityAt?: Date | string | $Types.Skip
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type UserWorkspaceCreateWithoutUserInput = {
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
    workspaceInvitation?: WorkspaceUserInvitationCreateNestedOneWithoutMembersInput | $Types.Skip
  }

  export type UserWorkspaceUncheckedCreateWithoutUserInput = {
    workspaceId: string
    workspaceInvitationId?: string | null | $Types.Skip
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserWorkspaceCreateOrConnectWithoutUserInput = {
    where: UserWorkspaceWhereUniqueInput
    create: XOR<UserWorkspaceCreateWithoutUserInput, UserWorkspaceUncheckedCreateWithoutUserInput>
  }

  export type UserWorkspaceCreateManyUserInputEnvelope = {
    data: UserWorkspaceCreateManyUserInput | UserWorkspaceCreateManyUserInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string | $Types.Skip
    locale: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string | $Types.Skip
    locale: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserPreferencesCreateManyUserInputEnvelope = {
    data: UserPreferencesCreateManyUserInput | UserPreferencesCreateManyUserInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type FileCreateWithoutUploaderInput = {
    id?: string | $Types.Skip
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    folder?: FolderCreateNestedOneWithoutFilesInput | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFilesInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutFileInput | $Types.Skip
  }

  export type FileUncheckedCreateWithoutUploaderInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    folderId?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutFileInput | $Types.Skip
  }

  export type FileCreateOrConnectWithoutUploaderInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput>
  }

  export type FileCreateManyUploaderInputEnvelope = {
    data: FileCreateManyUploaderInput | FileCreateManyUploaderInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type FileUploadSessionCreateWithoutUserInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    uploadId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
    folder?: FolderCreateNestedOneWithoutFileUploadSessionsInput | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutFileUploadSessionsInput
  }

  export type FileUploadSessionUncheckedCreateWithoutUserInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    workspaceId: string
    uploadId: string
    folderId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
  }

  export type FileUploadSessionCreateOrConnectWithoutUserInput = {
    where: FileUploadSessionWhereUniqueInput
    create: XOR<FileUploadSessionCreateWithoutUserInput, FileUploadSessionUncheckedCreateWithoutUserInput>
  }

  export type FileUploadSessionCreateManyUserInputEnvelope = {
    data: FileUploadSessionCreateManyUserInput | FileUploadSessionCreateManyUserInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateWithoutInvitorInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutUserInvitationsInput
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInvitationInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    workspaceId: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInvitationInput | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateOrConnectWithoutInvitorInput = {
    where: WorkspaceUserInvitationWhereUniqueInput
    create: XOR<WorkspaceUserInvitationCreateWithoutInvitorInput, WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput>
  }

  export type WorkspaceUserInvitationCreateManyInvitorInputEnvelope = {
    data: WorkspaceUserInvitationCreateManyInvitorInput | WorkspaceUserInvitationCreateManyInvitorInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    update: XOR<EmailVerificationTokenUpdateWithoutUserInput, EmailVerificationTokenUncheckedUpdateWithoutUserInput>
    create: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    data: XOR<EmailVerificationTokenUpdateWithoutUserInput, EmailVerificationTokenUncheckedUpdateWithoutUserInput>
  }

  export type EmailVerificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: EmailVerificationTokenScalarWhereInput
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailVerificationTokenScalarWhereInput = {
    AND?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[] | $Types.Skip
    OR?: EmailVerificationTokenScalarWhereInput[] | $Types.Skip
    NOT?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"EmailVerificationToken"> | string | $Types.Skip
    token?: StringFilter<"EmailVerificationToken"> | string | $Types.Skip
    userId?: StringFilter<"EmailVerificationToken"> | string | $Types.Skip
    newEmail?: StringNullableFilter<"EmailVerificationToken"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string | $Types.Skip
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[] | $Types.Skip
    OR?: SessionScalarWhereInput[] | $Types.Skip
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"Session"> | string | $Types.Skip
    userId?: StringFilter<"Session"> | string | $Types.Skip
    token?: StringFilter<"Session"> | string | $Types.Skip
    userAgent?: StringFilter<"Session"> | string | $Types.Skip
    ipAddress?: StringFilter<"Session"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"Session"> | Date | string | $Types.Skip
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFilter<"Session"> | Date | string | $Types.Skip
  }

  export type UserWorkspaceUpsertWithWhereUniqueWithoutUserInput = {
    where: UserWorkspaceWhereUniqueInput
    update: XOR<UserWorkspaceUpdateWithoutUserInput, UserWorkspaceUncheckedUpdateWithoutUserInput>
    create: XOR<UserWorkspaceCreateWithoutUserInput, UserWorkspaceUncheckedCreateWithoutUserInput>
  }

  export type UserWorkspaceUpdateWithWhereUniqueWithoutUserInput = {
    where: UserWorkspaceWhereUniqueInput
    data: XOR<UserWorkspaceUpdateWithoutUserInput, UserWorkspaceUncheckedUpdateWithoutUserInput>
  }

  export type UserWorkspaceUpdateManyWithWhereWithoutUserInput = {
    where: UserWorkspaceScalarWhereInput
    data: XOR<UserWorkspaceUpdateManyMutationInput, UserWorkspaceUncheckedUpdateManyWithoutUserInput>
  }

  export type UserWorkspaceScalarWhereInput = {
    AND?: UserWorkspaceScalarWhereInput | UserWorkspaceScalarWhereInput[] | $Types.Skip
    OR?: UserWorkspaceScalarWhereInput[] | $Types.Skip
    NOT?: UserWorkspaceScalarWhereInput | UserWorkspaceScalarWhereInput[] | $Types.Skip
    userId?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    workspaceId?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    workspaceInvitationId?: StringNullableFilter<"UserWorkspace"> | string | null | $Types.Skip
    role?: StringFilter<"UserWorkspace"> | string | $Types.Skip
    permissions?: StringNullableListFilter<"UserWorkspace"> | $Types.Skip
    createdAt?: DateTimeFilter<"UserWorkspace"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"UserWorkspace"> | Date | string | $Types.Skip
  }

  export type UserPreferencesUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateManyWithWhereWithoutUserInput = {
    where: UserPreferencesScalarWhereInput
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPreferencesScalarWhereInput = {
    AND?: UserPreferencesScalarWhereInput | UserPreferencesScalarWhereInput[] | $Types.Skip
    OR?: UserPreferencesScalarWhereInput[] | $Types.Skip
    NOT?: UserPreferencesScalarWhereInput | UserPreferencesScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"UserPreferences"> | string | $Types.Skip
    userId?: StringFilter<"UserPreferences"> | string | $Types.Skip
    locale?: StringFilter<"UserPreferences"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string | $Types.Skip
  }

  export type FileUpsertWithWhereUniqueWithoutUploaderInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUploaderInput, FileUncheckedUpdateWithoutUploaderInput>
    create: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUploaderInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUploaderInput, FileUncheckedUpdateWithoutUploaderInput>
  }

  export type FileUpdateManyWithWhereWithoutUploaderInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUploaderInput>
  }

  export type FileUploadSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: FileUploadSessionWhereUniqueInput
    update: XOR<FileUploadSessionUpdateWithoutUserInput, FileUploadSessionUncheckedUpdateWithoutUserInput>
    create: XOR<FileUploadSessionCreateWithoutUserInput, FileUploadSessionUncheckedCreateWithoutUserInput>
  }

  export type FileUploadSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: FileUploadSessionWhereUniqueInput
    data: XOR<FileUploadSessionUpdateWithoutUserInput, FileUploadSessionUncheckedUpdateWithoutUserInput>
  }

  export type FileUploadSessionUpdateManyWithWhereWithoutUserInput = {
    where: FileUploadSessionScalarWhereInput
    data: XOR<FileUploadSessionUpdateManyMutationInput, FileUploadSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceUserInvitationUpsertWithWhereUniqueWithoutInvitorInput = {
    where: WorkspaceUserInvitationWhereUniqueInput
    update: XOR<WorkspaceUserInvitationUpdateWithoutInvitorInput, WorkspaceUserInvitationUncheckedUpdateWithoutInvitorInput>
    create: XOR<WorkspaceUserInvitationCreateWithoutInvitorInput, WorkspaceUserInvitationUncheckedCreateWithoutInvitorInput>
  }

  export type WorkspaceUserInvitationUpdateWithWhereUniqueWithoutInvitorInput = {
    where: WorkspaceUserInvitationWhereUniqueInput
    data: XOR<WorkspaceUserInvitationUpdateWithoutInvitorInput, WorkspaceUserInvitationUncheckedUpdateWithoutInvitorInput>
  }

  export type WorkspaceUserInvitationUpdateManyWithWhereWithoutInvitorInput = {
    where: WorkspaceUserInvitationScalarWhereInput
    data: XOR<WorkspaceUserInvitationUpdateManyMutationInput, WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorInput>
  }

  export type WorkspaceUserInvitationScalarWhereInput = {
    AND?: WorkspaceUserInvitationScalarWhereInput | WorkspaceUserInvitationScalarWhereInput[] | $Types.Skip
    OR?: WorkspaceUserInvitationScalarWhereInput[] | $Types.Skip
    NOT?: WorkspaceUserInvitationScalarWhereInput | WorkspaceUserInvitationScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    email?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    status?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    workspaceId?: StringFilter<"WorkspaceUserInvitation"> | string | $Types.Skip
    invitorId?: StringNullableFilter<"WorkspaceUserInvitation"> | string | null | $Types.Skip
    createdAt?: DateTimeFilter<"WorkspaceUserInvitation"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"WorkspaceUserInvitation"> | Date | string | $Types.Skip
  }

  export type UserCreateWithoutUserPreferencesInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserUncheckedCreateWithoutUserPreferencesInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserCreateOrConnectWithoutUserPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
  }

  export type UserUpsertWithoutUserPreferencesInput = {
    update: XOR<UserUpdateWithoutUserPreferencesInput, UserUncheckedUpdateWithoutUserPreferencesInput>
    create: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    where?: UserWhereInput | $Types.Skip
  }

  export type UserUpdateToOneWithWhereWithoutUserPreferencesInput = {
    where?: UserWhereInput | $Types.Skip
    data: XOR<UserUpdateWithoutUserPreferencesInput, UserUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserUncheckedUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutInvitorInput | $Types.Skip
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateWithoutMembersInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutMembersInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutMembersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
  }

  export type WorkspaceUserInvitationCreateWithoutMembersInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    workspace: WorkspaceCreateNestedOneWithoutUserInvitationsInput
    invitor?: UserCreateNestedOneWithoutSentInvitationsInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedCreateWithoutMembersInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    workspaceId: string
    invitorId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateOrConnectWithoutMembersInput = {
    where: WorkspaceUserInvitationWhereUniqueInput
    create: XOR<WorkspaceUserInvitationCreateWithoutMembersInput, WorkspaceUserInvitationUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput | $Types.Skip
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput | $Types.Skip
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sentInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorNestedInput | $Types.Skip
  }

  export type WorkspaceUpsertWithoutMembersInput = {
    update: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutMembersInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    userInvitations?: WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUpsertWithoutMembersInput = {
    update: XOR<WorkspaceUserInvitationUpdateWithoutMembersInput, WorkspaceUserInvitationUncheckedUpdateWithoutMembersInput>
    create: XOR<WorkspaceUserInvitationCreateWithoutMembersInput, WorkspaceUserInvitationUncheckedCreateWithoutMembersInput>
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUpdateToOneWithWhereWithoutMembersInput = {
    where?: WorkspaceUserInvitationWhereInput | $Types.Skip
    data: XOR<WorkspaceUserInvitationUpdateWithoutMembersInput, WorkspaceUserInvitationUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceUserInvitationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutUserInvitationsNestedInput | $Types.Skip
    invitor?: UserUpdateOneWithoutSentInvitationsNestedInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    invitorId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceCreateWithoutWorkspaceInput = {
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspaceInvitation?: WorkspaceUserInvitationCreateNestedOneWithoutMembersInput | $Types.Skip
  }

  export type UserWorkspaceUncheckedCreateWithoutWorkspaceInput = {
    userId: string
    workspaceInvitationId?: string | null | $Types.Skip
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserWorkspaceCreateOrConnectWithoutWorkspaceInput = {
    where: UserWorkspaceWhereUniqueInput
    create: XOR<UserWorkspaceCreateWithoutWorkspaceInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInput>
  }

  export type UserWorkspaceCreateManyWorkspaceInputEnvelope = {
    data: UserWorkspaceCreateManyWorkspaceInput | UserWorkspaceCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type ScreenCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    device?: DeviceCreateNestedOneWithoutScreenInput | $Types.Skip
    playlists?: PlaylistScreenCreateNestedManyWithoutScreenInput | $Types.Skip
    group?: ScreenGroupCreateNestedOneWithoutScreensInput | $Types.Skip
  }

  export type ScreenUncheckedCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    groupId?: string | null | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    device?: DeviceUncheckedCreateNestedOneWithoutScreenInput | $Types.Skip
    playlists?: PlaylistScreenUncheckedCreateNestedManyWithoutScreenInput | $Types.Skip
  }

  export type ScreenCreateOrConnectWithoutWorkspaceInput = {
    where: ScreenWhereUniqueInput
    create: XOR<ScreenCreateWithoutWorkspaceInput, ScreenUncheckedCreateWithoutWorkspaceInput>
  }

  export type ScreenCreateManyWorkspaceInputEnvelope = {
    data: ScreenCreateManyWorkspaceInput | ScreenCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type PlaylistCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    layout?: PlaylistLayoutCreateNestedOneWithoutPlaylistsInput | $Types.Skip
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistUncheckedCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    playlistLayoutId?: string | null | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedCreateNestedManyWithoutNestedPlaylistInput | $Types.Skip
    screens?: PlaylistScreenUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedCreateNestedManyWithoutPlaylistInput | $Types.Skip
  }

  export type PlaylistCreateOrConnectWithoutWorkspaceInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutWorkspaceInput, PlaylistUncheckedCreateWithoutWorkspaceInput>
  }

  export type PlaylistCreateManyWorkspaceInputEnvelope = {
    data: PlaylistCreateManyWorkspaceInput | PlaylistCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type PlaylistLayoutCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutLayoutInput | $Types.Skip
    sections?: PlaylistLayoutSectionCreateNestedManyWithoutPlaylistLayoutInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutLayoutInput | $Types.Skip
    sections?: PlaylistLayoutSectionUncheckedCreateNestedManyWithoutPlaylistLayoutInput | $Types.Skip
  }

  export type PlaylistLayoutCreateOrConnectWithoutWorkspaceInput = {
    where: PlaylistLayoutWhereUniqueInput
    create: XOR<PlaylistLayoutCreateWithoutWorkspaceInput, PlaylistLayoutUncheckedCreateWithoutWorkspaceInput>
  }

  export type PlaylistLayoutCreateManyWorkspaceInputEnvelope = {
    data: PlaylistLayoutCreateManyWorkspaceInput | PlaylistLayoutCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type FileCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    folder?: FolderCreateNestedOneWithoutFilesInput | $Types.Skip
    uploader?: UserCreateNestedOneWithoutUploadedFilesInput | $Types.Skip
    playlistItems?: PlaylistItemCreateNestedManyWithoutFileInput | $Types.Skip
  }

  export type FileUncheckedCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    folderId?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    uploaderId?: string | null | $Types.Skip
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutFileInput | $Types.Skip
  }

  export type FileCreateOrConnectWithoutWorkspaceInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput>
  }

  export type FileCreateManyWorkspaceInputEnvelope = {
    data: FileCreateManyWorkspaceInput | FileCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type FolderCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    parent?: FolderCreateNestedOneWithoutSubfoldersInput | $Types.Skip
    subfolders?: FolderCreateNestedManyWithoutParentInput | $Types.Skip
    files?: FileCreateNestedManyWithoutFolderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderUncheckedCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    parentId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedCreateNestedManyWithoutParentInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutFolderInput | $Types.Skip
  }

  export type FolderCreateOrConnectWithoutWorkspaceInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutWorkspaceInput, FolderUncheckedCreateWithoutWorkspaceInput>
  }

  export type FolderCreateManyWorkspaceInputEnvelope = {
    data: FolderCreateManyWorkspaceInput | FolderCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type FileUploadSessionCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    uploadId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
    folder?: FolderCreateNestedOneWithoutFileUploadSessionsInput | $Types.Skip
    user: UserCreateNestedOneWithoutFileUploadSessionsInput
  }

  export type FileUploadSessionUncheckedCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    uploadId: string
    folderId?: string | null | $Types.Skip
    userId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
  }

  export type FileUploadSessionCreateOrConnectWithoutWorkspaceInput = {
    where: FileUploadSessionWhereUniqueInput
    create: XOR<FileUploadSessionCreateWithoutWorkspaceInput, FileUploadSessionUncheckedCreateWithoutWorkspaceInput>
  }

  export type FileUploadSessionCreateManyWorkspaceInputEnvelope = {
    data: FileUploadSessionCreateManyWorkspaceInput | FileUploadSessionCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    invitor?: UserCreateNestedOneWithoutSentInvitationsInput | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInvitationInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    invitorId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInvitationInput | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceUserInvitationWhereUniqueInput
    create: XOR<WorkspaceUserInvitationCreateWithoutWorkspaceInput, WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserInvitationCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceUserInvitationCreateManyWorkspaceInput | WorkspaceUserInvitationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type ScreenGroupCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutGroupInput | $Types.Skip
  }

  export type ScreenGroupUncheckedCreateWithoutWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutGroupInput | $Types.Skip
  }

  export type ScreenGroupCreateOrConnectWithoutWorkspaceInput = {
    where: ScreenGroupWhereUniqueInput
    create: XOR<ScreenGroupCreateWithoutWorkspaceInput, ScreenGroupUncheckedCreateWithoutWorkspaceInput>
  }

  export type ScreenGroupCreateManyWorkspaceInputEnvelope = {
    data: ScreenGroupCreateManyWorkspaceInput | ScreenGroupCreateManyWorkspaceInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: UserWorkspaceWhereUniqueInput
    update: XOR<UserWorkspaceUpdateWithoutWorkspaceInput, UserWorkspaceUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<UserWorkspaceCreateWithoutWorkspaceInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInput>
  }

  export type UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: UserWorkspaceWhereUniqueInput
    data: XOR<UserWorkspaceUpdateWithoutWorkspaceInput, UserWorkspaceUncheckedUpdateWithoutWorkspaceInput>
  }

  export type UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInput = {
    where: UserWorkspaceScalarWhereInput
    data: XOR<UserWorkspaceUpdateManyMutationInput, UserWorkspaceUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ScreenUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ScreenWhereUniqueInput
    update: XOR<ScreenUpdateWithoutWorkspaceInput, ScreenUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ScreenCreateWithoutWorkspaceInput, ScreenUncheckedCreateWithoutWorkspaceInput>
  }

  export type ScreenUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ScreenWhereUniqueInput
    data: XOR<ScreenUpdateWithoutWorkspaceInput, ScreenUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ScreenUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ScreenScalarWhereInput
    data: XOR<ScreenUpdateManyMutationInput, ScreenUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type PlaylistUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: PlaylistWhereUniqueInput
    update: XOR<PlaylistUpdateWithoutWorkspaceInput, PlaylistUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<PlaylistCreateWithoutWorkspaceInput, PlaylistUncheckedCreateWithoutWorkspaceInput>
  }

  export type PlaylistUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: PlaylistWhereUniqueInput
    data: XOR<PlaylistUpdateWithoutWorkspaceInput, PlaylistUncheckedUpdateWithoutWorkspaceInput>
  }

  export type PlaylistUpdateManyWithWhereWithoutWorkspaceInput = {
    where: PlaylistScalarWhereInput
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type PlaylistLayoutUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: PlaylistLayoutWhereUniqueInput
    update: XOR<PlaylistLayoutUpdateWithoutWorkspaceInput, PlaylistLayoutUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<PlaylistLayoutCreateWithoutWorkspaceInput, PlaylistLayoutUncheckedCreateWithoutWorkspaceInput>
  }

  export type PlaylistLayoutUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: PlaylistLayoutWhereUniqueInput
    data: XOR<PlaylistLayoutUpdateWithoutWorkspaceInput, PlaylistLayoutUncheckedUpdateWithoutWorkspaceInput>
  }

  export type PlaylistLayoutUpdateManyWithWhereWithoutWorkspaceInput = {
    where: PlaylistLayoutScalarWhereInput
    data: XOR<PlaylistLayoutUpdateManyMutationInput, PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type PlaylistLayoutScalarWhereInput = {
    AND?: PlaylistLayoutScalarWhereInput | PlaylistLayoutScalarWhereInput[] | $Types.Skip
    OR?: PlaylistLayoutScalarWhereInput[] | $Types.Skip
    NOT?: PlaylistLayoutScalarWhereInput | PlaylistLayoutScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"PlaylistLayout"> | string | $Types.Skip
    workspaceId?: StringFilter<"PlaylistLayout"> | string | $Types.Skip
    name?: StringFilter<"PlaylistLayout"> | string | $Types.Skip
    resolutionWidth?: IntFilter<"PlaylistLayout"> | number | $Types.Skip
    resolutionHeight?: IntFilter<"PlaylistLayout"> | number | $Types.Skip
    createdAt?: DateTimeFilter<"PlaylistLayout"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"PlaylistLayout"> | Date | string | $Types.Skip
  }

  export type FileUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutWorkspaceInput, FileUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput>
  }

  export type FileUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutWorkspaceInput, FileUncheckedUpdateWithoutWorkspaceInput>
  }

  export type FileUpdateManyWithWhereWithoutWorkspaceInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type FolderUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutWorkspaceInput, FolderUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<FolderCreateWithoutWorkspaceInput, FolderUncheckedCreateWithoutWorkspaceInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutWorkspaceInput, FolderUncheckedUpdateWithoutWorkspaceInput>
  }

  export type FolderUpdateManyWithWhereWithoutWorkspaceInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type FileUploadSessionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: FileUploadSessionWhereUniqueInput
    update: XOR<FileUploadSessionUpdateWithoutWorkspaceInput, FileUploadSessionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<FileUploadSessionCreateWithoutWorkspaceInput, FileUploadSessionUncheckedCreateWithoutWorkspaceInput>
  }

  export type FileUploadSessionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: FileUploadSessionWhereUniqueInput
    data: XOR<FileUploadSessionUpdateWithoutWorkspaceInput, FileUploadSessionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type FileUploadSessionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: FileUploadSessionScalarWhereInput
    data: XOR<FileUploadSessionUpdateManyMutationInput, FileUploadSessionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceUserInvitationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserInvitationWhereUniqueInput
    update: XOR<WorkspaceUserInvitationUpdateWithoutWorkspaceInput, WorkspaceUserInvitationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceUserInvitationCreateWithoutWorkspaceInput, WorkspaceUserInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserInvitationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserInvitationWhereUniqueInput
    data: XOR<WorkspaceUserInvitationUpdateWithoutWorkspaceInput, WorkspaceUserInvitationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceUserInvitationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceUserInvitationScalarWhereInput
    data: XOR<WorkspaceUserInvitationUpdateManyMutationInput, WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ScreenGroupUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ScreenGroupWhereUniqueInput
    update: XOR<ScreenGroupUpdateWithoutWorkspaceInput, ScreenGroupUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ScreenGroupCreateWithoutWorkspaceInput, ScreenGroupUncheckedCreateWithoutWorkspaceInput>
  }

  export type ScreenGroupUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ScreenGroupWhereUniqueInput
    data: XOR<ScreenGroupUpdateWithoutWorkspaceInput, ScreenGroupUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ScreenGroupUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ScreenGroupScalarWhereInput
    data: XOR<ScreenGroupUpdateManyMutationInput, ScreenGroupUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ScreenGroupScalarWhereInput = {
    AND?: ScreenGroupScalarWhereInput | ScreenGroupScalarWhereInput[] | $Types.Skip
    OR?: ScreenGroupScalarWhereInput[] | $Types.Skip
    NOT?: ScreenGroupScalarWhereInput | ScreenGroupScalarWhereInput[] | $Types.Skip
    id?: StringFilter<"ScreenGroup"> | string | $Types.Skip
    name?: StringFilter<"ScreenGroup"> | string | $Types.Skip
    workspaceId?: StringFilter<"ScreenGroup"> | string | $Types.Skip
    createdAt?: DateTimeFilter<"ScreenGroup"> | Date | string | $Types.Skip
    updatedAt?: DateTimeFilter<"ScreenGroup"> | Date | string | $Types.Skip
    deletedAt?: DateTimeNullableFilter<"ScreenGroup"> | Date | string | null | $Types.Skip
  }

  export type WorkspaceCreateWithoutUserInvitationsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceUncheckedCreateWithoutUserInvitationsInput = {
    id?: string | $Types.Skip
    name: string
    slug: string
    status: string
    picture?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screens?: ScreenUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    playlists?: PlaylistUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    folders?: FolderUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedCreateNestedManyWithoutWorkspaceInput | $Types.Skip
  }

  export type WorkspaceCreateOrConnectWithoutUserInvitationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutUserInvitationsInput, WorkspaceUncheckedCreateWithoutUserInvitationsInput>
  }

  export type UserCreateWithoutSentInvitationsInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionCreateNestedManyWithoutUserInput | $Types.Skip
  }

  export type UserUncheckedCreateWithoutSentInvitationsInput = {
    id?: string | $Types.Skip
    email: string
    emailVerifiedAt?: Date | string | null | $Types.Skip
    name: string
    password: string
    profilePhoto?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedCreateNestedManyWithoutUserInput | $Types.Skip
  }

  export type UserCreateOrConnectWithoutSentInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
  }

  export type UserWorkspaceCreateWithoutWorkspaceInvitationInput = {
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
  }

  export type UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput = {
    userId: string
    workspaceId: string
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserWorkspaceCreateOrConnectWithoutWorkspaceInvitationInput = {
    where: UserWorkspaceWhereUniqueInput
    create: XOR<UserWorkspaceCreateWithoutWorkspaceInvitationInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput>
  }

  export type UserWorkspaceCreateManyWorkspaceInvitationInputEnvelope = {
    data: UserWorkspaceCreateManyWorkspaceInvitationInput | UserWorkspaceCreateManyWorkspaceInvitationInput[]
    skipDuplicates?: boolean | $Types.Skip
  }

  export type WorkspaceUpsertWithoutUserInvitationsInput = {
    update: XOR<WorkspaceUpdateWithoutUserInvitationsInput, WorkspaceUncheckedUpdateWithoutUserInvitationsInput>
    create: XOR<WorkspaceCreateWithoutUserInvitationsInput, WorkspaceUncheckedCreateWithoutUserInvitationsInput>
    where?: WorkspaceWhereInput | $Types.Skip
  }

  export type WorkspaceUpdateToOneWithWhereWithoutUserInvitationsInput = {
    where?: WorkspaceWhereInput | $Types.Skip
    data: XOR<WorkspaceUpdateWithoutUserInvitationsInput, WorkspaceUncheckedUpdateWithoutUserInvitationsInput>
  }

  export type WorkspaceUpdateWithoutUserInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type WorkspaceUncheckedUpdateWithoutUserInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    slug?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    picture?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    layouts?: PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    folders?: FolderUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
    screenGroups?: ScreenGroupUncheckedUpdateManyWithoutWorkspaceNestedInput | $Types.Skip
  }

  export type UserUpsertWithoutSentInvitationsInput = {
    update: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    where?: UserWhereInput | $Types.Skip
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitationsInput = {
    where?: UserWhereInput | $Types.Skip
    data: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutUserNestedInput | $Types.Skip
  }

  export type UserUncheckedUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    password?: StringFieldUpdateOperationsInput | string | $Types.Skip
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    workspaces?: UserWorkspaceUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    userPreferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutUserNestedInput | $Types.Skip
  }

  export type UserWorkspaceUpsertWithWhereUniqueWithoutWorkspaceInvitationInput = {
    where: UserWorkspaceWhereUniqueInput
    update: XOR<UserWorkspaceUpdateWithoutWorkspaceInvitationInput, UserWorkspaceUncheckedUpdateWithoutWorkspaceInvitationInput>
    create: XOR<UserWorkspaceCreateWithoutWorkspaceInvitationInput, UserWorkspaceUncheckedCreateWithoutWorkspaceInvitationInput>
  }

  export type UserWorkspaceUpdateWithWhereUniqueWithoutWorkspaceInvitationInput = {
    where: UserWorkspaceWhereUniqueInput
    data: XOR<UserWorkspaceUpdateWithoutWorkspaceInvitationInput, UserWorkspaceUncheckedUpdateWithoutWorkspaceInvitationInput>
  }

  export type UserWorkspaceUpdateManyWithWhereWithoutWorkspaceInvitationInput = {
    where: UserWorkspaceScalarWhereInput
    data: XOR<UserWorkspaceUpdateManyMutationInput, UserWorkspaceUncheckedUpdateManyWithoutWorkspaceInvitationInput>
  }

  export type DeviceTelemetryCreateManyDeviceInput = {
    id?: string | $Types.Skip
    localIpAddress?: string | null | $Types.Skip
    publicIpAddress?: string | null | $Types.Skip
    macAddress?: string | null | $Types.Skip
    softwareVersion?: string | null | $Types.Skip
    platform?: string | null | $Types.Skip
    osRelease?: string | null | $Types.Skip
    screenResolutionWidth?: number | null | $Types.Skip
    screenResolutionHeight?: number | null | $Types.Skip
    hostname?: string | null | $Types.Skip
    timezone?: string | null | $Types.Skip
    totalMemory?: bigint | number | null | $Types.Skip
    freeMemory?: bigint | number | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceStatusCreateManyDeviceInput = {
    id?: string | $Types.Skip
    isOnline: boolean
    createdAt?: Date | string | $Types.Skip
  }

  export type DeviceTelemetryUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    localIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    publicIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    softwareVersion?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    platform?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    osRelease?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    screenResolutionWidth?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    screenResolutionHeight?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    hostname?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    timezone?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    totalMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    freeMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceTelemetryUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    localIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    publicIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    softwareVersion?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    platform?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    osRelease?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    screenResolutionWidth?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    screenResolutionHeight?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    hostname?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    timezone?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    totalMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    freeMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceTelemetryUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    localIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    publicIpAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    softwareVersion?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    platform?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    osRelease?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    screenResolutionWidth?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    screenResolutionHeight?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    hostname?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    timezone?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    totalMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    freeMemory?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceStatusUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceStatusUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type DeviceStatusUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isOnline?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistItemCreateManyFileInput = {
    id?: string | $Types.Skip
    playlistId: string
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    playlistLayoutSectionId: string
    nestedPlaylistId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlist?: PlaylistUpdateOneRequiredWithoutItemsNestedInput | $Types.Skip
    nestedPlaylist?: PlaylistUpdateOneWithoutParentItemsNestedInput | $Types.Skip
    playlistLayoutSection?: PlaylistLayoutSectionUpdateOneRequiredWithoutPlaylistItemsNestedInput | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    nestedPlaylistId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    nestedPlaylistId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type FolderCreateManyParentInput = {
    id?: string | $Types.Skip
    name: string
    workspaceId: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type FileCreateManyFolderInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    uploaderId?: string | null | $Types.Skip
  }

  export type FileUploadSessionCreateManyFolderInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    workspaceId: string
    uploadId: string
    userId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
  }

  export type FolderUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFoldersNestedInput | $Types.Skip
    subfolders?: FolderUpdateManyWithoutParentNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutFolderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedUpdateManyWithoutParentNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFilesNestedInput | $Types.Skip
    uploader?: UserUpdateOneWithoutUploadedFilesNestedInput | $Types.Skip
    playlistItems?: PlaylistItemUpdateManyWithoutFileNestedInput | $Types.Skip
  }

  export type FileUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutFileNestedInput | $Types.Skip
  }

  export type FileUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
  }

  export type FileUploadSessionUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFileUploadSessionsNestedInput | $Types.Skip
    user?: UserUpdateOneRequiredWithoutFileUploadSessionsNestedInput | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type PlaylistItemCreateManyPlaylistInput = {
    id?: string | $Types.Skip
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    playlistLayoutSectionId: string
    fileId?: string | null | $Types.Skip
    nestedPlaylistId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemCreateManyNestedPlaylistInput = {
    id?: string | $Types.Skip
    playlistId: string
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    playlistLayoutSectionId: string
    fileId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistScreenCreateManyPlaylistInput = {
    screenId: string
  }

  export type PlaylistScheduleCreateManyPlaylistInput = {
    id?: string | $Types.Skip
    startAt: Date | string
    endAt?: Date | string | null | $Types.Skip
    startTime?: string | null | $Types.Skip
    endTime?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    weekdays?: PlaylistScheduleCreateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistItemUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    file?: FileUpdateOneWithoutPlaylistItemsNestedInput | $Types.Skip
    nestedPlaylist?: PlaylistUpdateOneWithoutParentItemsNestedInput | $Types.Skip
    playlistLayoutSection?: PlaylistLayoutSectionUpdateOneRequiredWithoutPlaylistItemsNestedInput | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    fileId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    nestedPlaylistId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    fileId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    nestedPlaylistId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistItemUpdateWithoutNestedPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlist?: PlaylistUpdateOneRequiredWithoutItemsNestedInput | $Types.Skip
    file?: FileUpdateOneWithoutPlaylistItemsNestedInput | $Types.Skip
    playlistLayoutSection?: PlaylistLayoutSectionUpdateOneRequiredWithoutPlaylistItemsNestedInput | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateWithoutNestedPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    fileId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    playlistLayoutSectionId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    fileId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistScreenUpdateWithoutPlaylistInput = {
    screen?: ScreenUpdateOneRequiredWithoutPlaylistsNestedInput | $Types.Skip
  }

  export type PlaylistScreenUncheckedUpdateWithoutPlaylistInput = {
    screenId?: StringFieldUpdateOperationsInput | string | $Types.Skip
  }

  export type PlaylistScreenUncheckedUpdateManyWithoutPlaylistInput = {
    screenId?: StringFieldUpdateOperationsInput | string | $Types.Skip
  }

  export type PlaylistScheduleUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    startTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    endTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    weekdays?: PlaylistScheduleUpdateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScheduleUncheckedUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    startTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    endTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    weekdays?: PlaylistScheduleUpdateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistScheduleUncheckedUpdateManyWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    startTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    endTime?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    weekdays?: PlaylistScheduleUpdateweekdaysInput | $Enums.Weekday[] | $Types.Skip
  }

  export type PlaylistCreateManyLayoutInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type PlaylistLayoutSectionCreateManyPlaylistLayoutInput = {
    id?: string | $Types.Skip
    name: string
    top: number
    left: number
    width: number
    height: number
    zIndex: number
  }

  export type PlaylistUpdateWithoutLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutPlaylistsNestedInput | $Types.Skip
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateWithoutLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateManyWithoutLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type PlaylistLayoutSectionUpdateWithoutPlaylistLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
    playlistItems?: PlaylistItemUpdateManyWithoutPlaylistLayoutSectionNestedInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedUpdateWithoutPlaylistLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutPlaylistLayoutSectionNestedInput | $Types.Skip
  }

  export type PlaylistLayoutSectionUncheckedUpdateManyWithoutPlaylistLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    top?: IntFieldUpdateOperationsInput | number | $Types.Skip
    left?: IntFieldUpdateOperationsInput | number | $Types.Skip
    width?: IntFieldUpdateOperationsInput | number | $Types.Skip
    height?: IntFieldUpdateOperationsInput | number | $Types.Skip
    zIndex?: IntFieldUpdateOperationsInput | number | $Types.Skip
  }

  export type PlaylistItemCreateManyPlaylistLayoutSectionInput = {
    id?: string | $Types.Skip
    playlistId: string
    type: $Enums.PlaylistItemType
    duration?: number | null | $Types.Skip
    fileId?: string | null | $Types.Skip
    nestedPlaylistId?: string | null | $Types.Skip
    order: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistItemUpdateWithoutPlaylistLayoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlist?: PlaylistUpdateOneRequiredWithoutItemsNestedInput | $Types.Skip
    file?: FileUpdateOneWithoutPlaylistItemsNestedInput | $Types.Skip
    nestedPlaylist?: PlaylistUpdateOneWithoutParentItemsNestedInput | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateWithoutPlaylistLayoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    fileId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    nestedPlaylistId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistItemUncheckedUpdateManyWithoutPlaylistLayoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    type?: EnumPlaylistItemTypeFieldUpdateOperationsInput | $Enums.PlaylistItemType | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    fileId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    nestedPlaylistId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    order?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistScreenCreateManyScreenInput = {
    playlistId: string
  }

  export type PlaylistScreenUpdateWithoutScreenInput = {
    playlist?: PlaylistUpdateOneRequiredWithoutScreensNestedInput | $Types.Skip
  }

  export type PlaylistScreenUncheckedUpdateWithoutScreenInput = {
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
  }

  export type PlaylistScreenUncheckedUpdateManyWithoutScreenInput = {
    playlistId?: StringFieldUpdateOperationsInput | string | $Types.Skip
  }

  export type ScreenCreateManyGroupInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type ScreenUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutScreensNestedInput | $Types.Skip
    device?: DeviceUpdateOneWithoutScreenNestedInput | $Types.Skip
    playlists?: PlaylistScreenUpdateManyWithoutScreenNestedInput | $Types.Skip
  }

  export type ScreenUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    device?: DeviceUncheckedUpdateOneWithoutScreenNestedInput | $Types.Skip
    playlists?: PlaylistScreenUncheckedUpdateManyWithoutScreenNestedInput | $Types.Skip
  }

  export type ScreenUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type EmailVerificationTokenCreateManyUserInput = {
    id?: string | $Types.Skip
    token: string
    newEmail?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
  }

  export type SessionCreateManyUserInput = {
    id?: string | $Types.Skip
    token: string
    userAgent: string
    ipAddress: string
    createdAt?: Date | string | $Types.Skip
    revokedAt?: Date | string | null | $Types.Skip
    lastActivityAt?: Date | string | $Types.Skip
  }

  export type UserWorkspaceCreateManyUserInput = {
    workspaceId: string
    workspaceInvitationId?: string | null | $Types.Skip
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserPreferencesCreateManyUserInput = {
    id?: string | $Types.Skip
    locale: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type FileCreateManyUploaderInput = {
    id?: string | $Types.Skip
    workspaceId: string
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    folderId?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type FileUploadSessionCreateManyUserInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    workspaceId: string
    uploadId: string
    folderId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateManyInvitorInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    workspaceId: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type EmailVerificationTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    newEmail?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type EmailVerificationTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    newEmail?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    newEmail?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userAgent?: StringFieldUpdateOperationsInput | string | $Types.Skip
    ipAddress?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userAgent?: StringFieldUpdateOperationsInput | string | $Types.Skip
    ipAddress?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    token?: StringFieldUpdateOperationsInput | string | $Types.Skip
    userAgent?: StringFieldUpdateOperationsInput | string | $Types.Skip
    ipAddress?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput | $Types.Skip
    workspaceInvitation?: WorkspaceUserInvitationUpdateOneWithoutMembersNestedInput | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateWithoutUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceInvitationId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateManyWithoutUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceInvitationId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    locale?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    locale?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserPreferencesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    locale?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type FileUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    folder?: FolderUpdateOneWithoutFilesNestedInput | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFilesNestedInput | $Types.Skip
    playlistItems?: PlaylistItemUpdateManyWithoutFileNestedInput | $Types.Skip
  }

  export type FileUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutFileNestedInput | $Types.Skip
  }

  export type FileUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUploadSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    folder?: FolderUpdateOneWithoutFileUploadSessionsNestedInput | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutFileUploadSessionsNestedInput | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type WorkspaceUserInvitationUpdateWithoutInvitorInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutUserInvitationsNestedInput | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceInvitationNestedInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateWithoutInvitorInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceInvitationNestedInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateManyWithoutInvitorInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceCreateManyWorkspaceInput = {
    userId: string
    workspaceInvitationId?: string | null | $Types.Skip
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type ScreenCreateManyWorkspaceInput = {
    id?: string | $Types.Skip
    groupId?: string | null | $Types.Skip
    name: string
    layoutRotation?: $Enums.LayoutRotation | $Types.Skip
    resolutionWidth: number
    resolutionHeight: number
    type: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type PlaylistCreateManyWorkspaceInput = {
    id?: string | $Types.Skip
    playlistLayoutId?: string | null | $Types.Skip
    name: string
    description?: string | $Types.Skip
    size?: bigint | number | $Types.Skip
    type?: string | $Types.Skip
    isPublished?: boolean | $Types.Skip
    priority?: number | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type PlaylistLayoutCreateManyWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    resolutionWidth: number
    resolutionHeight: number
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type FileCreateManyWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    extension: string
    mimeType: string
    previewPath?: string | null | $Types.Skip
    size: bigint | number
    type: string
    path: string
    width?: number | null | $Types.Skip
    height?: number | null | $Types.Skip
    duration?: number | null | $Types.Skip
    defaultDuration?: number | null | $Types.Skip
    md5?: string | null | $Types.Skip
    folderId?: string | null | $Types.Skip
    availabilityStartAt?: Date | string | null | $Types.Skip
    availabilityEndAt?: Date | string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
    uploaderId?: string | null | $Types.Skip
  }

  export type FolderCreateManyWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    parentId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type FileUploadSessionCreateManyWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    path: string
    size: bigint | number
    uploaded?: bigint | number | $Types.Skip
    parts?: number | $Types.Skip
    mimeType?: string | $Types.Skip
    uploadId: string
    folderId?: string | null | $Types.Skip
    userId: string
    createdAt?: Date | string | $Types.Skip
    completedAt?: Date | string | null | $Types.Skip
  }

  export type WorkspaceUserInvitationCreateManyWorkspaceInput = {
    id?: string | $Types.Skip
    email: string
    status?: string | $Types.Skip
    invitorId?: string | null | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type ScreenGroupCreateManyWorkspaceInput = {
    id?: string | $Types.Skip
    name: string
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
    deletedAt?: Date | string | null | $Types.Skip
  }

  export type UserWorkspaceUpdateWithoutWorkspaceInput = {
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput | $Types.Skip
    workspaceInvitation?: WorkspaceUserInvitationUpdateOneWithoutMembersNestedInput | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateWithoutWorkspaceInput = {
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceInvitationId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateManyWithoutWorkspaceInput = {
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceInvitationId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type ScreenUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    device?: DeviceUpdateOneWithoutScreenNestedInput | $Types.Skip
    playlists?: PlaylistScreenUpdateManyWithoutScreenNestedInput | $Types.Skip
    group?: ScreenGroupUpdateOneWithoutScreensNestedInput | $Types.Skip
  }

  export type ScreenUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    groupId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    device?: DeviceUncheckedUpdateOneWithoutScreenNestedInput | $Types.Skip
    playlists?: PlaylistScreenUncheckedUpdateManyWithoutScreenNestedInput | $Types.Skip
  }

  export type ScreenUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    groupId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    layoutRotation?: EnumLayoutRotationFieldUpdateOperationsInput | $Enums.LayoutRotation | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type PlaylistUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    layout?: PlaylistLayoutUpdateOneWithoutPlaylistsNestedInput | $Types.Skip
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    parentItems?: PlaylistItemUncheckedUpdateManyWithoutNestedPlaylistNestedInput | $Types.Skip
    screens?: PlaylistScreenUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
    schedules?: PlaylistScheduleUncheckedUpdateManyWithoutPlaylistNestedInput | $Types.Skip
  }

  export type PlaylistUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    playlistLayoutId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    description?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    isPublished?: BoolFieldUpdateOperationsInput | boolean | $Types.Skip
    priority?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type PlaylistLayoutUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlists?: PlaylistUpdateManyWithoutLayoutNestedInput | $Types.Skip
    sections?: PlaylistLayoutSectionUpdateManyWithoutPlaylistLayoutNestedInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    playlists?: PlaylistUncheckedUpdateManyWithoutLayoutNestedInput | $Types.Skip
    sections?: PlaylistLayoutSectionUncheckedUpdateManyWithoutPlaylistLayoutNestedInput | $Types.Skip
  }

  export type PlaylistLayoutUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    resolutionWidth?: IntFieldUpdateOperationsInput | number | $Types.Skip
    resolutionHeight?: IntFieldUpdateOperationsInput | number | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type FileUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    folder?: FolderUpdateOneWithoutFilesNestedInput | $Types.Skip
    uploader?: UserUpdateOneWithoutUploadedFilesNestedInput | $Types.Skip
    playlistItems?: PlaylistItemUpdateManyWithoutFileNestedInput | $Types.Skip
  }

  export type FileUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutFileNestedInput | $Types.Skip
  }

  export type FileUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    extension?: StringFieldUpdateOperationsInput | string | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    previewPath?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    type?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    width?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    height?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    duration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    defaultDuration?: NullableIntFieldUpdateOperationsInput | number | null | $Types.Skip
    md5?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    availabilityStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    availabilityEndAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
  }

  export type FolderUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    parent?: FolderUpdateOneWithoutSubfoldersNestedInput | $Types.Skip
    subfolders?: FolderUpdateManyWithoutParentNestedInput | $Types.Skip
    files?: FileUpdateManyWithoutFolderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    parentId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    subfolders?: FolderUncheckedUpdateManyWithoutParentNestedInput | $Types.Skip
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
    fileUploadSessions?: FileUploadSessionUncheckedUpdateManyWithoutFolderNestedInput | $Types.Skip
  }

  export type FolderUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    parentId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUploadSessionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    folder?: FolderUpdateOneWithoutFileUploadSessionsNestedInput | $Types.Skip
    user?: UserUpdateOneRequiredWithoutFileUploadSessionsNestedInput | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type FileUploadSessionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    path?: StringFieldUpdateOperationsInput | string | $Types.Skip
    size?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    uploaded?: BigIntFieldUpdateOperationsInput | bigint | number | $Types.Skip
    parts?: IntFieldUpdateOperationsInput | number | $Types.Skip
    mimeType?: StringFieldUpdateOperationsInput | string | $Types.Skip
    uploadId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    folderId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type WorkspaceUserInvitationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    invitor?: UserUpdateOneWithoutSentInvitationsNestedInput | $Types.Skip
    members?: UserWorkspaceUpdateManyWithoutWorkspaceInvitationNestedInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    invitorId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    members?: UserWorkspaceUncheckedUpdateManyWithoutWorkspaceInvitationNestedInput | $Types.Skip
  }

  export type WorkspaceUserInvitationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    email?: StringFieldUpdateOperationsInput | string | $Types.Skip
    status?: StringFieldUpdateOperationsInput | string | $Types.Skip
    invitorId?: NullableStringFieldUpdateOperationsInput | string | null | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type ScreenGroupUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    screens?: ScreenUpdateManyWithoutGroupNestedInput | $Types.Skip
  }

  export type ScreenGroupUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
    screens?: ScreenUncheckedUpdateManyWithoutGroupNestedInput | $Types.Skip
  }

  export type ScreenGroupUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string | $Types.Skip
    name?: StringFieldUpdateOperationsInput | string | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null | $Types.Skip
  }

  export type UserWorkspaceCreateManyWorkspaceInvitationInput = {
    userId: string
    workspaceId: string
    role?: string | $Types.Skip
    permissions?: UserWorkspaceCreatepermissionsInput | string[] | $Types.Skip
    createdAt?: Date | string | $Types.Skip
    updatedAt?: Date | string | $Types.Skip
  }

  export type UserWorkspaceUpdateWithoutWorkspaceInvitationInput = {
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput | $Types.Skip
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateWithoutWorkspaceInvitationInput = {
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }

  export type UserWorkspaceUncheckedUpdateManyWithoutWorkspaceInvitationInput = {
    userId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    workspaceId?: StringFieldUpdateOperationsInput | string | $Types.Skip
    role?: StringFieldUpdateOperationsInput | string | $Types.Skip
    permissions?: UserWorkspaceUpdatepermissionsInput | string[] | $Types.Skip
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string | $Types.Skip
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}